<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游戏开发之多人匹配系统设计</title>
    <link href="/2023/10/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%A4%9A%E4%BA%BA%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/10/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%A4%9A%E4%BA%BA%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="匹配需求"><a href="#匹配需求" class="headerlink" title="匹配需求"></a>匹配需求</h2><p>玩家可在不同玩法中进行匹配，匹配可分为俩种，组队匹配和单人匹配；</p><ul><li>单人匹配：玩家直接点击匹配，即可进行匹配倒计时；</li><li>组队匹配：玩家创建队伍后，点击匹配，组队至多有三人；</li></ul><p>流程：玩家提交匹配后，数据加入匹配池后，进入匹配计时界面，匹配成功后进入战斗（可能会匹配机器人）；</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>将提交匹配和匹配逻辑拆分；（避免阻塞玩家匹配计时界面，匹配逻辑本身是一个耗时的过程）</li><li>将匹配逻辑拆分成接口，可自定义实现多种方式，依据不同的玩法，指定具体的匹配逻辑；</li><li>将匹配核心逻辑的具体执行定时封装成RunnableTask发送给线程池，线程池负责执行任务；</li><li>可针对不同玩法，允许指定匹配核心逻辑是单线程执行匹配或多线程执行。</li></ul><h2 id="设计框图"><a href="#设计框图" class="headerlink" title="设计框图"></a>设计框图</h2><p><img src="/../image/game/match1.png" alt="img"></p><h2 id="设计类图"><a href="#设计类图" class="headerlink" title="设计类图"></a>设计类图</h2><p><img src="/../image/game/match2.png" alt="img"></p><ul><li>MatchActor: 负责接收匹配任务，通过指定的匹配逻辑加入具体的匹配池</li><li>MatchThreadActor: 匹配线程池管理器</li><li>ICommonMatchLogic: 通用匹配逻辑接口</li><li>Multi3V3RandomMatchLogic: 3v3随机匹配玩法的匹配逻辑具体实现</li><li>MatchData: 根据提交的MatchTask包装的MatchData, 主要对MatchTask添加了状态</li><li>MatchDataMap: 依据玩法设定的一次成功匹配的MatchData集合</li><li>SuccessWaitRemoveQueue：成功匹配等待移除的队列</li></ul>]]></content>
    
    
    <categories>
      
      <category>游戏开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用浅析</title>
    <link href="/2023/10/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B5%85%E6%9E%90/"/>
    <url>/2023/10/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="IO多路复用浅析（Epoll、Poll、-Select）"><a href="#IO多路复用浅析（Epoll、Poll、-Select）" class="headerlink" title="IO多路复用浅析（Epoll、Poll、 Select）"></a>IO多路复用浅析（Epoll、Poll、 Select）</h2><blockquote><p>IO多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步I&#x2F;O,因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO的实现会负责把数据从内核拷贝到用户空间。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看man手册<br>man pagenum <span class="hljs-keyword">function</span> //查看对应的函数原型， pagenum 为页数， <span class="hljs-keyword">function</span>为函数名<br>如： man 2 <span class="hljs-keyword">select</span><br></code></pre></td></tr></table></figure><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-comment">/* According to earlier standards */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="hljs-params"><span class="hljs-function">fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br><br><span class="hljs-comment">//nfds: 监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态</span><br><span class="hljs-comment">//readfds：    监控有读数据到达文件描述符集合，传入传出参数</span><br><span class="hljs-comment">//writefds：监控写数据到达文件描述符集合，传入传出参数</span><br><span class="hljs-comment">//exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数</span><br><span class="hljs-comment">//timeout：    定时阻塞监控时间，3种情况</span><br><span class="hljs-comment">//1.NULL，永远等下去</span><br><span class="hljs-comment">//2.设置timeval，等待固定时间</span><br><span class="hljs-comment">//3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br><span class="hljs-type">long</span> tv_sec; <span class="hljs-comment">/* seconds */</span><br><span class="hljs-type">long</span> tv_usec; <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>; <span class="hljs-comment">//把文件描述符集合里fd清0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>; <span class="hljs-comment">//测试文件描述符集合里fd是否置1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>; <span class="hljs-comment">//把文件描述符集合里fd位置1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *set)</span></span>; <span class="hljs-comment">//把文件描述符集合里所有位清0</span><br><br></code></pre></td></tr></table></figure><p>调用过程如下：<br><img src="/../image/net/io1.png" alt="在这里插入图片描述"><br>fd_set如下所示：<br>types.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ifndef FD_SETSIZE</span><br><span class="hljs-comment">#define FD_SETSIZE  1024</span><br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#define NBBY    8       /* number of bits in a byte */</span><br>typedef long    fd_mask;<br><span class="hljs-comment">#define NFDBITS (sizeof (fd_mask) * NBBY)   /* bits per mask */</span><br><span class="hljs-comment">#define howmany(x,y)    (((x)+((y)-1))/(y))</span><br>typedef struct _types_fd_set &#123;<br>    fd_mask fds_bits[howmany(FD_SETSIZE, NFDBITS)];<br>&#125; _types_fd_set;<br></code></pre></td></tr></table></figure><p>fd_set就是long的数组，数组的大小取决于FD_SETSIZE&#x2F;NFDBITS，如果1个long是8字节64位的话，fds_bits的大小就是16</p><ol><li>默认最大监听描述符个数为1024；但是可以通过内核编译来重设FD_SETSIZE，并且在linux下是FD_SETSIZE限制的是值，文件描述符值的大小不能大于1024</li><li>每次调用时都需要将描述符和事件从用户空间拷贝到内核空间（copy_from_user）</li><li>查询事件时采用遍历轮询的方式，select函数会修改readfds，writefds，exceptfds，如果一个文件描述符就绪，则为1，没就绪则为0，这样调用者要遍历整个位域，通过要通过FD_ISSET宏来找到就绪的文件描述符。时间复杂度 O(n)。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -n  //查看当前最大监听描述符设置<br><span class="hljs-built_in">ulimit</span> -n size //size:具体的值的大小，设置更改<br></code></pre></td></tr></table></figure><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br><span class="hljs-type">int</span> fd;        <span class="hljs-comment">/* 文件描述符 */</span><br><span class="hljs-type">short</span> events;  <span class="hljs-comment">/* 监控的事件 */</span><br><span class="hljs-type">short</span> revents; <span class="hljs-comment">/* 监控事件中满足条件返回的事件 */</span><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">POLL事件类型</span><br><span class="hljs-comment">    The  bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;:</span><br><span class="hljs-comment">POLLIN//普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="hljs-comment">POLLRDNORM//数据可读</span><br><span class="hljs-comment">POLLRDBAND//优先级带数据可读</span><br><span class="hljs-comment">POLLPRI //高优先级可读数据</span><br><span class="hljs-comment">POLLOUT    //普通或带外数据可写</span><br><span class="hljs-comment">POLLWRNORM//数据可写</span><br><span class="hljs-comment">POLLWRBAND//优先级带数据可写</span><br><span class="hljs-comment">POLLERR //发生错误</span><br><span class="hljs-comment">POLLHUP //发生挂起</span><br><span class="hljs-comment">POLLNVAL //描述字不是一个打开的文件</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">nfds //监控数组中有多少文件描述符需要被监控</span><br><span class="hljs-comment">timeout //毫秒级等待</span><br><span class="hljs-comment">-1：//阻塞等，#define INFTIM -1 Linux中没有定义此宏</span><br><span class="hljs-comment"> 0：//立即返回，不阻塞进程</span><br><span class="hljs-comment">&gt;0：//等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ol><li>不同于select，最大监听描述符不设限制（也不是指可以无限大），poll没有用fd_set数据类型，而是使用了pollfd数组（事件基于链表的数据结构存储）</li><li>查询事件时采用遍历轮询的方式，时间复杂度 O(n)</li><li>监听、返回集合分离</li><li>水平触发，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li></ol><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span><span class="hljs-comment">//size：监听数目</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span><br><span class="hljs-function">    <span class="hljs-comment">//epfd：     为epoll_creat的句柄</span></span><br><span class="hljs-function">    <span class="hljs-comment">//op：     表示动作，用3个宏来表示：</span></span><br><span class="hljs-function"><span class="hljs-comment">//EPOLL_CTL_ADD  (注册新的fd到epfd)，</span></span><br><span class="hljs-function"><span class="hljs-comment">//EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span></span><br><span class="hljs-function"><span class="hljs-comment">//EPOLL_CTL_DEL (从epfd删除一个fd)；</span></span><br><span class="hljs-function">    <span class="hljs-comment">//event：        告诉内核需要监听的事件</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> epoll_event </span>&#123;<br><span class="hljs-type">__uint32_t</span> events; <span class="hljs-comment">/* Epoll events */</span><br><span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> &#123;<br><span class="hljs-type">void</span> *ptr;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">uint32_t</span> u32;<br><span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-comment">//EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="hljs-comment">//EPOLLOUT：表示对应的文件描述符可以写</span><br><span class="hljs-comment">//EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="hljs-comment">//EPOLLERR：表示对应的文件描述符发生错误</span><br><span class="hljs-comment">//EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="hljs-comment">//EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br>    <span class="hljs-comment">//EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span><br><span class="hljs-function"><span class="hljs-comment">//events：   用来存内核得到事件的集合，</span></span><br><span class="hljs-function"><span class="hljs-comment">//maxevents：  告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span></span><br><span class="hljs-function"><span class="hljs-comment">//timeout：   是超时时间</span></span><br><span class="hljs-function"><span class="hljs-comment">//-1：   阻塞</span></span><br><span class="hljs-function"><span class="hljs-comment">// 0：   立即返回，非阻塞</span></span><br><span class="hljs-function"><span class="hljs-comment">//&gt;0：   指定毫秒                                                </span></span><br><span class="hljs-function"><span class="hljs-comment">//返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span></span><br></code></pre></td></tr></table></figure><ol><li>无最大监听描述符个数限制（并非无限大）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">通过 <span class="hljs-built_in">cat</span> /proc/sys/fs/file-max 查看<br></code></pre></td></tr></table></figure></li><li>底层基于红黑树和就绪链表，IO的效率不会随着监视fd的数量的增长而下降。不同于之前的轮询，而是通过每个fd定义的回调函数来实现。只有就绪的fd才会执行回调函数。时间复杂度O(1)<blockquote><p>红黑树存储所监控的文件描述符的节点数据，就绪链表存储就绪的文件描述符的节点数据；epoll_ctl将会添加新的描述符，首先判断是红黑树上是否有此文件描述符节点，如果有，则立即返回。如果没有， 则在树干上插入新的节点，并且告知内核注册回调函数。当接收到某个文件描述符过来数据时，那么内核将该节点插入到就绪链表里面。epoll_wait将会接收到消息，并且将数据拷贝到用户空间，清空链表。<br>获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合</p></blockquote></li><li>提供边沿触发ET模式，效率高于LT</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在描述符不是太多的情况下，且大部分描述符处于活跃状态，select, poll仍然是不错的选择，几乎所有的平台都有对他们的实现提供接口，便于移植。</li><li>epoll的底层依然需要设备驱动提供poll回调来作为状态检测基础，但通过 epoll_ctl的EPOLL_CTL_ADD命令把描述符添加进epoll内部管理器里，只需添加一次即可，直到用 epoll_ctl的EPOLL_CTL_DEL命令删除此描述符为止，而不像select&#x2F;poll是每次执行都必须添加，很显然大量减少了描述符在内核和用户空间不断的来回copy的开销。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a><br><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">深入理解select、poll和epoll及区别</a><br><a href="https://www.zhihu.com/question/37219281/answer/74003967">为什么select打开的FD数量有限制，而poll、epoll等打开的FD数量没有限制？</a><br><a href="https://blog.csdn.net/jyy305/article/details/73012706?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">socket编程以及select、epoll、poll示例详解</a><br><a href="https://www.jb51.net/article/97777.htm">linux内核select&#x2F;poll，epoll实现与区别</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令小记</title>
    <link href="/2023/10/25/Git%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/10/25/Git%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a><strong>新建代码库</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录新建一个Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个目录，将其初始化为Git代码库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init [project-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> [url]</span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--list</span><br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> -<span class="hljs-string">e</span> [<span class="hljs-built_in">--global]</span><br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">name</span> <span class="hljs-string">&quot;[name]&quot;</span><br>$ <span class="hljs-string">git</span> <span class="hljs-string">config</span> [<span class="hljs-built_in">--global]</span> <span class="hljs-string">user</span>.<span class="hljs-string">email</span> <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><h1 id="增删文件"><a href="#增删文件" class="headerlink" title="增删文件"></a><strong>增删文件</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加指定目录到暂存区，包括子目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add [<span class="hljs-built_in">dir</span>]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加当前目录的所有文件到暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加每个变化前，都会要求确认</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -p</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> [file1] [file2] ...</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">rm</span> --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改名文件，并且将这个改名放入暂存区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]</span><br></code></pre></td></tr></table></figure><h1 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="hljs-variable">$ </span>git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a><strong>标签</strong></h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 列出所有tag</span><br>$ git <span class="hljs-keyword">tag</span><br><br><span class="hljs-title"># 新建一个tag</span>在当前commit<br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">[tag</span>]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">[tag</span>] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [<span class="hljs-keyword">tag</span>]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [<span class="hljs-keyword">tag</span>]<br></code></pre></td></tr></table></figure><h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a><strong>查看信息</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">显示有变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的版本历史</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示commit历史，以及每次commit发生变更的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">搜索提交历史，根据关键词</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -S [keyword]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个commit之后的所有变动，其<span class="hljs-string">&quot;提交说明&quot;</span>必须符合搜索条件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某个文件的版本历史，包括文件改名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> --follow [file]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git whatchanged [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示指定文件相关的每一次diff</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -p [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示过去5次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -5 --pretty --oneline</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示所有提交过的用户，按提交次数排序</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git shortlog -sn</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示指定文件是什么人在什么时间修改过</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git blame [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示暂存区和工作区的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示暂存区和上一个commit的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff --cached [file]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示工作区与当前分支最新commit之间的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff HEAD</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示两次提交之间的差异</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff [first-branch]...[second-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示今天你写了多少行代码</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交的元数据和内容变化</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交发生变化的文件</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show --name-only [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示某次提交时，某个文件的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git show [commit]:[filename]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示当前分支的最近几次提交</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reflog</span><br></code></pre></td></tr></table></figure><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a><strong>远程同步</strong></h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br><span class="hljs-variable">$ </span>git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br><span class="hljs-variable">$ </span>git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br><span class="hljs-variable">$ </span>git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br><span class="hljs-variable">$ </span>git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="hljs-variable">$ </span>git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br><span class="hljs-variable">$ </span>git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="hljs-variable">$ </span>git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br><span class="hljs-variable">$ </span>git push [remote] --all<br></code></pre></td></tr></table></figure><h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a><strong>撤销</strong></h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="hljs-variable">$ </span>git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br><span class="hljs-variable">$ </span>git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="hljs-variable">$ </span>git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="hljs-variable">$ </span>git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="hljs-variable">$ </span>git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="hljs-variable">$ </span>git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="hljs-variable">$ </span>git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="hljs-variable">$ </span>git stash<br><span class="hljs-variable">$ </span>git stash pop<br></code></pre></td></tr></table></figure><h1 id="一般操作步骤"><a href="#一般操作步骤" class="headerlink" title="一般操作步骤"></a><strong>一般操作步骤</strong></h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git init<br>git <span class="hljs-keyword">add </span>.<br>git commit -m <span class="hljs-string">&quot;注释&quot;</span><br>git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>git@地址<br>git push -u <span class="hljs-keyword">origin </span>master<br></code></pre></td></tr></table></figure><h1 id="玩游戏来练-Git"><a href="#玩游戏来练-Git" class="headerlink" title="玩游戏来练 Git"></a><strong>玩游戏来练 Git</strong></h1><p>项目：<a href="https://github.com/pcottle/learnGitBranching">https://github.com/pcottle/learnGitBranching</a></p><p>网址：<a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">git init<br>git add .<br>git commit -m &quot;说明&quot;<br>git remote add origin git@git.corp.kuaishou.com:wenhoulai/javalearn.git<br>git push -u origin master<br><br><span class="hljs-keyword">error: </span>远程 origin 已经存在。<br>git remote rm origin<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/897271968352576">廖雪峰老师的Git教程</a></p>]]></content>
    
    
    <categories>
      
      <category>运维部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决TimeWait过多的问题</title>
    <link href="/2023/10/25/%E8%A7%A3%E5%86%B3TimeWait%E8%BF%87%E5%A4%9A%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/25/%E8%A7%A3%E5%86%B3TimeWait%E8%BF%87%E5%A4%9A%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="转载-原文链接：https-www-tiejiang-org-27040-html"><a href="#转载-原文链接：https-www-tiejiang-org-27040-html" class="headerlink" title="[转载]原文链接：https://www.tiejiang.org/27040.html"></a>[转载]原文链接：<a href="https://www.tiejiang.org/27040.html">https://www.tiejiang.org/27040.html</a></h2><h2 id="服务端客户端通信连接示意图"><a href="#服务端客户端通信连接示意图" class="headerlink" title="服务端客户端通信连接示意图"></a>服务端客户端通信连接示意图</h2><p><img src="/../image/net/tcp1.png" alt="在这里插入图片描述"></p><h2 id="1、-time-wait的作用："><a href="#1、-time-wait的作用：" class="headerlink" title="1、 time_wait的作用："></a>1、 time_wait的作用：</h2><p>TIME_WAIT状态存在的理由：<br>1）可靠地实现TCP全双工连接的终止<br>在进行关闭连接四次挥手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，<br>因此客户端必须维护状态信息允许它重发最终的ACK。如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。<br>因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭的客户端必须维持状态信息进入TIME_WAIT状态。</p><p>2）允许老的重复分节在网络中消逝<br>TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个原来的迷途分节就称为lost duplicate。<br>在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身（incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。<br>为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。</p><h2 id="2、大量TIME-WAIT造成的影响："><a href="#2、大量TIME-WAIT造成的影响：" class="headerlink" title="2、大量TIME_WAIT造成的影响："></a>2、大量TIME_WAIT造成的影响：</h2><p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。<br>我来解释下这个场景。主动正常关闭TCP连接，都会出现TIMEWAIT。</p><h3 id="为什么我们要关注这个高并发短连接呢？"><a href="#为什么我们要关注这个高并发短连接呢？" class="headerlink" title="为什么我们要关注这个高并发短连接呢？"></a>为什么我们要关注这个高并发短连接呢？</h3><p>有两个方面需要注意：</p><ol><li>高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。</li><li>在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。</li></ol><p>这里有个相对长短的概念，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的(占着茅坑不拉翔)。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费。（说个题外话，从这个意义出发来考虑服务器性能调优的话，长连接业务的服务就不需要考虑TIMEWAIT状态。同时，假如你对服务器业务场景非常熟悉，你会发现，在实际业务场景中，一般长连接对应的业务的并发量并不会很高。<br>综合这两个方面，持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。同时，这些端口都是服务器临时分配，无法用SO_REUSEADDR选项解决这个问题。</p><h3 id="关于time-wait的反思："><a href="#关于time-wait的反思：" class="headerlink" title="关于time_wait的反思："></a>关于time_wait的反思：</h3><p>存在即是合理的，既然TCP协议能盛行四十多年，就证明他的设计合理性。所以我们尽可能的使用其原本功能。<br>依靠TIME_WAIT状态来保证我的服务器程序健壮，服务功能正常。<br>那是不是就不要性能了呢？并不是。如果服务器上跑的短连接业务量到了我真的必须处理这个TIMEWAIT状态过多的问题的时候，我的原则是尽量处理，而不是跟TIMEWAIT干上，非先除之而后快。<br>如果尽量处理了，还是解决不了问题，仍然拒绝服务部分请求，那我会采取负载均衡来抗这些高并发的短请求。持续十万并发的短连接请求，两台机器，每台5万个，应该够用了吧。一般的业务量以及国内大部分网站其实并不需要关注这个问题，一句话，达不到时才需要关注这个问题的访问量。</p><blockquote><p>TCP协议发表：1974年12月，卡恩、瑟夫的第一份TCP协议详细说明正式发表。当时美国国防部与三个科学家小组签定了完成TCP&#x2F;IP的协议，结果由瑟夫领衔的小组捷足先登，首先制定出了通过详细定义的TCP&#x2F;IP协议标准。当时作了一个试验，将信息包通过点对点的卫星网络，再通过陆地电缆<br>，再通过卫星网络，再由地面传输，贯串欧洲和美国，经过各种电脑系统，全程9.4万公里竟然没有丢失一个数据位，远距离的可靠数据传输证明了TCP&#x2F;IP协议的成功。</p></blockquote><h2 id="3、案列分析："><a href="#3、案列分析：" class="headerlink" title="3、案列分析："></a>3、案列分析：</h2><p>首先，根据一个查询TCP连接数，来说明这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ant|awk <span class="hljs-string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#x27;</span><br>LAST_ACK 14<br>SYN_RECV 348<br>ESTABLISHED 70<br>FIN_WAIT1 229<br>FIN_WAIT2 30<br>CLOSING 33<br>TIME_WAIT 18122<br></code></pre></td></tr></table></figure><h3 id="状态描述："><a href="#状态描述：" class="headerlink" title="状态描述："></a>状态描述：</h3><p>CLOSED：无连接是活动的或正在进行<br>LISTEN：服务器在等待进入呼叫<br>SYN_RECV：一个连接请求已经到达，等待确认<br>SYN_SENT：应用已经开始，打开一个连接<br>ESTABLISHED：正常数据传输状态<br>FIN_WAIT1：应用说它已经完成<br>FIN_WAIT2：另一边已同意释放<br>ITMED_WAIT：等待所有分组死掉<br>CLOSING：两边同时尝试关闭<br>TIME_WAIT：另一边已初始化一个释放<br>LAST_ACK：等待所有分组死掉</p><h3 id="命令解释："><a href="#命令解释：" class="headerlink" title="命令解释："></a>命令解释：</h3><p>先来看看netstat：<br>netstat -n<br>Active Internet connections (w&#x2F;o servers)<br>Proto Recv-Q Send-Q Local Address Foreign Address State<br>tcp 0 0 123.123.123.123:80 234.234.234.234:12345 TIME_WAIT<br>你实际执行这条命令的时候，可能会得到成千上万条类似上面的记录，不过我们就拿其中的一条就足够了。</p><h3 id="再来看看awk："><a href="#再来看看awk：" class="headerlink" title="再来看看awk："></a>再来看看awk：</h3><p>滤出tcp开头的记录，屏蔽udp, socket等无关记录。<br>state[]相当于定义了一个名叫state的数组<br>NF<br>表示记录的字段数，如上所示的记录，NF等于6<br>$NF<br>表示某个字段的值，如上所示的记录，$NF也就是$6，表示第6个字段的值，也就是TIME_WAIT<br>state[$NF]表示数组元素的值，如上所示的记录，就是state[TIME_WAIT]状态的连接数<br>++state[$NF]表示把某个数加一，如上所示的记录，就是把state[TIME_WAIT]状态的连接数加一<br>END<br>表示在最后阶段要执行的命令<br>for(key in state)<br>遍历数组</p><h2 id="如何尽量处理TIMEWAIT过多"><a href="#如何尽量处理TIMEWAIT过多" class="headerlink" title="如何尽量处理TIMEWAIT过多?"></a>如何尽量处理TIMEWAIT过多?</h2><p>编辑内核文件&#x2F;etc&#x2F;sysctl.conf，加入以下内容：</p><p>net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间<br>然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效.</p><p>&#x2F;etc&#x2F;sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP&#x2F;IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。<br>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</p><p>如果以上配置调优后性能还不理想，可继续修改一下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/sysctl.conf<br>net.ipv4.tcp_keepalive_time = 1200 <br><span class="hljs-comment">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span><br>net.ipv4.ip_local_port_range = 1024 65000 <br><span class="hljs-comment">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span><br>net.ipv4.tcp_max_syn_backlog = 8192 <br><span class="hljs-comment">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br>net.ipv4.tcp_max_tw_buckets = 5000 <br><span class="hljs-comment">#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。</span><br>默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C/C++哪些情况下会发生CoreDump?</title>
    <link href="/2023/10/25/C-C-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9FCoreDump/"/>
    <url>/2023/10/25/C-C-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9FCoreDump/</url>
    
    <content type="html"><![CDATA[<h2 id="CoreDump"><a href="#CoreDump" class="headerlink" title="CoreDump"></a>CoreDump</h2><blockquote><p>coredump是指当程序出错而异常中断时，OS会把程序工作的当前状态存储成一个coredunmp文件。通常情况下coredump文件包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。<a href="https://baike.baidu.com/item/coredump/10713566?fr=aladdin">百度百科</a></p></blockquote><h2 id="常见造成程序coredump的原因"><a href="#常见造成程序coredump的原因" class="headerlink" title="常见造成程序coredump的原因"></a>常见造成程序coredump的原因</h2><ol><li>内存访问越界（比如数组下标越界）</li><li>堆栈溢出（使用了过大的局部变量，因为局部变量存储在栈中，容易导致溢出；函数递归的深度太大等等）</li><li>非法指针（比如随意的强制转换指针的类型，或者使用了空指针（清理数据时，释放了指针所指向的内存地址，但没有将指针置空，导致其成为野指针。））</li><li>多线程读写的数据未加锁保护。</li><li>多线程程序使用了线程不安全的函数（比如strtok、gethostbyname等）。</li></ol><h2 id="设置生成coredump文件"><a href="#设置生成coredump文件" class="headerlink" title="设置生成coredump文件"></a>设置生成coredump文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@iZ8vbj2dzs3ntek0vbzdz5Z:~/Hugh/test<span class="hljs-comment"># ulimit -c</span><br>0<br></code></pre></td></tr></table></figure><p>在Linux环境下，需要设置。这里输出结果为0，则表示未开启coredump功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -c unlimited<br></code></pre></td></tr></table></figure><p>开启coredump功能，并且不限制coredump文件大小。<br>备注：重启开机后，该设置需要重新设定，避免程序不断产生coredump文件。<br>再次输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@iZ8vbj2dzs3ntek0vbzdz5Z:~/Hugh/test<span class="hljs-comment"># ulimit -c</span><br>unlimited<br></code></pre></td></tr></table></figure><h2 id="常用gdb来调试coredump问题"><a href="#常用gdb来调试coredump问题" class="headerlink" title="常用gdb来调试coredump问题"></a>常用gdb来调试coredump问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb program corefile <span class="hljs-comment">#program 为可执行的程序;corefile为对应的core文件</span><br>bt(backtrace)命令（或者<span class="hljs-built_in">where</span>）<span class="hljs-comment">#查看对应出错的位置</span><br>启动gdb,注意该程序编译需要-g选项进行。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CORE_SIZE   1024 * 1024 * 500</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span> <span class="hljs-title">rlmt</span>;</span><br>    <span class="hljs-keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    &#125;   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before set rlimit CORE dump current is:%d, max is:%d\n&quot;</span>, (<span class="hljs-type">int</span>)rlmt.rlim_cur, (<span class="hljs-type">int</span>)rlmt.rlim_max);<br><br>    rlmt.rlim_cur = (<span class="hljs-type">rlim_t</span>)CORE_SIZE;<br>    rlmt.rlim_max  = (<span class="hljs-type">rlim_t</span>)CORE_SIZE;<br><br>    <span class="hljs-keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    &#125;   <br><br>    <span class="hljs-keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    &#125;   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After set rlimit CORE dump current is:%d, max is:%d\n&quot;</span>, (<span class="hljs-type">int</span>)rlmt.rlim_cur, (<span class="hljs-type">int</span>)rlmt.rlim_max);<br><br>    <span class="hljs-comment">/*测试非法内存，产生core文件*/</span><br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>    *ptr = <span class="hljs-number">10</span>; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/c++/coredump1.png" alt="在这里插入图片描述"></p><p>通过查看core文件，发现错误的地方在 main函数里面。<br>输入bt或where可以显示出所有的堆栈信息。</p><h2 id="常见错误举例"><a href="#常见错误举例" class="headerlink" title="常见错误举例"></a>常见错误举例</h2><ol><li><p>除0错误<br>除零错误、参数为空指针、迭代器失效等问题属于程序堆栈本身代码出错，可以通过gdb查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> c;<br>    c=b/a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/c++/coredump2.png" alt="在这里插入图片描述"></p></li><li><p>内存越界</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br>    buf[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//strcpy(buf,&quot;111111111&quot;);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf is %p:%s\n&quot;</span>,buf,buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/c++/coredump3.png" alt="在这里插入图片描述"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/java20130726/p/3218455.html">C++中Segmentation fault(Core Dump)错误处理</a><br><a href="https://www.cnblogs.com/s-lisheng/p/11278193.html">Linux下core dump</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2023/10/25/%E5%89%91%E6%8C%87offer/"/>
    <url>/2023/10/25/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s[r]))<br>                l = <span class="hljs-built_in">max</span>(l, mp[s[r]]+<span class="hljs-number">1</span>);<br>            mp[s[r]] = r;<br>            r++;<br>            res = <span class="hljs-built_in">max</span>(res, r-l);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><p>现有矩阵 matrix 如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。<br>给定 target &#x3D; 20，返回 false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二分</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findtarget</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; mat, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mat[mid] == target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mat[mid] &lt; target)<br>            &#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                right = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findtarget</span>(matrix[i], <span class="hljs-number">0</span>, matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, target))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; j &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)<br>                i++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j]&gt;target)<br>                j--;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;     <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p><blockquote><p>输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j)<br>            &#123;<br>                res = <span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">max</span>(dp[i-j]*j,(i-j)*j));<br>            &#125;<br>            dp[i] = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* ret = head;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)<br>            &#123;<br>                head-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                head-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            head = head-&gt;next;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">NULL</span>)<br>            head-&gt;next = l2;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">NULL</span>)<br>            head-&gt;next = l1;<br>        <span class="hljs-keyword">return</span> ret-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h2><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &lt; nums[i])<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(dq.<span class="hljs-built_in">front</span>());<br>                <span class="hljs-keyword">if</span>(nums[i-k+<span class="hljs-number">1</span>] == dq.<span class="hljs-built_in">front</span>())<br>                    dq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            &#123;<br>                grid[i][j] += <span class="hljs-built_in">max</span>(grid[i<span class="hljs-number">-1</span>][j],grid[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><blockquote><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j , <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= board.<span class="hljs-built_in">size</span>() || j &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || board[i][j] != word[w]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(w == word.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp = board[i][j];<br>        board[i][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(    <span class="hljs-built_in">dfs</span>(board,word,i<span class="hljs-number">-1</span>,j,w+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board,word,i,j+<span class="hljs-number">1</span>,w+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board,word,i+<span class="hljs-number">1</span>,j,w+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board,word,i,j<span class="hljs-number">-1</span>,w+<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        board[i][j] = tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,i,j,<span class="hljs-number">0</span>))<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> inf = <span class="hljs-number">1e9</span>;<br>        <span class="hljs-type">int</span> minprice = inf, maxprofit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> price: prices)<br>        &#123;<br>            maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>            minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxprofit;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分</p><blockquote><p>输入：nums &#x3D; [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt; high)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>                low++;<br>            <span class="hljs-built_in">swap</span>(nums[low],nums[high]);<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                high--;<br>            <span class="hljs-built_in">swap</span>(nums[low],nums[high]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><blockquote><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(maxqt.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> maxqt.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        qt.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span>(!maxqt.<span class="hljs-built_in">empty</span>() &amp;&amp; maxqt.<span class="hljs-built_in">back</span>() &lt; value)<br>        &#123;<br>            maxqt.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        maxqt.<span class="hljs-built_in">push_back</span>(value);<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(qt.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res = qt.<span class="hljs-built_in">front</span>();<br>        qt.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(res == maxqt.<span class="hljs-built_in">front</span>())<br>            maxqt.<span class="hljs-built_in">pop_front</span>();<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; qt;<br>    deque&lt;<span class="hljs-type">int</span>&gt; maxqt;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p><blockquote><p>输入：n &#x3D; 2<br>输出：2<br>输入：n &#x3D; 7<br>输出：21</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>];<br>        <span class="hljs-type">int</span> dq[<span class="hljs-number">101</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">101</span>; ++i)<br>        &#123;<br>            dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>])%<span class="hljs-number">1000000007</span>;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><blockquote><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>            <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>|| matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> b = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">for</span>(;;)<br>            &#123;<br>                <span class="hljs-comment">//左至右</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)<br>                    res.<span class="hljs-built_in">push_back</span>(matrix[t][i]);                <br>                <span class="hljs-keyword">if</span>(++t &gt; b) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = t; i &lt;= b; ++i)<br>                    res.<span class="hljs-built_in">push_back</span>(matrix[i][r]);                <br>                <span class="hljs-keyword">if</span>(--r &lt; l) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = r; i &gt;= l; --i)<br>                    res.<span class="hljs-built_in">push_back</span>(matrix[b][i]);                <br>                <span class="hljs-keyword">if</span>(--b &lt; t) <span class="hljs-keyword">break</span>;    <br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b; i &gt;= t; --i)<br>                    res.<span class="hljs-built_in">push_back</span>(matrix[i][l]);                <br>                <span class="hljs-keyword">if</span>(++l &gt; r) <span class="hljs-keyword">break</span>;  <br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-59-I-滑动窗口的最大值-1"><a href="#剑指-Offer-59-I-滑动窗口的最大值-1" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h2><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p>思路：<br>维护一个单调递减的双端队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &lt; nums[i])<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(dq.<span class="hljs-built_in">front</span>());<br>                <span class="hljs-keyword">if</span>(nums[i-k+<span class="hljs-number">1</span>] == dq.<span class="hljs-built_in">front</span>())<br>                    dq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.<br>返回链表 4-&gt;5.</p></blockquote><p>思路：<br>利用一个节点先走k步，然后另外一个节点开始走，走到末尾就可以找到倒数第k个节点了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* p1 = head;<br>        ListNode* p2 = p1;<br>        <span class="hljs-keyword">while</span>(k--)<br>        &#123;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p2 != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            p1 = p1-&gt;next;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><blockquote><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p></blockquote><p>思路: </p><ol><li>去掉头尾的空格</li><li>从尾部开始遍历，遍历到空格的地方，利用substr() 截取对应长度的字符串，加入结果结合中<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> len  = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span>&amp;&amp; len != <span class="hljs-number">0</span>)<br>            &#123;<br>                res+=s.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>,len)+<span class="hljs-string">&quot; &quot;</span>;<br>                len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] != <span class="hljs-string">&#x27; &#x27;</span>) len++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(len != <span class="hljs-number">0</span>) res+=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,len) +<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) res.<span class="hljs-built_in">erase</span>(res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-59-II-队列的最大值-1"><a href="#剑指-Offer-59-II-队列的最大值-1" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1</p><blockquote><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> maxqt.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : maxqt.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        qt.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">while</span>(!maxqt.<span class="hljs-built_in">empty</span>() &amp;&amp; maxqt.<span class="hljs-built_in">back</span>() &lt; value)<br>            maxqt.<span class="hljs-built_in">pop_back</span>();<br>        maxqt.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(qt.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> front = qt.<span class="hljs-built_in">front</span>();<br>        qt.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(front == maxqt.<span class="hljs-built_in">front</span>())<br>            maxqt.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">return</span> front;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; qt;<br>    deque&lt;<span class="hljs-type">int</span>&gt; maxqt;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h2><p>给定一棵二叉搜索树，请找出其中第k大的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: root = [3,1,4,null,2], k = 1<br>   3<br>  / \<br> 1   4<br>  \<br>   2<br>输出: 4<br></code></pre></td></tr></table></figure><p>思路：<br>对于二叉搜索树来说，中序遍历可以得到有序数组，第k大即为倒数第k个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">traverse</span>(root,res); <br>        <span class="hljs-comment">// for(int i = 0; i &lt; res.size(); ++i)  </span><br>        <span class="hljs-comment">//     std::cout &lt;&lt; res[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-keyword">return</span> res[res.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left,res);     <br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traverse</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* p = head;<br>        ListNode* q = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* tmp = p-&gt;next;<br>            p-&gt;next = q;<br>            q = p;<br>            p = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。<br>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22<br>思路：</p><ol><li>递归终止条件：当前目标和为0，且为叶子节点</li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \    / \<br>        7    2  5   1<br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; vs;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>        <span class="hljs-built_in">path</span>(root, sum, vc);<br>        <span class="hljs-keyword">return</span> vs;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">path</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vc)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> tmp = sum - root-&gt;val;<br>        vc.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(tmp == <span class="hljs-number">0</span> &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)<br>        &#123;<br>            vs.<span class="hljs-built_in">push_back</span>(vc);<br>        &#125;<br>        <span class="hljs-built_in">path</span>(root-&gt;left, tmp, vc);<br>        <span class="hljs-built_in">path</span>(root-&gt;right, tmp, vc);<br>        vc.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>例如，<br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5<br>设计一个支持以下两种操作的数据结构：<br>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数</p><blockquote><p>输入：<br>[“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[1],[2],[],[3],[]]<br>输出：[null,null,null,1.50000,null,2.00000]<br>输入：<br>[“MedianFinder”,”addNum”,”findMedian”,”addNum”,”findMedian”]<br>[[],[2],[],[3],[]]<br>输出：[null,null,2.00000,null,2.50000]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        lt.<span class="hljs-built_in">push</span>(num);<br>        ht.<span class="hljs-built_in">push</span>(lt.<span class="hljs-built_in">top</span>());<br>        lt.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(lt.<span class="hljs-built_in">size</span>() &lt; ht.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            lt.<span class="hljs-built_in">push</span>(ht.<span class="hljs-built_in">top</span>());<br>            ht.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lt.<span class="hljs-built_in">size</span>() &gt; ht.<span class="hljs-built_in">size</span>() ? (<span class="hljs-type">double</span>) lt.<span class="hljs-built_in">top</span>() : (lt.<span class="hljs-built_in">top</span>() + ht.<span class="hljs-built_in">top</span>()) * <span class="hljs-number">0.5</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//将较小的部分存在大根堆，较大的部分存在小根堆</span><br>    <span class="hljs-comment">//大根堆元素个数 - 小根堆元素个数 = 0 或者 1</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; ht;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; lt;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>要求时间复杂度为O(n)</p><blockquote><p>输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><ol><li>dp[i]:第i个数时,连续最大子数组和</li><li>dp[i] &#x3D; max(dp[i-1]+nums[i], nums[i])</li><li>dp[i] &#x3D; nums[0]</li><li>maxs &#x3D; max(dp[i], maxs)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> maxs = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>            maxs = <span class="hljs-built_in">max</span>(maxs, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxs;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxs = INT_MIN;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum &lt;= <span class="hljs-number">0</span>)<br>                sum = num;<br>            <span class="hljs-keyword">else</span><br>                sum += num;<br>            maxs = <span class="hljs-built_in">max</span>(maxs, sum);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxs;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h2><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><blockquote><p>这里是引用<br>输入: “42”<br>输出: 42<br>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字<br>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>因此无法执行有效的转换<br>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>因此返回 INT_MIN (−231)</p></blockquote><p>思路：</p><p>1. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; str[index] == <span class="hljs-string">&#x27; &#x27;</span>)<br>            index++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i&lt; str.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i == index &amp;&amp; (str[index] == <span class="hljs-string">&#x27;-&#x27;</span> || str[index] == <span class="hljs-string">&#x27;+&#x27;</span>))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(str[index] == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                &#123;<br>                    flag = <span class="hljs-number">-1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[index] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>                &#123;<br>                    flag = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(str[i]))<br>            &#123;<br>                res = (res*<span class="hljs-number">10</span>+(str[i]-<span class="hljs-string">&#x27;0&#x27;</span>));<br>                <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span> &amp;&amp; res &gt; INT_MAX)<br>                    <span class="hljs-keyword">return</span> INT_MAX;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span> &amp;&amp; -res &lt; INT_MIN)<br>                    <span class="hljs-keyword">return</span> INT_MIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res*flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><blockquote><p>例如:<br>给定的树 A:<br>输入：A &#x3D; [1,2,3], B &#x3D; [3,1]<br>输出：false</p></blockquote><p>思路：</p><ol><li>二叉树相关首先想到递归解决，递归问题应当单独设计一个子函数，避免受一些特殊情况</li><li>递归终止条件：<br>（1）B &#x3D;&#x3D; NULL 子树查找完成: TRUE<br>（2）B !&#x3D; NULL &amp;&amp; A &#x3D;&#x3D; NULL: FALSE</li><li>递归顺序：<br>（1）当前节点<br>（2）左子树<br>（3）右子树<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">NULL</span> || A == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(A,B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode*A, TreeNode*B)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> A-&gt;val == B-&gt;val &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(A-&gt;right, B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://img-blog.csdnimg.cn/20200910141948527.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p,q);<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span>(right != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之字符串</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>思路：</p><ol><li>明确字串含义：连续的字符串，区别于子序列</li><li>如何区别字符串重复？哈希表</li><li>如何计算长度？利用下标，右下标-左下标（双指针）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(s[r]))<br>                l = <span class="hljs-built_in">max</span>(l, mp[s[r]]+<span class="hljs-number">1</span>);<br>            mp[s[r]] = r;<br>            r++;<br>            res = <span class="hljs-built_in">max</span>(res, r-l);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入</p><blockquote><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        string res;<br>        stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>        stack&lt;string&gt; str;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        string tmp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>               num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>                num = <span class="hljs-number">0</span>;<br>                str.<span class="hljs-built_in">push</span>(tmp);<br>                tmp.<span class="hljs-built_in">clear</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>))<br>                tmp += s[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>                &#123;<br>                    str.<span class="hljs-built_in">top</span>() += tmp;<br>                &#125;<br>                tmp = str.<span class="hljs-built_in">top</span>();<br>                str.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        res += tmp;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之栈</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></p><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p></blockquote><p>分析</p><ol><li>判断字符串是否有效的规则是括号能匹配上且正确顺序闭合；</li><li>括号匹配有先来后匹配的顺序要求，类似于栈的存储方式，考虑用栈实现</li><li>字符串中除了<strong>左</strong>括号就是<strong>右</strong>括号，遍历时遇见左括号就压入栈中对应的右括号，当出现右括号时去对比栈顶元素，相等则弹出后继续，否则无法匹配。</li><li>如果遍历完成后栈为空则完全匹配，如果需要匹配的时候栈已经为空则不匹配</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>        Stack&lt;Character&gt; st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                st.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>                st.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                st.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.isEmpty() || c != st.pop())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></p><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p></blockquote><p>示例:</p><blockquote><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]<br>输出：<br>[null,null,null,null,-3,null,0,-2]<br>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><p>思考：</p><ol><li>求最小栈，常数时间内检索到</li><li>需要一个栈用于存储数据，再加一个栈来存储当前位置栈的最小值，其实一个单调栈的概念</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">```java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; st;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minSt;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        st = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minSt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        st.push(val);<br>        <span class="hljs-keyword">if</span> (minSt.isEmpty() || val &lt;= minSt.peek()) &#123;<br>            minSt.push(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minSt.push(minSt.peek());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(!st.empty()) &#123;<br>            st.pop();<br>            minSt.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> st.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minSt.peek();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之设计</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点</p><blockquote><p>MyLinkedList linkedList &#x3D; new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   &#x2F;&#x2F;链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回2<br>linkedList.deleteAtIndex(1);  &#x2F;&#x2F;现在链表是1-&gt; 3<br>linkedList.get(1);            &#x2F;&#x2F;返回3</p></blockquote><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU缓存机制</a></h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字&#x2F;值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><blockquote><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p></blockquote><p>思路：</p><ol><li>采用链表+哈希表实现，利用哈希查找的时间复杂度为O(1),链表插入删除元素的时间复杂度为O(1),这里使用双向链表，如果使用单链表的话，删除元素需要保存其前向节点，所以直接使用双向链表；</li><li>ltcached的每一个节点是（key,val）对，mp的关键字是key，值为key对应的链表节点的迭代器；</li><li>根据LRU规则，判断是否存在key,存在则返回对应的val（由于mp[key]存放的时链表节点的迭代器，所以val &#x3D; mp[key]-&gt;second），删除该元素，并将元素重新插入链表头，若超出容量指责删除链表尾部元素；不存在则返回-1；</li><li>插入元素时，若存在，更新值即可，并删除该元素，插入链表头部；若不存在，在容量达到最大值的情况下，删除链表尾部元素；每次更新时，同样需要更新mp中的值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) <br>        :<span class="hljs-built_in">cap</span>(capacity)&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(key)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> val = map[key]-&gt;second;<br>            list_cache.<span class="hljs-built_in">erase</span>(map[key]);<br>            list_cache.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">make_pair</span>(key,val));<br>            map[key]=list_cache.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>)<br>        &#123;<br>            list_cache.<span class="hljs-built_in">front</span>() = <span class="hljs-built_in">make_pair</span>(key,value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list_cache.<span class="hljs-built_in">size</span>() == cap)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> p = list_cache.<span class="hljs-built_in">back</span>();<br>            map.<span class="hljs-built_in">erase</span>(p.first);<br>            list_cache.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        list_cache.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>        map[key]=list_cache.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; list_cache;<br>    unordered_map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator&gt; map;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DlinkNode</span> &#123;<br>    <span class="hljs-type">int</span> key, value;<br>    DlinkNode* prev;<br>    DlinkNode* next;<br>    <span class="hljs-built_in">DlinkNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">DlinkNode</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, DlinkNode*&gt; cache;<br>    DlinkNode* head;<br>    DlinkNode* tail;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DlinkNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DlinkNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span><br>        DlinkNode* node = cache[key];<br>        <span class="hljs-built_in">moveToHead</span>(node);<br>        <span class="hljs-keyword">return</span> node-&gt;value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span><br>            DlinkNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DlinkNode</span>(key, value);<br>            <span class="hljs-comment">// 添加进哈希表</span><br>            cache[key] = node;<br>            <span class="hljs-comment">// 添加至双向链表的头部</span><br>            <span class="hljs-built_in">addToHead</span>(node);<br>            ++size;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;<br>                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span><br>                DlinkNode* removed = <span class="hljs-built_in">removeTail</span>();<br>                <span class="hljs-comment">// 删除哈希表中对应的项</span><br>                cache.<span class="hljs-built_in">erase</span>(removed-&gt;key);<br>                <span class="hljs-comment">// 防止内存泄漏</span><br>                <span class="hljs-keyword">delete</span> removed;<br>                --size;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br>            DlinkNode* node = cache[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DlinkNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        node-&gt;prev = head;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        head-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DlinkNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DlinkNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br><br>    <span class="hljs-function">DlinkNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        DlinkNode* node = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之动态规划</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><blockquote><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。.  1 阶 + 1 阶       ;  2 阶</p></blockquote><p>思路：</p><ol><li>dp[i]爬到第i阶的方法</li><li>dp[i] &#x3D; dp[i-1] + dp[i-2]</li><li>dp[0] &#x3D; 1;</li><li>dp[1] &#x3D; 1;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>        &#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>]+ dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><blockquote><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p></blockquote><p>思路：</p><ol><li>dp[i]表示偷第i个元素时可以获得的<strong>最大</strong>利润</li><li>dp[i] &#x3D; max(dp[i-1],dp[i-2]+num[i]); 可以理解为偷不偷当前房屋，偷则dp[i-2]+nums[i], 不偷则dp[i-1]，比较俩种方式的最大金额。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//处理边界条件</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i&lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><blockquote><p>输入: [2,3,2]<br>输出: 3<br>解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p></blockquote><p>思路：</p><p>1. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>z        <span class="hljs-type">int</span> prevMax = <span class="hljs-number">0</span>, prevvMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curMax = <span class="hljs-number">0</span>, currMax = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = curMax;<br>            curMax = <span class="hljs-built_in">max</span>(prevMax + nums[i], curMax);<br>            prevMax = tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = currMax;<br>            currMax = <span class="hljs-built_in">max</span>(prevvMax + nums[i], currMax);<br>            prevvMax = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(curMax,currMax);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><p>思路：</p><ol><li>获取最大利润，需要买卖差值最大</li><li>对于当前节点，确定之前最低价值，当前值-最低值&#x3D;当前最大收益，最大收益&#x3D;max(当前最大收益)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxpro = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minpri = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> price: prices)<br>        &#123;<br>            minpri = <span class="hljs-built_in">min</span>(minpri, price);<br>            maxpro = <span class="hljs-built_in">max</span>(maxpro, price - minpri);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxpro;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><blockquote><p>输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出: 3<br>解释: 11 &#x3D; 5 + 5 + 1<br>输入: coins &#x3D; [2], amount &#x3D; 3<br>输出: -1<br>说明:<br>你可以认为每种硬币的数量是无限的。</p></blockquote><p>思路：</p><ol><li>dp[i]表示金额为i时凑硬币的最小个数</li><li>dp[i] &#x3D; min(dp[i], (dp[i-coins[0]]…dp[i-coins[j]]) +1)</li><li>dp[0] &#x3D; 0<br>注意：</li><li>边界条件： i-coins[j] &lt; 0 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-built_in">sort</span>(coins.<span class="hljs-built_in">begin</span>(), coins.<span class="hljs-built_in">end</span>());<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i - coins[j] &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-coins[j]]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        res = dp[amount] == amount+<span class="hljs-number">1</span> ? <span class="hljs-number">-1</span>: dp[amount];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少</p><blockquote><p>输入: n &#x3D; 12<br>输出: 3<br>解释: 12 &#x3D; 4 + 4 + 4.</p></blockquote><p>思路：</p><ol><li>类似与凑零钱，只是零钱的金额为完全平方数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j*j &lt;= i; ++j)<br>            &#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-j*j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置</p><blockquote><p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt;= j; ++i)<br>        &#123;<br>            j = <span class="hljs-built_in">max</span>(j,i+nums[i]);<br>            <span class="hljs-keyword">if</span>(j &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置</p><blockquote><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><p>思路：</p><ol><li>dp[i]表示跳到第i个元素时需要的最少步数</li><li>dp[i] &#x3D; min(dp[i], dp[i-num[j]+1)</li><li>dp[0] &#x3D; 0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxPos = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>, step = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) <br>        &#123;<br>            maxPos = <span class="hljs-built_in">max</span>(maxPos, i + nums[i]);<br>            <span class="hljs-keyword">if</span> (i == end) <br>            &#123;<br>                end = maxPos;<br>                ++step;<br>            &#125;       <br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入: <span class="hljs-number">3</span><br>输出: <span class="hljs-number">5</span><br>解释:<br>给定 n = <span class="hljs-number">3</span>, 一共有 <span class="hljs-number">5</span> 种不同结构的二叉搜索树:<br>   <span class="hljs-number">1</span>         <span class="hljs-number">3</span>     <span class="hljs-number">3</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span><br>    \       /     /      / \      \<br>     <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     <span class="hljs-number">1</span>      <span class="hljs-number">1</span>   <span class="hljs-number">3</span>      <span class="hljs-number">2</span><br>    /     /       \                 \<br>   <span class="hljs-number">2</span>     <span class="hljs-number">1</span>         <span class="hljs-number">2</span>                 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>思路：</p><ol><li>dp[i]表示1…i为节点组成的二叉搜索树的个数</li><li>dp[i] +&#x3D; dp[j-1]*dp[i-j]</li><li>dp[0] &#x3D; 1;<br> dp[1] &#x3D; 1;<br> 以i根节点的二叉搜索树的个数为sum(以i-j为根节点的个数*以i+j为根节点的个数) (j&#x3D; 0…i)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>       <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>       dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>       dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>       &#123;<br>           <span class="hljs-comment">//以j为根节点的不同情况</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j)<br>           &#123;<br>               dp[i] += dp[j<span class="hljs-number">-1</span>]*dp[i-j];<br>           &#125;<br>       &#125; <br>       <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0</p><blockquote><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。</p></blockquote><p>思路：</p><ol><li>dp[i][j]表示text1到第i个元素时text2到第j个元素最长公共子序列的值</li><li>text1[i] &#x3D;&#x3D; text2[j] : dp[i][j] &#x3D; dp[i-1][j-1]+1;</li><li>text1[i] !&#x3D; text2[j] : dp[i][j] &#x3D; max(dp[i][j-1],dp[i-1][j])</li><li>res &#x3D; dp[m][n](m &#x3D; text1.size(), n &#x3D; text2.size())<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(text2.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text1.<span class="hljs-built_in">size</span>(); ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; text2.<span class="hljs-built_in">size</span>(); ++j)<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text1.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; text2.<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(text1[i] == text2[j])<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.<span class="hljs-built_in">size</span>()][text2.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度</p><blockquote><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:<br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p></blockquote><p>思路：</p><ol><li>dp[i]表示第i个元素时的最长上升子序列长度</li><li>dp[i] &#x3D; max(dp[i],dp[j]+1)(j:0-i if(nums[i] &gt; nums[j])</li><li>由于不是找连续子序列，所以用单调栈去解决实现会出现问题</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><blockquote><p>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].<br>输入: [1, 2, 3, 5]<br>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p></blockquote><p>思路：</p><ol><li>划分俩个数组，使各自和相等。转化成求目标值和sum&#x2F;2的子数组</li><li>对于每一个元素，存在俩种选择，选和不选</li><li>dp[i] : 到第i个元素时，能否找到目标和sum&#x2F;2的数组</li><li>dp[i] &#x3D; dp[i] || dp[j-nums[i]]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//递归实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> res = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(res || target &lt; <span class="hljs-number">0</span> || index &gt;= nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)<br>        &#123;<br>            res = <span class="hljs-literal">true</span>; <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">find</span>(nums, index+<span class="hljs-number">1</span>, target-nums[index]);<br>        <span class="hljs-built_in">find</span>(nums, index+<span class="hljs-number">1</span>, target);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            sum += nums[i];<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">find</span>(nums, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<span class="hljs-comment">//备忘录实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) sum+=nums[i];<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = sum;j &gt;= nums[i]; j--)<br>            &#123;<br>                dp[j]= dp[j]||dp[j-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[sum];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><blockquote><p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”<br>利用栈进行括号匹配，弹出有效括号对，剩下的即是无效括号元素</p></blockquote><p>思路：</p><ol><li>用栈存储元素下标，如果栈不为空，且将要插入的元素为‘）’，栈顶元素为‘（’，则将栈顶元素弹出，否则压入栈中；</li><li>如果此时栈为空，直接返回总长度，代表所有括号都匹配；</li><li>如果栈不为空，则依次弹出栈顶元素，作插值（注意栈顶元素可能不为元素总长度，栈底元素可能不为0，需要考虑到），取最大差值，就是我们要求的答案。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxans = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; s[stk.<span class="hljs-built_in">top</span>()] == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<br>                stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span><br>                stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-type">int</span> tmp = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            maxans = <span class="hljs-built_in">max</span>(maxans, tmp - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>);<br>            tmp = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        maxans = <span class="hljs-built_in">max</span>(maxans, tmp);<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><blockquote><p>输入：”abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”<br>输入：”aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p></blockquote><p>思路：</p><ol><li>dp[i][j]表示s[i]-s[j]是否为回文子串</li><li>dp[i][j] &#x3D; s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1]</li><li>j &#x3D;&#x3D; i  dp[i][j]  &#x3D; true</li><li>j - i &lt;&#x3D; 2 若 s[i] &#x3D;&#x3D; s[j] ,dp[i][j]  &#x3D; true</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>()));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); ++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = j; i &gt;= <span class="hljs-number">0</span>; --i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j] &amp;&amp; (j-i &lt;= <span class="hljs-number">2</span> || dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]))<br>                &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><blockquote><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>输入: “cbbd”<br>输出: “bb”</p></blockquote><p>思路：</p><ol><li>找出所有字串，判断是否是回文串</li><li>去最大值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//暴力解法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(i,j-i+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(str))<br>                    res = res.<span class="hljs-built_in">size</span>() &gt; str.<span class="hljs-built_in">size</span>() ? res : str;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i] != s[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>dp[i][j] 表示以i为开头，j为结尾的子串是否为回文子串</li><li>dp[i][j] &#x3D; (s[i]  &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1])</li><li>j &#x3D;&#x3D; i -&gt; dp[i][j] &#x3D; true</li><li>j - i &#x3D;&#x3D; 1 -&gt; s[i] &#x3D;&#x3D; s[j] 则 dp[i][j] &#x3D; true</li><li>j - i &#x3D;&#x3D; 2 -&gt; s[i] &#x3D;&#x3D; s[j] dp[i][j] &#x3D; true</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <br>        <span class="hljs-keyword">return</span> s;<br>        string res;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>()));<br>        res = s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = j; i &gt;= <span class="hljs-number">0</span>; i--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">2</span> || dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]))<br>                &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(j - i &gt; len)<br>                    &#123;<br>                        res = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>                        len = j - i;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p>思路：<br>总是希望能加到能使连续数组的综合变大的数；<br>如果加了之后，比当前值还小，则选择以这个元素为开头重新再来。</p><ol><li>利用dp[i] 表征 以nums[i]元素结尾的连续数组的最大和</li><li>dp[i] &#x3D; max( nums[i], dp[i-1] + nums[i])</li><li>res &#x3D; max(res, dp[i])<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i], nums[i] + dp[i<span class="hljs-number">-1</span>]);<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;       <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p><blockquote><p>输入:<br>[<br>[1,3,1],<br>[1,5,1],<br>[4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。</p></blockquote><p>思路：</p><ol><li>dp[i][j]表示从左上角元素到对应i行j列的元素的路径的最小值</li><li>dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</li><li>dp[0][i] &#x3D; dp[0][i-1]+grid[0][i]</li><li>dp[i][0] &#x3D; dp[i-1][0]+grid[i][0];<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+grid[<span class="hljs-number">0</span>][i];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+grid[i][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><blockquote><p>输入: m &#x3D; 3, n &#x3D; 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下;2. 向右 -&gt; 向下 -&gt; 向右;3. 向下 -&gt; 向右 -&gt; 向右</p></blockquote><p>思路：</p><ol><li>dp[i][j]表示从左上角元素到对应i行j列的元素的路径数</li><li>dp[i][j] &#x3D; dp[i-1][j]+ dp[i][j-1]（只能往下走或者往右走）</li><li>dp[i][0] &#x3D; 1（往下走的只有一条路径）</li><li>dp[0][i] &#x3D; 1（往右走的只有一条路径）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;   <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]+ dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;         <br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><blockquote><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。<br>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>    注意你可以重复使用字典中的单词。<br>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p></blockquote><p>思路：</p><ol><li>dp[i] 表示以是以[0,i-1]长度的字符串是否可以被拆分成wordDict其中的元素</li><li>dp[i] &#x3D; (dp[j] &amp;&amp; check(s[j..i−1])) , check(s[j,i-1])代表在字典中查询是否是wordDict中的元素</li><li>dp[0] &#x3D; true;设定为初始条件，因为题目说明不存在空串，方便初始查找。</li></ol><p>说明：<br>动态规划的题目总是希望能够由已知推出未知，这里dp[i]表示s[0:i-1]个元素是否可以被拆分成wordDict中的元素，其前一状态为dp[i-1],如果dp[i-1] &#x3D; true ,只要s[i-1]也存在wordDict中，那么dp[i] &#x3D; true;  对于</p><blockquote><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “leetcode”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p></blockquote><p>判断完”leet“存在在wordDict中后，wordDict中”leetcode”便无法再判断出结果，dp[i]不只与前一状态有关，与之前的所有状态可能都有关<br>因此，每次需要重新判断s.substr(j, i - j)是否存在wordDict中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size()+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">mp</span><span class="hljs-params">(wordDict.begin(), wordDict.end())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; mp.<span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">substr</span>(j, i - j))!= mp.<span class="hljs-built_in">end</span>())<br>                &#123;<br>                    dp[i] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><blockquote><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5<br>解释：<br>-1+1+1+1+1 &#x3D; 3<br>+1-1+1+1+1 &#x3D; 3<br>+1+1-1+1+1 &#x3D; 3<br>+1+1+1-1+1 &#x3D; 3<br>+1+1+1+1-1 &#x3D; 3<br>一共有5种方法让最终目标和为3。<br>提示：<br>数组非空，且长度不会超过 20 。<br>初始的数组的和不会超过 1000 。<br>保证返回的最终结果能被 32 位整数存下。</p></blockquote><p>思路：</p><ol><li>这里提示32位整数, long long </li><li>递归终点<br>（1）到达数组的末端<br>（2）如果到末端，此时S &#x3D;&#x3D; 0， res++</li><li>根据当前nums[index]的符号变化（+，-），改变下一次的目标值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">find</span>(nums, <span class="hljs-number">0</span>, S);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, <span class="hljs-type">long</span> <span class="hljs-type">long</span> S)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(S == <span class="hljs-number">0</span>) res++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;       <br>        <span class="hljs-built_in">find</span>(nums, index+<span class="hljs-number">1</span>, S+nums[index]);<br>        <span class="hljs-built_in">find</span>(nums, index+<span class="hljs-number">1</span>, S-nums[index]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><blockquote><p>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)<br>输入：word1 &#x3D; “intention”, word2 &#x3D; “execution”<br>输出：5<br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p></blockquote><ol><li>dp[i][j]表示word1[0-i]到word2[0-j]的编辑距离</li><li>word1和word2可为空，初始化dp[0-i] &#x3D; i, dp[0-j] &#x3D; j</li><li>这里我们只对一个单词操作，共计三种操作，插入删除替换，等价于对另一个单词删除插入替换<br>（1）从word1[0-i]编辑到word2[0-j]只需要删除word1第i个元素即可: dp[i][j] &#x3D; dp[i-1][j] + 1,;<br>（2）从word1[0-i]编辑到word2[0-j]只需要替换word1第i个元素即可: dp[i][j] &#x3D; dp[i-1][j-1] + 1,;<br>（3）从word1[0-i]编辑到word2[0-j]只需要插入word1第i个元素即可: dp[i][j] &#x3D; dp[i][j-1] + 1,;<br>每次操作，三者取最小的；当然如果word1[i] &#x3D;&#x3D; word2[j]则直接跳过，不用加1.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = word1.<span class="hljs-built_in">size</span>(), len2 = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len1; ++i)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= len2; ++i)<br>            dp[<span class="hljs-number">0</span>][i] = i;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], <span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><blockquote><p>输入:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>输出: 4</p></blockquote><p>思路：</p><ol><li>dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长</li><li>dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxside = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> colums = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(colums));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; colums; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]),dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    maxside = <span class="hljs-built_in">max</span>(maxside, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> maxsquare = maxside*maxside;       <br>        <span class="hljs-keyword">return</span> maxsquare;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="https://img-blog.csdnimg.cn/20200831230019151.png#pic_center" alt="在这里插入图片描述"><br>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。<br><img src="https://img-blog.csdnimg.cn/20200831230038327.png#pic_center" alt="在这里插入图片描述"><br>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><blockquote><p>输入: [2,1,5,6,2,3]<br>输出: 10</p></blockquote><p>思路：</p><p>1. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; st;<br>        heights.<span class="hljs-built_in">insert</span>(heights.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;heights.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[st.<span class="hljs-built_in">back</span>()] &gt; heights[i])<br>            &#123;<br>                <span class="hljs-type">int</span> cur = st.<span class="hljs-built_in">back</span>();<br>                st.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">back</span>()+<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = i - <span class="hljs-number">1</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans,(right - left + <span class="hljs-number">1</span>) * heights[cur]);<br><br>            &#125;<br>            st.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h2><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><blockquote><p>[<br>[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]<br>]<br>输出: 6</p></blockquote><p>思路：</p><ol><li>dp[i][j]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxrecangle</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;heights)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> maxs = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        heights.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">top</span>()!= <span class="hljs-number">-1</span> &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                <span class="hljs-type">int</span> num = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                maxs = <span class="hljs-built_in">max</span>(maxs,heights[num] *(i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>));<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxs;  <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!matrix.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(matrix[<span class="hljs-number">0</span>].size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> maxsquare = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                dp[j] = (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) ? dp[j] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            &#125;<br>            maxsquare = <span class="hljs-built_in">max</span>(maxsquare,<span class="hljs-built_in">maxrecangle</span>(dp));<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxsquare;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积</p><blockquote><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p></blockquote><p>思路：</p><ol><li>dp[i]表示到第i+1个元素时可以得到的最大乘积</li><li>dp[i] &#x3D; max(dp[i-1]*nums[i],nums[i])<br>&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt;&gt;&gt;<br>     dp_max[i] &#x3D; max(dp_max[i-1]*nums[i], max(dp_min[i-1]*nums[i], nums[i]));<br>     dp_min[i] &#x3D; min(dp_min[i-1]*nums[i], min(dp_max[i-1]*nums[i], nums[i]));<br>     max &#x3D; max(max, dp_max[i]);</li><li>res &#x3D; max(res, dp[i]);</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//错误1：未考虑到几个负值可以得到最大乘积的结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]*nums[i], nums[i]);<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//添加求得当前最大乘积值和最小乘积值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxn = INT_MIN;<br>        <span class="hljs-type">int</span> tmp_max = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tmp_min = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            tmp_max *= nums[i];<br>            tmp_min *= nums[i];<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>) <br>                <span class="hljs-built_in">swap</span>(tmp_max,tmp_min);<br>            tmp_max = <span class="hljs-built_in">max</span>(tmp_max, nums[i]);<br>            tmp_min = <span class="hljs-built_in">min</span>(tmp_min, nums[i]);<br>            maxn = <span class="hljs-built_in">max</span>(tmp_max, maxn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素</p><blockquote><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]</p></blockquote><p>思路：</p><ol><li>使用map存储每个元素的频次</li><li>使用优先队列，容量为k,依次插入元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            mp[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">//(频率，元素)</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; p;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">begin</span>(); iter != mp.<span class="hljs-built_in">end</span>(); iter++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(k == p.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(iter-&gt;second &gt; p.<span class="hljs-built_in">top</span>().first)<br>                &#123;<br>                    p.<span class="hljs-built_in">pop</span>();<br>                    p.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(iter-&gt;second,iter-&gt;first));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                p.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(iter-&gt;second,iter-&gt;first));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!p.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">top</span>().second);<br>            p.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></h2><p>给一非空的单词列表，返回前 k 个出现次数最多的单词。<br>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序</p><blockquote><p>输入: [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k &#x3D; 2<br>输出: [“i”, “love”]<br>解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。<br>注意，按字母顺序 “i” 在 “love” 之前。<br>输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k &#x3D; 4<br>输出: [“the”, “is”, “sunny”, “day”]<br>解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，<br>出现次数依次为 4, 3, 2 和 1 次。</p></blockquote><p>思路：<br>和上一题类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;string, <span class="hljs-type">int</span>&gt;&amp;a, <span class="hljs-type">const</span> pair&lt;string, <span class="hljs-type">int</span>&gt;&amp;b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(a.second != b.second)<br>                <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br>        vector&lt;string&gt; vc;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            mp[words[i]]++;<br>        &#125;<br>        priority_queue&lt;pair&lt;string, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;string, <span class="hljs-type">int</span>&gt;&gt;, cmp&gt; p;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m:mp)<br>        &#123;<br>            p.<span class="hljs-built_in">push</span>(m);<br>            <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">size</span>() &gt; k)<br>                p.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!p.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vc.<span class="hljs-built_in">push_back</span>(p.<span class="hljs-built_in">top</span>().first);<br>            p.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(vc.<span class="hljs-built_in">begin</span>(), vc.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> vc;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/">44. 通配符匹配</a></h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p><p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *</p><blockquote><p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p></blockquote><p>思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(p.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>));<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            dp[<span class="hljs-number">0</span>][i] =  dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p.<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>)<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][p.<span class="hljs-built_in">size</span>()];      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;.&#x27;</span> 匹配任意单个字符<br><span class="hljs-string">&#x27;*&#x27;</span> 匹配零个或多个前面的那一个元素<br></code></pre></td></tr></table></figure><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。<br>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><blockquote><p>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">empty</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(p.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p.<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    dp[i][j] = dp[i][j<span class="hljs-number">-2</span>];<br>                    <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span> || p[j<span class="hljs-number">-2</span>] == s[i<span class="hljs-number">-1</span>])<br>                    &#123;<br>                        dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()][p.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之链表</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h2><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头</p><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 &#x3D; 807</p></blockquote><p>思路：</p><ol><li>对于链表长度不一致的情况，补0</li><li>只有当俩个链表均为null并且没有近位的情况下退出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* res= head;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 || l2 || flag)<br>        &#123;<br>            <span class="hljs-type">int</span> t1 = l1 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : l1-&gt;val;<br>            <span class="hljs-type">int</span> t2 = l2 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : l2-&gt;val;<br>            sum = t1+t2+flag;<br><br>            flag = sum/<span class="hljs-number">10</span>;<br>            sum = sum % <span class="hljs-number">10</span>;<br><br>            head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>            head = head-&gt;next;<br>            <br>            l1 = l1 ? l1-&gt;next : l1;<br>            l2 = l2 ? l2-&gt;next : l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a></h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p>思路：</p><ol><li>使用快慢指针，快指针先走N个节点，然后快慢指针一起走，知道快指针为NULL,此时慢指针即为倒数第N个节点</li><li>由于要删除倒数第N个节点，需要保存其前节点，因此在遍历过程中，每次保存当前节点的前驱节点；或者让慢节点走到倒数第N+1个节点时，直接操作即可</li><li>注意如果倒是第N个节点时头节点时，删除的方式需要注意，可以根据快节点走完N个节点的情况来判断<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* quick = head;<br>        ListNode* low = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            quick = quick-&gt;next;<br>        <span class="hljs-keyword">if</span>(!quick)<br>        &#123;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(quick-&gt;next)<br>        &#123;<br>            quick = quick-&gt;next;<br>            low = low-&gt;next;<br>        &#125;<br>        low-&gt;next = low-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-literal">NULL</span>);<br>        ListNode* res = head;<br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)<br>            &#123;<br>                res-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;             <br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            res = res-&gt;next;<br>        &#125;<br>        res-&gt;next = (l1 == <span class="hljs-literal">NULL</span> ? l2 : l1);<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;  <br>       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode *a,ListNode *b)</span></span>&#123;<br>          <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>       &#125;<br>    &#125;;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pt;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *p = head;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> node: lists)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node)<br>                pt.<span class="hljs-built_in">push</span>(node);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!pt.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            ListNode* q = pt.<span class="hljs-built_in">top</span>();<br>            pt.<span class="hljs-built_in">pop</span>();<br>            p-&gt;next = q;<br>            p = q;<br>            <span class="hljs-keyword">if</span>(q-&gt;next)<br>                pt.<span class="hljs-built_in">push</span>(q-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false<br>进阶：<br>你能用 O(1)（即，常量）内存解决此问题吗？<br><img src="https://img-blog.csdnimg.cn/20200919164611935.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p>思路：</p><ol><li>利用快慢指针，快指针每次走俩个节点，慢指针每次走一个节点</li><li>如果存在环，那么快慢指针最终会相遇</li><li>如果不存在，则快慢指针最后至少有一个先走到null节点</li><li>对于只有单个节点和俩个节点的链表，可以直接判断</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* quick = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(quick&amp;&amp;quick-&gt;next)<br>        &#123;<br>            slow = slow-&gt;next;   <br>            quick = quick-&gt;next-&gt;next;<br><br>            <span class="hljs-keyword">if</span>(quick == slow)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表</p><blockquote><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200919191556946.png#pic_center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* slow = head;<br>        ListNode* quick = head;<br>        <span class="hljs-keyword">while</span>(quick &amp;&amp; quick-&gt;next)<br>        &#123;<br>            slow = slow-&gt;next;<br>            quick = quick-&gt;next-&gt;next;<br>            <br>            <span class="hljs-keyword">if</span>(slow == quick)<br>             &#123;<br>                 slow = head;<br>                 <span class="hljs-keyword">while</span>(slow != quick)<br>                 &#123;<br>                     slow = slow-&gt;next;<br>                     quick = quick-&gt;next;<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> slow;<br>             &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h2><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p>思路：</p><ol><li>归并的思想，先分割链表，局部排序，排序完后再合并排序</li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy= <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* head = dummy;<br>        <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)<br>            &#123;<br>                dummy-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dummy-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            dummy = dummy-&gt;next;<br>        &#125;<br>        dummy-&gt;next = l1 ? l1 : l2;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">cut</span><span class="hljs-params">(ListNode* l1, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* p = l1;<br>        <span class="hljs-keyword">while</span>(--len &amp;&amp; p)<br>        &#123;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!p)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        ListNode* next = p-&gt;next;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            p = p-&gt;next;<br>            len++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i &lt;&lt;= <span class="hljs-number">1</span>)<br>        &#123;<br>            ListNode* cur = dummy-&gt;next;<br>            ListNode* tail = dummy;<br>            <span class="hljs-keyword">while</span>(cur)<br>            &#123;<br>                ListNode* left = cur;<br>                ListNode* right = <span class="hljs-built_in">cut</span>(left, i);<br>                cur = <span class="hljs-built_in">cut</span>(right, i);<br>                tail-&gt;next = <span class="hljs-built_in">merge</span>(left, right);<br>                <span class="hljs-keyword">while</span>(tail-&gt;next)<br>                    tail = tail-&gt;next;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><blockquote><p>示例：<br>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5<br>说明：<br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p></blockquote><p>思路：<br>递归实现</p><ol><li>按k个元素分割链表，局部反转后连上；</li><li>确定每次需要翻转的k个元素，递归翻转，对应链表尾端均为NULL；</li><li>如果不足k个元素，则不反转，直接返回。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(head &amp;&amp; k)<br>        &#123;<br>            ListNode* cur = head-&gt;next;<br>            head-&gt;next = pre;<br>            pre = head;<br>            head = cur;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || k == <span class="hljs-number">1</span>)<br>             <span class="hljs-keyword">return</span> head;<br>        ListNode* tail = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k &amp;&amp; tail != <span class="hljs-literal">NULL</span>; ++i)<br>            tail = tail-&gt;next;<br>        <span class="hljs-keyword">if</span>(tail == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode *next = tail-&gt;next;<br>        <span class="hljs-built_in">reverse</span>(head,k);<br>        head-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(next, k);<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<br><img src="https://img-blog.csdnimg.cn/20200919204242538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NzMyMDUw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在节点 c1 开始相交<br><img src="https://img-blog.csdnimg.cn/20200919204300272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NzMyMDUw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* ha = headA;<br>        ListNode* hb = headB;<br>        <span class="hljs-keyword">while</span>(ha != hb)<br>        &#123;<br>            ha = ha ? ha-&gt;next:headB;<br>            hb = hb ? hb-&gt;next:headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ha;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><p>反转一个单链表</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* next = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, next);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(head)<br>        &#123;<br>            ListNode* next = head-&gt;next;<br>            head-&gt;next = pre;<br>            pre = head;<br>            head = next;      <br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><p>请判断一个链表是否为回文链表</p><blockquote><p>输入: 1-&gt;2<br>输出: false<br>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p></blockquote><p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题</p><p>思路：</p><ol><li>找到链表中点</li><li>翻转后半部分链表，然后依次遍历俩部分链表即可</li><li>恢复原链表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)<br>        &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(slow)<br>        &#123;<br>            ListNode* next = slow-&gt;next;<br>            slow-&gt;next = pre;<br>            pre = slow;<br>            slow = next;<br>        &#125;<br>        ListNode * cur = head;<br>        ListNode* pt = pre;<br>        <span class="hljs-keyword">while</span>(cur &amp;&amp; pt)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val != pt-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur-&gt;next;<br>            pt = pt-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(cur)<br>            cur = cur-&gt;next;<br>        <span class="hljs-keyword">while</span>(pre)<br>        &#123;<br>            ListNode* next = pre-&gt;next;<br>            pre-&gt;next = cur;<br>            cur = pre;<br>            pre = next;<br>        &#125;        <br><br>        <span class="hljs-comment">// while(head)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     std::cout &lt;&lt; head-&gt;val &lt;&lt; std::endl;</span><br>        <span class="hljs-comment">//     head = head-&gt;next;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之二叉树</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">  3<br> / \<br>9  20<br>  /  \<br> 15   7<br></code></pre></td></tr></table></figure><p>思路：<br>（1）前序遍历：根节点-&gt;左节点-&gt;右节点；中序遍历：左子树-&gt;根节点-&gt;右子树<br>（2）利用前序遍历中的根节点将中序遍历数组拆分成俩部分，分别为当前根节点的左子树和右子树<br>（3）递归解决每个根节点的左子树和右子树问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pos &lt; inorder.<span class="hljs-built_in">size</span>() &amp;&amp; preorder[<span class="hljs-number">0</span>] != inorder[pos])<br>            pos++;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prev</span><span class="hljs-params">(preorder.begin()+<span class="hljs-number">1</span>, preorder.begin()+pos+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inv</span><span class="hljs-params">(inorder.begin(), inorder.begin()+pos)</span></span>;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(prev, inv);<br><br>        prev.<span class="hljs-built_in">assign</span>(preorder.<span class="hljs-built_in">begin</span>()+pos+<span class="hljs-number">1</span>, preorder.<span class="hljs-built_in">end</span>());<br>        inv.<span class="hljs-built_in">assign</span>(inorder.<span class="hljs-built_in">begin</span>()+pos+<span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(prev, inv);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//迭代</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-type">int</span> pval = preorder[i];<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val != inorder[pos])<br>            &#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pval);<br>                st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>()-&gt;val == inorder[pos])<br>                &#123;<br>                    node = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    pos++;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pval);<br>                st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入: <br><br>           1<br>         /   \<br>        3     2<br>       / \     \  <br>      5   3     9 <br><br>输出: 4<br>解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。<br></code></pre></td></tr></table></figure><p>思路：</p><ol><li>求最大宽度，那么如果我们能求到最靠近左边的节点，保存下标；然后求得最后边的节点，利用下标之差，注意这个节点的父亲节点的父亲节点可能存在左子树。</li><li>题目有提到说类似于满二叉树结构，所以如果根节点下标设为i(i&gt;&#x3D;1)，那么根节点的左节点2 *i,右节点2 *i+1;</li><li>使用一个map来存放每一层最左边的节点的下标<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> maxwidth = <span class="hljs-number">0</span>;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; mp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> level, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(!mp.<span class="hljs-built_in">count</span>(level))<br>            mp[level] = index;<br>        maxwidth = <span class="hljs-built_in">max</span>(maxwidth, index - mp[level] + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, level+<span class="hljs-number">1</span>, index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, level+<span class="hljs-number">1</span>, index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> maxwidth;<br>    &#125;<br>&#125;;<span class="hljs-comment">// 非递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxwidth = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> maxwidth;<br>        queue&lt;pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt;&gt; qt;<br>        vector&lt;<span class="hljs-type">int</span>&gt; start;<br>        qt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(root, <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">while</span>(!qt.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; p = qt.<span class="hljs-built_in">front</span>();<br>            start.<span class="hljs-built_in">push_back</span>(p.second);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; qt.<span class="hljs-built_in">size</span>(); ++i)<br>            &#123;<br>                pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; tp = qt.<span class="hljs-built_in">front</span>();<br>                qt.<span class="hljs-built_in">pop</span>();<br>                maxwidth = <span class="hljs-built_in">max</span>(maxwidth, tp.second - p.second + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(tp.first-&gt;left)<br>                    qt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(tp.first-&gt;left, <span class="hljs-number">2</span>*tp.second));<br>                <span class="hljs-keyword">if</span>(tp.first-&gt;right)<br>                    qt.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;TreeNode*, <span class="hljs-type">int</span>&gt;(tp.first-&gt;left, <span class="hljs-number">2</span>*tp.second+<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxwidth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">    1<br>   / \<br>  2   3<br> / \     <br>4   5    <br></code></pre></td></tr></table></figure><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。<br>注意：两结点之间的路径长度是以它们之间边的数目表示。<br>思路：</p><ol><li>直径的概念：俩个节点之间的路径长度，对于每一个节点来说，就是左子树长度+右子树长度</li><li>求最大直径，比较所有节点的直径，取最大值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameter</span><span class="hljs-params">(TreeNode* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">diameter</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">diameter</span>(root-&gt;right);<br>        ans = <span class="hljs-built_in">max</span>(ans, l + r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l,r) + <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">diameter</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://img-blog.csdnimg.cn/20200908085313373.png#pic_center" alt="](https://img-blog.csdnimg.cn/20200908085259995.png#pic_center)"></p><blockquote><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br>说明:<br>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p></blockquote><p>思路：<br>分析二叉树的结构，左子树，右子树， 根节点，给定俩个节点，找最近公共祖先<br>（1）当某一节点A在另一节B点的左子树或右子树中，则B为最近公共祖先，反之亦然<br>（2）如果一个节点C的左子树和右子树分别包含A，B节点，则C为AB的公共祖先，那么如何保证C为最近公共祖先呢？当我们采用递归的方式查找（递归到叶子节点回退判断）的时候，最先查找的节点就是最近的点，直接返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* ans;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> lson = <span class="hljs-built_in">dfs</span>(root-&gt;left,p,q);<br>        <span class="hljs-type">bool</span> rson = <span class="hljs-built_in">dfs</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val) || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))<br>            ans = root;<br>        <span class="hljs-keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="htAtps://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。<br>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入:<br>   1<br> /   \<br>2     3<br> \<br>  5<br>输出: [<span class="hljs-string">&quot;1-&gt;2-&gt;5&quot;</span>, <span class="hljs-string">&quot;1-&gt;3&quot;</span>]<br>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3<br></code></pre></td></tr></table></figure><p>思路：</p><ol><li>回溯的方法</li><li>使用vector<int>先存储，存完后转string<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>        <span class="hljs-built_in">TreePath</span>(root,vc);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TreePath</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vc)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        vc.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            string str = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vc.<span class="hljs-built_in">size</span>(); ++i)<br>            &#123;<br>                cout &lt;&lt; vc[i];<br>                str += <span class="hljs-built_in">to_string</span>(vc[i]);<br>                <span class="hljs-keyword">if</span>(i != vc.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>                    str += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            path.<span class="hljs-built_in">push_back</span>(str);<br>            vc.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">TreePath</span>(root-&gt;left, vc);<br>        <span class="hljs-built_in">TreePath</span>(root-&gt;right, vc);<br>        vc.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode算法之回溯</title>
    <link href="/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF/"/>
    <url>/2023/10/25/Leetcode%E7%AE%97%E6%B3%95%E4%B9%8B%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><blockquote><p>board &#x3D;<br>[<br>[‘A’,’B’,’C’,’E’],<br>[‘S’,’F’,’C’,’S’],<br>[‘A’,’D’,’E’,’E’]<br>]<br>给定 word &#x3D; “ABCCED”, 返回 true<br>给定 word &#x3D; “SEE”, 返回 true<br>给定 word &#x3D; “ABCB”, 返回 false<br>board 和 word 中只包含大写和小写英文字母。<br>1 &lt;&#x3D; board.length &lt;&#x3D; 200<br>1 &lt;&#x3D; board[i].length &lt;&#x3D; 200<br>1 &lt;&#x3D; word.length &lt;&#x3D; 10^3</p></blockquote><p>思路：<br>回溯的思想其实也是暴力的一种</p><ol><li>找到第一个与word[0]字母相同的字母，然后从她的四个方向查找，找之前将该节点元素保存，源位置置换为‘\0’，保证下一次不会查找到这个元素，等回退到这一层时在还原该元素。</li><li>只有当index和word.size()-1相等时，代表所有元素查找完成并存在，返回真</li><li>当查找范围超出界限，或者与当前word[index]不相等，则返回假，回退。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= board.<span class="hljs-built_in">size</span>() || y &lt; <span class="hljs-number">0</span> || y &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || board[x][y] != word[index])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(index == word.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(    <span class="hljs-built_in">dfs</span>(board, word, x<span class="hljs-number">-1</span>, y, index+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board, word, x+<span class="hljs-number">1</span>, y, index+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board, word, x, y<span class="hljs-number">-1</span>, index+<span class="hljs-number">1</span>)<br>            || <span class="hljs-built_in">dfs</span>(board, word, x, y+<span class="hljs-number">1</span>, index+<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        board[x][y] = tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><blockquote><p>输入: [1,2,3]<br>输出:<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p></blockquote><p>思路：</p><ol><li>结束条件：当每轮路径存储的元素与nums元素的个数一致时，返回</li><li>选择列表：visited[i] &#x3D;&#x3D; false， 回溯的时候如果需要避免一些未被访问的元素，我们添加visited数组表示</li><li>回退操作：路径数组中弹出这轮循环中的元素，visited重新置未false<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vc, vector&lt;<span class="hljs-type">bool</span>&gt;&amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(vc.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(vc);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i])<br>                <span class="hljs-keyword">continue</span>;<br>            visited[i] = <span class="hljs-literal">true</span>;<br>            vc.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums, vc, visited);<br>            vc.<span class="hljs-built_in">pop_back</span>();<br>            visited[i] = <span class="hljs-literal">false</span>;            <br>        &#125;<br><br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) <br>    &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">dfs</span>(nums, vc, visited);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。</p><p>说明：<br>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。 </p><blockquote><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,<br>所求解集为：<br>[<br>[7],<br>[2,2,3]<br>]</p></blockquote><p>思路：</p><ol><li>终止条件：组合和为大于等于target,等于时保存，大于时回退</li><li>选择列表：由于元素可以被无限次数使用，所以不需要visited数组</li><li>回退列表：将当前元素弹出，目标和对应减去</li><li>去重：每次查找只需要以当前元素为起点查找即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vc, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(vc);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            vc.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">dfs</span>(candidates, target-candidates[i], vc, i);<br>            vc.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>        <span class="hljs-built_in">dfs</span>(candidates,target,vc,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><blockquote><p>输入：n &#x3D; 3<br>输出：[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p></blockquote><p>思路：</p><ol><li>终止条件：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">func</span>(res, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;string&gt; &amp;res, string str, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l &gt; n || r &gt; n || r &gt; l) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span>(l == n &amp;&amp; r == n) &#123;res.<span class="hljs-built_in">push_back</span>(str); <span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-built_in">func</span>(res, str + <span class="hljs-string">&#x27;(&#x27;</span>, l+<span class="hljs-number">1</span>, r, n);<br>        <span class="hljs-built_in">func</span>(res, str + <span class="hljs-string">&#x27;)&#x27;</span>, l, r+<span class="hljs-number">1</span>, n);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入:<br>[<br>[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],<br>[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],<br>[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],<br>[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]<br>]<br>输出: <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.<span class="hljs-built_in">size</span>() || j &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    res++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i , j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],<br> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br> 对于上面这个给定矩阵应返回 <span class="hljs-number">6</span>。注意答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直的四个方向的 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span>&amp; tmp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= grid.<span class="hljs-built_in">size</span>() || y &gt;= grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || grid[x][y] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        tmp++;<br>        grid[x][y] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, x+<span class="hljs-number">1</span>, y, tmp);<br>        <span class="hljs-built_in">dfs</span>(grid, x<span class="hljs-number">-1</span>, y, tmp);<br>        <span class="hljs-built_in">dfs</span>(grid, x, y<span class="hljs-number">-1</span>, tmp);<br>        <span class="hljs-built_in">dfs</span>(grid, x, y+<span class="hljs-number">1</span>, tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)<br>                &#123;<br>                    tmp = <span class="hljs-number">0</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j, tmp);<br>                    res = <span class="hljs-built_in">max</span>(res, tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有向图环路检测</title>
    <link href="/2023/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/10/25/%E6%9C%89%E5%90%91%E5%9B%BE%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于有向图的环路检测，首先我想先补充几个关于图的概念。<br>顶点：图中的每个点称为顶点。<br>顶点的入度：在有向图中，指以该顶点为终点的边的数目<br>顶点的出度：在有向图中，指以该顶点为起点的边的数目</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>方法一</strong>：图中有环则表示至少有一条路径上出现俩个相同的顶点。该路径满足起点入度为0，终点出度为0.<br>可以使用一个集合表示每个顶点的状态，是否被标记过，但需要注意，这个点被检查过后需要去掉这个标记，因为一条路径上有环意味着会出现重复的顶点，但不同路径上出现相同的顶点上是允许的。<br>缺点：大量的点可能将被重复检查<br>优点：思路清晰，简单，递归实现。<br><strong>方法二</strong>：图中若没有环，则必有一个节点的入度为0，依次删除入度为0的点及其相邻的边，最终的集合为空。<br>先构建俩个集合，一个入度为0的点集合，一个入度不为0的点集合，遍历入度为0的集合，依次删除，并更新入度为0的集合（删除就的点同时可能会增加新的点），直到入度为0的点的集合为空后，去检查出度为0的点是否为空，空则无环，否则有环。<br>缺点：内存组装对象麻烦<br>优点：所有的点只需要一次删除。快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法1其实就是dfs；<br>方法2利用拓扑排序；拓扑排序，其实就是将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。通常用来对具有依赖关系的任务进行排序，因此是从入度为0的点作为起始点，遍历整个图，输出顶点之间的顺序。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++</title>
    <link href="/2023/10/25/Effective-C/"/>
    <url>/2023/10/25/Effective-C/</url>
    
    <content type="html"><![CDATA[<p><img src="/../image/c++/effectiveC++0.png" alt="effectiveC++0"></p><p><img src="/../image/c++/effectiveC++.png" alt="在这里插入图片描述"></p><h3 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h3><h5 id="为什么尽量不用-define？"><a href="#为什么尽量不用-define？" class="headerlink" title="为什么尽量不用#define？"></a>为什么尽量不用#define？</h5><p>（1）#define的记号名称可能在编译器处理源码时就已经被预处理器移走了，记号名称未能进入记号表，从而可能获得编译错误的信息。如果又是定义在非你所写的头文件中，你更将毫无概念，并耗时追踪。<br>（2）无法用#define创建一个class专属常量，#define并不注重于（scope），一旦编译除非#undef,定义区间均有效。因此，无法提供任何封装性。<br>（3）以#define实现宏时,格式可能较为繁琐，，易出错，且效率难以保障。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b) ? (a):(b))</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b); <span class="hljs-meta">#a被累加2次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b+<span class="hljs-number">10</span>);<span class="hljs-meta">#a被累加1次</span><br></code></pre></td></tr></table></figure><p>在这里，f调用前，a的递增次数会取决于“它被拿来和谁比较”</p><h6 id="尽量多的使用const-enum-inline"><a href="#尽量多的使用const-enum-inline" class="headerlink" title="尽量多的使用const,enum,inline"></a>尽量多的使用const,enum,inline</h6><h6 id="const"><a href="#const" class="headerlink" title="const"></a>const</h6><p>(1) 使用常量可能比用#define导致较小的代码量<br>(2) 可以作为class的专属常量，static 从上图，可以确保此常量至多只有一份实体</p><h6 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h6><p>(1) 某些行为较像#define 而不像const,取#define的地址也不合法，取enum的地址不合法，因此约束指针指向，同时于#define一样不会导致非必要的内存分配<br>(2) 实用，“enum hack”是templat metaprogramming（模板元编程）的基础技术</p><h6 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h6><p>可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全，只要你写出template inline函数。</p><p><img src="/../image/c++/effectiveC++1.png" alt="在这里插入图片描述"></p><h3 id="条款03：尽可能用const"><a href="#条款03：尽可能用const" class="headerlink" title="条款03：尽可能用const"></a>条款03：尽可能用const</h3><h5 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h5><p>（1）变量<br>常量，该变量不可被修改, 因此定义时必须被初始化<br>（2）指针<br>常量指针和指针常量<br>允许非const对象的地址赋给指向const对象的指针<br>因此可以简单的理解为，谁被const修饰，谁就不能改变。没有被修饰的不可轻易下结论。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#常量指针<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a; <span class="hljs-meta"># p本身并不是常量，*p是指向 const int的指针,因此*p可以被重新赋值，或者更改指向</span><br>#指针常量<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a; <span class="hljs-meta"># p是指向int类型的指针，p本身是常量，不可被修改</span><br>#指向常量的指针常量<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure><p>（3）参数<br>避免了拷贝，又避免了函数对值的修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span></span>; #避免对函数值的修改<br></code></pre></td></tr></table></figure><p>（4）函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;# (<span class="hljs-number">1</span>) 可用于区分重载<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;# (<span class="hljs-number">2</span>) 常成员函数在函数体内不能对成员变量进行修改<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">misp</span><span class="hljs-params">()</span></span>; # (<span class="hljs-number">3</span>) 修饰返回值，返回值为常量不可修改<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-title">mis</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="const-static"><a href="#const-static" class="headerlink" title="const &amp;&amp; static"></a>const &amp;&amp; static</h5><h3 id="条款04：确定对象使用前已经被初始化"><a href="#条款04：确定对象使用前已经被初始化" class="headerlink" title="条款04：确定对象使用前已经被初始化"></a>条款04：确定对象使用前已经被初始化</h3><h2 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h2><h3 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h3><h3 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><h3 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h3><p><strong>问题</strong>：对于具有多态性质的基类，在没有virtual析构函数的情况下，派生类的对象会经由一个基类指针被删除，其中基类成分通常会被销毁，但派生类很可能没被销毁，这就造成了一个”局部销毁“的对象，可能引起资源泄露。<br><strong>解决</strong>：给基类添加一个virtual析构函数。virtual函数的目的是允许派生类的实现得以客制化，在不同的派生类中有对应不同的实现码。<br><strong>注意</strong>：classes的设计目的如果不是作为基类使用，或者不是为了具备多态性质，就不该声明virtual函数。virtual函数的实现会使对象的体积增加约50%-100%，因此可能不再能传递给其他语言所写的函数。<br><strong>总结</strong>：带多态性质的基类应该声明一个virtual析构函数，如果类中有任何virtual函数，它就应该拥有一个virtual析构函数。</p><h3 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h3><p><strong>问题</strong>：在析构函数中吐过抛出异常可能会导致剩下的析构工作未完成，出现资源泄露。<br><strong>解决</strong>：<br>方案1：抛出异常时粗暴结束，常常通过abort完成；<br>方案2：吞下异常并记录异常；<br>方案3：设计接口使得用户对可能出现的异常做出反应。<br><strong>注意</strong>：如果客户需要对某个操作函数进行运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行操作。<br><strong>总结</strong>：析构函数绝对不要吐出异常，如果一个析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p><h3 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h3><p><strong>问题</strong>：在派生类对象的基类构造期间对象的类型是基类而不是派生类<br><strong>注意</strong>：在基类构造期间，virtual函数不是virtual函数<br><strong>总结</strong>：在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</p><h3 id="条款10：令operato-返回一个reference-to-this"><a href="#条款10：令operato-返回一个reference-to-this" class="headerlink" title="条款10：令operato&#x3D; 返回一个reference to *this"></a>条款10：令operato&#x3D; 返回一个reference to *this</h3><p><strong>说明</strong>：实现赋值操作符时应该遵循的协议（实现“连锁赋值”：a &#x3D; b &#x3D; c &#x3D; 20）<br><strong>总结</strong>：令赋值操作符返回一个 reference to *this。</p><h3 id="条款11：在operator-中处理“自我赋值"><a href="#条款11：在operator-中处理“自我赋值" class="headerlink" title="条款11：在operator&#x3D; 中处理“自我赋值"></a>条款11：在operator&#x3D; 中处理“自我赋值</h3><p><strong>问题</strong>：自我赋值时容易掉进“在停止使用资源之前意外释放了它”的陷阱</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span>&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>...<br><span class="hljs-keyword">private</span>:<br>Bitmap* pb;              <span class="hljs-comment">//指针，指向一个从heap分配而得的对象</span><br>&#125;<br>Widget&amp; Wisget:: <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br><span class="hljs-keyword">delete</span> pb;               <span class="hljs-comment">//停止使用当前的bitmap</span><br>pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<span class="hljs-comment">//使用rhs‘s bitmap的副本</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;           <br>&#125;<br></code></pre></td></tr></table></figure><p>这里operator&#x3D; 函数内的*this（赋值目的端）和rhs有可能是同一个对象，在这种情况下，delete就不只是销毁当前对象的bitmap,它也销毁rhs的bitmap,最后this会指向一个被删除的对象。<br><strong>解决</strong>：<br>方案一(传统做法):判断是否是自我赋值（“证同测试”）<br>方案二：在复制pb所指东西之前别删除pb</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>Bitmap* pOrig = pb;<br>pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><span class="hljs-keyword">delete</span> pOrig;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方案三：copy and swap</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget rhs) <span class="hljs-comment">//rhs被传递时是一份副本</span><br>&#123;                                           <span class="hljs-comment">//这里是值传递</span><br><span class="hljs-built_in">swap</span>(rhs);                              <span class="hljs-comment">//将*this的数据和复件的数据互换</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                           <br>&#125;<br></code></pre></td></tr></table></figure><p>（1）某class的拷贝赋值操作符可能被声明为“以值方式接受实参”；<br>（2）值传递会造成一份副本<br><strong>注意</strong>：确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。<br><strong>总结</strong>：确保当对象自我赋值时 operator&#x3D; 有良好行为，其中技术包括比较“来源对象”和“目标对象”的地址，精心周到的语句顺序，以及copy-and-swap。</p><h3 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h3><p><strong>注意</strong>：不要尝试以某个copying函数实现另一个copying函数，应该将共同机能放进第三个函数中，并由俩个copying函数共同调用。<br><strong>总结</strong>：Copying函数应该确保复制“对象内的所有成员变量”及“所有基类成分”</p><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h3><p><strong>问题</strong>：单纯依赖某个函数总会去执行delete语句“是行不通的，中途可能由于continue，goto等操作使得delete语句被跳过去，引发资源泄露<br><strong>解决</strong>：将资源放进对象内，当控制流离开f函数，该对象的析构函数会自动释放那些资源。<br><strong>注意</strong>：俩个常被使用的RAIL classes分别是tr1::shared_ptr和auto_ptr,前者通常是较佳选择，因为其copy行为较为直观，若选择auto_ptr,复制动作会使它（被复制物）指向NULL.<br><strong>总结</strong>：为防止资源泄露，请使用RAIL对象，它们在构造函数中获得资源并在析构函数中释放资源</p><h3 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h3><p><strong>说明</strong>：RAII（Resource Acquisition Is Intialization）:资源取得时机便是便是初始化时机。<br><strong>注意</strong>：普遍而常见的RAII class copying 行为是： 抑制copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现。<br><strong>总结</strong>：复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p><h3 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h3><p><strong>注意</strong>：对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。<br><strong>总结</strong>：APIs往往要求访问原始资源，所以每一个RAII class 应该提供一个“取得其所管理之资源”的办法</p><h3 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h3><p><strong>总结</strong>：如果你在new表达式中使用[ ],必须在相应的delete表达式中也使用[ ]。如果你在new表达式中不使用[ ],一定不要在相应的delete表达式中使用[ ]。</p><h3 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h3><p><strong>总结</strong>：以独立语句将newed对象存储于智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</p><h2 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h2><h3 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h3><p><strong>问题</strong>：<br>接口可能出现的错误：<br>（1）或许会以错误的次序传递参数<br>（2）可能传递一个无效的参数</p><p><strong>解决</strong>：<br>（1）限制类型内哪些可以做，哪些不能做(常见的限制是加上const)<br>（2）先发制人，由于客户可能会有着“不正确的使用倾向”，比如忘记通过智能指针来管理某些动态分配的对象，那么就令factory函数返回一个智能指针。<br><strong>注意</strong>：<br>（1）”促进正确使用”的办法包括一切接口的一致性，以及与内置类型的行为兼容。<br>（2）“阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。<br>（3）tr1::shared_ptr支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexes）等等。<br><strong>总结</strong>：好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</p><h3 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h3><p><strong>总结</strong>：class的设计就是type的设计，在定义一个新的type之前，请确定你已经考虑过本条款覆盖的所有讨论问题。</p><h3 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h3><p><strong>问题</strong>：对一般函数而言，对象参数的传递成本是“一次拷贝构造+一次析构调用”，其中对象内有几个成员，或者对象，也会增加传递成本。与此同时，引用传参的效率要高的多，没有任何构造函数的析构函数被调用，因为没有任何对象被创建，同时参数声明为const，避免参数被改变。7<br><strong>总结</strong>：尽量以pass-by-reference-to-const替换pass-by-value.前者通常比较高效，并可避免切割问题（splice problem）。<br><strong>注意</strong>：以上规则并不适用内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。</p><h3 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h3><p><strong>总结</strong>：绝不用返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而言而有可能同时需要多个这样的对象。</p><h3 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h3><p><strong>注意</strong>：protected并不比private更具有封装性<br><strong>总结</strong>：切记将成员变量声明private。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分的实现弹性。</p><h3 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h3><p><strong>总结</strong>：宁以non-member、non-friend替换member函数，这样做可以增加封装性，包裹弹性（package flexibility）和机能扩充性。</p><h3 id="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需要类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需要类型转换，请为此采用non-member函数</h3><p><strong>总结</strong>：如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</p><h3 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h3><p><strong>注意</strong>：<br>（1）如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于class(而非templates),也请特化std::swap<br>（2）调用swap时针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。<br>（3）为“用户定义类型”进行是std::templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。<br><strong>总结</strong>：当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h3><p><strong>问题</strong>：变量定义式会带来构造和析构的成本，一旦定义变量的该函数抛出异常，你仍得夫付出变量定义的构造和析构成本。<br><strong>注意</strong>：不只是延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义，直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象还可以比避免无意义的deafult构造行为。更深一层说，以”具明显意义之初值“将变量初始化，还可以附带说明变量的目的。</p><p><strong>总结</strong>：尽可能延后变量定义式的出现，这样做会增加程序的清晰度并改善程序效率</p><h3 id="条款27：尽可能少做转型动作"><a href="#条款27：尽可能少做转型动作" class="headerlink" title="条款27：尽可能少做转型动作"></a>条款27：尽可能少做转型动作</h3><p><strong>说明</strong>：<br>（1）C++规则的设计目标之一是，保证”类型错误“绝不可能发生<br>（2）旧式转换：T（expression） （T）expression<br>（3）新式转换：const_cast&amp;dynamic_cast&amp;reinterpret_cast&amp;static_cast</p><p><strong>注意</strong>：<br>（1）任何一个类型转换（不论是通过转型操作而进行的显式转换，或通过编译器完成的隐式转换）往往真的令编译器编译出运行期间执行的码。<br>其中新式转换较为欢迎，原因：<br>（1）代码中易辨识<br>（2）各转型动作的目标愈窄化，编译器愈能诊断出错误的运用</p><p>（1）const_cast通常被用来将对象的常量性去除，也是唯一具有此能力的C++ style转型操作符<br>（2）dynamic_cast主要用来执行“安全向下转型”，也就是用来决定某对象是否归属体系中的某个类型，他是唯一无法由旧式语法执行的动作，也是唯一可能消耗重大运行成本的转型动作<br>（3）reinterpret_cast意图执行低级转型，实际动作可能取决于编译器，这也就表示它不可移植，<br>（4）static_cast用来强迫隐式转换</p><p><strong>总结</strong>：<br>（1）如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有这个设计需要转型动作，试着发展无需转型的替代设计<br>（2）如果转型是必要的，试着将它隐藏于某个函数背后，客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。<br>（3）宁可使用C++style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的执掌。</p><h3 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h3><p><strong>问题</strong>：Reference,指针，迭代器统统都是所谓的handles（号码牌，用来取得某个对象），而返回一个”代表对象内部“的handle,随之而来的式”降低对象封装性“的风险。同时，它也可能导致”虽然调用const成员函数却造成对象状态被更改“。<br><strong>解决</strong>：<br>留心不要返回他们的handles,对const成员函数的返回类型加上const<br><strong>总结</strong>：<br>避免返回handles,（包括references，指针，迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const,并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。</p><h3 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h3><p><strong>总结</strong>：<br>（1）异常安全函数（Exceptional functions）即使发生异常也不会泄露资源或允许任何数据结构破坏，这样的函数区分为三种可能的保证：基本型，强烈型，不抛异常型。<br>（2）“强烈保证”往往能够实现以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。<br>（3）函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</p><h3 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h3><p><strong>说明</strong>：<br>（1）inline函数背后的整体观念是，将”对此函数的每一个调用“都以函数本体替换之。<br>（2）过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为（paging),降低指令高速缓存装置的击中率（instruction cache hit rate），以及伴随这些而来的效率损失。<br>（3）inline只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出，隐喻方式是将函数定义于class定义式内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> theAge;&#125;<span class="hljs-comment">//一个隐喻的inline申请</span><br>   <span class="hljs-comment">//age被定义于class定义式内</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> theAge;                    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：<br>（1）将大多数inlining限制在小型，被频繁调用的函数身上。这可使日后的调试过程和大多数二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。<br>（2）不要只因为function templates出现在头文件，就将它们声明为inline</p><h3 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h3><p><strong>说明</strong>：接口与实现分离的关键在于”声明的依存性“替代”定义的依存性“，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。<br><strong>总结</strong>：<br>（1）支持“编译依存性最小化”的一般构想是：相依存于定义式。基于此构想的俩个手段是handle class和Interface classes<br>（2）程序库头文件应该以“”完全且仅有声明式的形式存在，这种做法不论是否涉及templates都适用。</p><h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><h3 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h3><p><strong>总结</strong>：public继承意味is-a。适用于base classes身上的每一件事请也一定适用于derived classes身上，因为每一个derived classes对象也都是一个base classes对象。</p><h3 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h3><p><strong>总结</strong>：<br>（1）derived classes内的名称会遮掩base classes内的名称，在public继承下从来没有人希望如此。<br>（2）为了让被遮掩的名称再见天日，可使用using声明式或转交函数</p><h3 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h3><p><strong>总结</strong>：<br>（1）接口继承和实现继承不同。在public继承之下，派生类总是继承基类的接口<br>（2）纯虚函数只具体指定接口继承<br>（3）非纯虚函数具体指定接口继承及缺省实现继承<br>（4）non-virtual函数具体指定接口继承及强制性实现继承</p><h3 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h3><p><strong>总结</strong>：<br>（1）virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式<br>（2）将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员<br>（3）tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物（callable entities）。</p><h3 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h3><p><strong>总结</strong>：绝不重新定义继承而来的non-virtual函数</p><h3 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h3><p><strong>总结</strong>：绝不重新定义继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数-你唯一应该覆写的东西-却是动态绑定</p><h3 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h3><p><strong>总结</strong>：<br>（1）复合（composition）的意义和public继承完全不同<br>（2）在应用域（application domian），复合意味着has-a（有一个）。在实现域（implementation domain），复合意味着is-implementation-in-terms-of(根据某物实现出)</p><h3 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h3><p><strong>总结</strong>：<br>（1）Private继承意味着is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低，但是当derived-class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计时合理的。<br>（2）和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要</p><h3 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h3><p><strong>总结</strong>：<br>（1）多重继承比单一继承复杂，它可能导致新的歧义性，以及对virtual继承的需要。<br>（2）virtual继承会增加大小，速度，初始化（及赋值）复杂度等等成本，如果virtual base classes不带任何数据，将是最具实用价值的情况。<br>（3）多重继承的确有正当用途，其中一个情节涉及“public”继承某个“Interface class”和“private继承某个协助实现的class”的俩相结合。</p><h2 id="模型与泛型编程"><a href="#模型与泛型编程" class="headerlink" title="模型与泛型编程"></a>模型与泛型编程</h2><h3 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h3><p><strong>总结</strong>：<br>（1）classes和templates都支持接口（interface）和多态（polymorphism）。<br>（2）对classes而言接口是显式的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期。<br>（3）对template参数而言，接口是隐式的（implicit），奠基于有效表达式。多态则是通过template具现化和函数重载解析（function overloading resolution）发生于编译期</p><h3 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h3><p><strong>总结</strong>：<br>（1）声明template参数时，前缀关键字class和typename可互换<br>（2）请使用关键字typename标识嵌套从属类型名称；但不得在base class lists(基类列)或member intialization list（成员初值列）内以它作为base class修饰符。</p><h3 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h3><p><strong>总结</strong>：可在派生类内通过“this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符“完成。</p><h3 id="条款44：将与参数无关的代码抽离"><a href="#条款44：将与参数无关的代码抽离" class="headerlink" title="条款44：将与参数无关的代码抽离"></a>条款44：将与参数无关的代码抽离</h3><p><strong>总结</strong>：<br>（1）Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系<br>（2）因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数<br>（3）因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representation）的具现类型（instantiation tyes）共享实现代码</p><h3 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h3><p><strong>总结</strong>：<br>（1）请使用member function template(成员函数模板)生成”可接受所有兼容类型“的函数<br>（2）如果声明member templates用于”泛化copy构造“或”泛化assignment操作“你还是需要声明正常的copy构造函数和copy assignment操作符。</p><h3 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h3><p><strong>总结</strong>：<br>当我们编写一个class template,而它所提供之”与此template相关的“函数支持”所有参数之隐式类型转换“时，请将那些函数定义为”class template内部的friend 函数”</p><h3 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h3><p><strong>总结</strong>：<br>（1）Traits classes使得“类型相关信息”在编译期可用，它们以templates和“templates特化”完成实现<br>（2）整合重载技术（overloading）后，traits classes有可能在编译期对类型执行if …else…测试。</p><h3 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h3><p><strong>总结</strong>：<br>（1）Template metaprogramming(TMP，模板元编程)可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率<br>（2）TMP可被用来生成“基于政策选择组合”（based on combrinations of policy choices）的客户定制代码，也可用来避免生成某些特殊类型并不适合的代码。</p><h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><h3 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h3><p><strong>总结</strong>：<br>（1）set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用<br>（2）Nothrow new时一个颇为局限的工具，因为它只适用于内存分配：后继的构造函数调用还是可能抛出异常</p><h3 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h3><p><strong>总结</strong>：<br>有许多理由需要写个自定的new和delete，包括改善效能，对heap运用错误进行调试，收集heap使用信息。</p><h3 id="条款51：编写new和delete时需要固守常规"><a href="#条款51：编写new和delete时需要固守常规" class="headerlink" title="条款51：编写new和delete时需要固守常规"></a>条款51：编写new和delete时需要固守常规</h3><p><strong>总结</strong>：<br>（1）operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用new-handler。它也应该有能力处理0 bytes申请。class专属版本则还应该处理“比正确大小更大的（错误）申请”。<br>（2）operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请”。</p><h3 id="条款52：写了placement-new-也要写-placement-delete"><a href="#条款52：写了placement-new-也要写-placement-delete" class="headerlink" title="条款52：写了placement new 也要写 placement delete"></a>条款52：写了placement new 也要写 placement delete</h3><p><strong>总结</strong>：<br>（1）当你写一个placement operator new，请确定也写出对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断的内存泄露。<br>（2）当你声明placement new和placement delete,请不要无意识（非故意）地遮掩了他们的正常版本</p><h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><h3 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h3><p><strong>总结</strong>：<br>（1）严肃对待编译器发出的警告信息。努力在你的编译器最高（最严苛）警告级别下争取“无任何警告”的荣誉<br>（2）不要过度依赖编译器的报警能力，因为不同的编译器对待事请的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。</p><h3 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h3><p><strong>总结</strong>：<br>（1）C++标准程序库的主要机能由STL、iostreams、locales组成，并包含C99标准程序库<br>（2）TR1添加了智能指针（例如 tr1::shanred_ptr）、一般化函数指针（tr1::function）、hash-based容器、正则表达式（regular expressions）以及另外10个组件的支持<br>（3）TR1自身只是一份规范。为获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost</p><h3 id="条款54：让自己熟悉Boost"><a href="#条款54：让自己熟悉Boost" class="headerlink" title="条款54：让自己熟悉Boost"></a>条款54：让自己熟悉Boost</h3><p><strong>总结</strong>：<br>（1）Boost时一个社群，也是一个网站，致力于免费、源码开放、同僚复审的C++程序库开发。Boost C++标准化过程中扮演深具影响力的角色。<br>（2）Boost提供许多TR1组件实现品，以及其他许多程序库.</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之排序</title>
    <link href="/2023/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/10/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>本文将对数据结构中的排序进行归纳学习</p><h2 id="排序框图整理"><a href="#排序框图整理" class="headerlink" title="排序框图整理"></a>排序框图整理</h2><p><img src="/../image/ds/sort.png" alt="在这里插入图片描述"><br>通常排序有以下俩种操作：<br>（1）比较俩个关键字大小<br>（2)将记录从一个位置移动到另一个位置</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：将序列分为有序和无序俩部分，每次取一无序最左边元素插入有序元素中，一直与其前一元素比较，直至找到合适位置。第一次时，有序元素为array[0]</p><ul><li>直接插入：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::Swap</span><span class="hljs-params">(T*a, T *b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = *a;<br>*a = *b;<br>*b = temp;<br><br>&#125;<br><br><span class="hljs-comment">/*直接插入排序*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::InsertSort</span><span class="hljs-params">(T* array, T length)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (array[i] &lt; array[i - <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">Swap</span>(&amp;array[i], &amp;array[i - <span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span> &amp;&amp; array[j] &lt; array[j<span class="hljs-number">-1</span>]; --j)<br>&#123;<br><span class="hljs-built_in">Swap</span>(&amp;array[j], &amp;array[j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>折半插入<br>思想：直接插入的思想类似，但在查找方式上采用折半查找。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::BInsertSort</span><span class="hljs-params">(T* array, T length)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i)<br>&#123;<br>tmp = array[i];<br><br><span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> high = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (low &lt;= high)<br>&#123;<br><span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (tmp &gt;= array[mid])<br>&#123;<br>low = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>high = mid - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= high + <span class="hljs-number">1</span>; --j)<br>&#123;<br>array[j] = array[j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//在处理之前使用临时变量存储</span><br>array[high+<span class="hljs-number">1</span>] = tmp;<span class="hljs-comment">//此处易写成array[i],注意此时序列nums已经数值发生变化</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>二路插入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*减小移动次数*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::TInsertSort</span><span class="hljs-params">(T* array, T length)</span></span><br><span class="hljs-function"></span>&#123;<br>T arr_tmp[MAX_SIZE];<br><br><span class="hljs-type">int</span> head = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br><br>arr_tmp[<span class="hljs-number">0</span>] = array[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (array[i] &lt; arr_tmp[head])<br>&#123;<br>head = (head - <span class="hljs-number">1</span> + length) % length;<br>arr_tmp[head] = array[i];<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[i] &gt; arr_tmp[tail])<br>&#123;<br>tail++;<br>arr_tmp[tail] = array[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>tail++;<br>arr_tmp[tail] = arr_tmp[tail - <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (j = tail - <span class="hljs-number">1</span>; array[i] &lt; arr_tmp[(j - <span class="hljs-number">1</span> + length) % length]; <br>j = (j<span class="hljs-number">-1</span>+length)%length )<br>&#123;<br>arr_tmp[j] = arr_tmp[(j - <span class="hljs-number">1</span> + length) % length];<br>&#125;<br>arr_tmp[j] = array[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i)<br>&#123;<br>array[i] = arr_tmp[head];<br>head = (head + <span class="hljs-number">1</span>) % length;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li>数据基本有序时，直接插入效率大大提高；</li><li>由于直接插入排序在n很小时效率比较高；</li></ul><p>希尔排序：<br>    先将整个待排记录序列分割为若干子序列分别进行直接插入排序，待<br>    整个序列中的记录“基本有序”时，再对全体记录一次直接插入排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::ShellSort</span><span class="hljs-params">(T* array,<span class="hljs-type">int</span> len1, T* delta,  <span class="hljs-type">int</span> len2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//按一定增量来划分序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len2; ++i)<br>&#123;<br>T tmp = <span class="hljs-number">0</span>;<br>T dk = delta[i];<br><span class="hljs-comment">//在相应序列内进行插入排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = dk; j &lt; len1; ++j)<br>&#123;<br><span class="hljs-keyword">if</span> (array[j] &lt; array[j - dk])<br>&#123;<br>tmp = array[j];<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span> ( k = j - dk; k &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; array[k]; k -= dk)<br>&#123;<br>array[k+dk] = array[k];<br>;&#125;<br>array[k+dk] = tmp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::BubbleSort</span><span class="hljs-params">(T *array, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - i - <span class="hljs-number">1</span>; ++j)<br>&#123;<br><span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>])<br><span class="hljs-built_in">Swap</span>(&amp;array[j],&amp;array[j+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>将序列一分为2，递归排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">T <span class="hljs-title">Sort::Partition</span><span class="hljs-params">(T *array, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>T pk = array[low];<br><span class="hljs-keyword">while</span> (low &lt; high)<br>&#123;<br><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pk)<br>&#123;<br>high--;<br>&#125;<br>array[low] = array[high];<br><span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt; pk)<br>&#123;<br>low++;<br>&#125;<br>array[high] = array[low];<br>&#125;<br>array[low] = pk;<br><span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::QuickSort</span><span class="hljs-params">(T *array, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (low &lt; high)<br>&#123;<br><span class="hljs-type">int</span> pkloc = <span class="hljs-built_in">Partition</span>(array, low, high);<br><span class="hljs-built_in">QuickSort</span>(array, low, pkloc - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">QuickSort</span>(array, pkloc + <span class="hljs-number">1</span>, high);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>思想：每次找到剩余序列中的最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sort::SelectMinKey</span><span class="hljs-params">(T* array, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>T minkey = MAX_VALUE;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; len; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (array[i] &lt; minkey)<br>&#123;<br>minkey = array[i];<br>j = i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::SelectSort</span><span class="hljs-params">(T* array, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; ++i)<br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">SelectMinKey</span>(array, i , len);<br><span class="hljs-keyword">if</span> (j != i)<br>&#123;<br><span class="hljs-built_in">Swap</span>(&amp;array[j], &amp;array[i]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>创建堆</li><li>如何建立小堆（完全二叉树来存储）</li><li>删除堆顶元素后如何更新</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Sort&lt;T&gt;::<span class="hljs-built_in">siftdown</span>(arr &amp;heap, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p)<br>&#123;<br><span class="hljs-type">int</span> i = p;<br><span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (j &lt; n)<br>&#123;<br><span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; heap[j] &gt; heap[j + <span class="hljs-number">1</span>])<br>j++;<br><span class="hljs-keyword">if</span> (heap[i] &lt;= heap[j])<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">swap</span>(heap[i], heap[j]);<br>i = j;<br>j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">int</span> Sort&lt;T&gt;::<span class="hljs-built_in">RemoveMinKey</span>(arr&amp; heap, <span class="hljs-type">int</span> n)<br>&#123;<br><span class="hljs-type">int</span> key = heap[<span class="hljs-number">0</span>];<br>heap[<span class="hljs-number">0</span>] = heap[n];<br><span class="hljs-built_in">siftdown</span>(heap, n, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Sort&lt;T&gt;::<span class="hljs-built_in">HeapSort</span>(arr&amp; nums, <span class="hljs-type">int</span> n)<br>&#123;<br><span class="hljs-type">int</span> heap[MAXSIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>heap[i] = nums[i];<br>&#125;<br><span class="hljs-type">int</span> spos = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-comment">//建立最小堆结构</span><br><span class="hljs-comment">//判断是否有左右子树，有则与其比较，选出最小值，作为父节点</span><br><span class="hljs-keyword">while</span> (spos--)<br>&#123;<br><span class="hljs-built_in">siftdown</span>(heap, n, spos);<br>&#125;<br><span class="hljs-comment">//删除堆顶元素后更新</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>nums[i] = <span class="hljs-built_in">RemoveMinKey</span>(heap, n-i<span class="hljs-number">-1</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数据结构-C语言版》[严蔚敏,吴伟民版]</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TopK理解与实现</title>
    <link href="/2023/10/25/TopK%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/10/25/TopK%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="堆实现Topk"><a href="#堆实现Topk" class="headerlink" title="堆实现Topk"></a>堆实现Topk</h2><p>时间复杂度：O(nlogk)<br>思路：</p><ol><li>通过小顶堆实现TopK（小顶堆的堆顶元素小于左右子树的值，当设定堆空间为K时，每次选择是否更新堆顶元素，若更新则进行相应调整）</li><li>构建堆：构建一个heap,元素个数为K，以完全二叉树的结构去理解数组中元素之间的关系，根节点为i(下标从0开始)，则左儿子下标为2<em>i+1,右儿子为2</em>i+2；</li><li>调整小顶堆：从n&#x2F;2-1的下标开始构建（完全二叉树的最后一个分支），选择左右子节点的最小值，进行交换，为确保最后所有分支都满足小顶堆，所以当每次交换后，以被换掉的下标重新开始调整</li><li>如果当前元素比堆顶元素大，则更新堆顶元素，从堆顶元素的下标开始调整。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uptodown</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heap, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = pos;<br><span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (j &lt; k)<br>&#123;<br><span class="hljs-keyword">if</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; heap[j] &gt; heap[j + <span class="hljs-number">1</span>])<br>j++;<br><span class="hljs-keyword">if</span> (heap[i] &lt;= heap[j])<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">swap</span>(heap[i], heap[j]);<br>i = j;<br>j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_heap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heap, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> pos = k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">uptodown</span>(heap, k, i);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-number">5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">52</span>,<span class="hljs-number">78</span>,<span class="hljs-number">59</span>,<span class="hljs-number">46</span>,<span class="hljs-number">49</span>,<span class="hljs-number">65</span>,<span class="hljs-number">42</span>,<span class="hljs-number">15</span>,<span class="hljs-number">34</span>,<span class="hljs-number">28</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">heap</span><span class="hljs-params">(k, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>&#123;<br>heap[i] = nums[i];<br>&#125;<br><span class="hljs-built_in">create_heap</span>(heap, k);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">if</span> (nums[i] &gt; heap[<span class="hljs-number">0</span>])<br>&#123;<br>heap[<span class="hljs-number">0</span>] = nums[i];<br><span class="hljs-built_in">uptodown</span>(heap, k, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; heap.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; heap[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="快排实现Topk"><a href="#快排实现Topk" class="headerlink" title="快排实现Topk"></a>快排实现Topk</h2><p>时间复杂度：平均O(N)<br>思路：</p><ol><li>利用快排的思想实现，每次可以得到一个元素下标，在这个元素下标左边，所有元素比这个元素小，在这个元素右边，所有元素都比这个元素大</li><li>如果右边的元素个数等于K-1，则加上当前元素，达到K个，可知TOPK的元素为这K个；</li><li>如果右边的元素个数小于K-1, 则在左边范围寻找K-len个元素</li><li>如果右边的元素个数大于K-1, 则在右边范围寻找K个元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pk = nums[low];<br>    <span class="hljs-keyword">while</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= pk)<br>            high--;<br>        nums[low] = nums[high];<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt; pk)<br>            low++;<br>        nums[high] = nums[low];<br>    &#125;<br>    nums[high] = pk;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_topk</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-type">int</span> len = high - pos - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(len == k)<br>            index = pos;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &lt; k)<br>        &#123;<br>            index = <span class="hljs-built_in">quick_topk</span>(nums, low, pos<span class="hljs-number">-1</span>, k-len);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            index = <span class="hljs-built_in">quick_topk</span>(nums, pos+<span class="hljs-number">1</span>, high, k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-number">5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">52</span>,<span class="hljs-number">1</span>,<span class="hljs-number">59</span>,<span class="hljs-number">46</span>,<span class="hljs-number">49</span>,<span class="hljs-number">65</span>,<span class="hljs-number">58</span>,<span class="hljs-number">15</span>,<span class="hljs-number">34</span>,<span class="hljs-number">28</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">quick_topk</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=nums.<span class="hljs-built_in">size</span>()-k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Prometheus+Grafana搭建性能监控系统</title>
    <link href="/2023/10/25/%E5%9F%BA%E4%BA%8EPrometheus-Grafana%E6%90%AD%E5%BB%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/10/25/%E5%9F%BA%E4%BA%8EPrometheus-Grafana%E6%90%AD%E5%BB%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Prometheus-Grafana搭建性能监测工具"><a href="#基于Prometheus-Grafana搭建性能监测工具" class="headerlink" title="基于Prometheus+Grafana搭建性能监测工具"></a><strong>基于Prometheus+Grafana搭建性能监测工具</strong></h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a><strong>需求</strong></h2><ul><li><p>监测数据类型：JVM数据、玩家在线人数、消息时延等</p></li><li><p>接入Prometheus性能监测工具，暴露服务器性能监测数据</p></li><li><ul><li>模式：pull&#x2F;push</li></ul></li><li><p>接入Grafana可视化数据</p></li><li><p>Prometheus框架图</p></li></ul><p><img src="/../image/develop/promethus.png" alt="img"></p><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>Java客户端配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- The client --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Hotspot JVM metrics--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_hotspot&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Exposition HTTPServer--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_httpserver&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Pushgateway exposition--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_pushgateway&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- JMX Collector--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus.jmx&lt;/groupId&gt;<br>    &lt;artifactId&gt;collector&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.jmx.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在本文的背景下，需要配置俩个文件：<br><strong>1.jmx 的yaml文件，主要用于管理JMX Exporter的数据，即需要暴露的JVM参数；</strong><br><a href="https://github.com/jetbrains-infra/prometheus-jmx-exporter/blob/master/config.yml.template">jmx 的yaml文件</a><br>其中hostPort,username,password可以选择先屏蔽掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#hostPort: $&#123;JMX_HOSTPORT&#125;</span><br><span class="hljs-comment">#username:</span><br><span class="hljs-comment">#password:</span><br></code></pre></td></tr></table></figure><p><strong>2.prometheus服务器的运行配置文件,注意替换配置文件中的ip和port</strong><br>● ip直接设置为本机IP, windows下ipconfig可以查询，Mac下ipconfig<br>● 在pull模式下，配置的port1为暴露的Http端口<br>● 在push模式下，配置的port2为push-gateway运行的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">global:<br>  scrape_interval:     15s<br>  evaluation_interval: 15s<br> <br>scrape_configs:<br><span class="hljs-comment"># pull mode</span><br>  - job_name: game-pull<br>    static_configs:<br>      - targets: [<span class="hljs-string">&#x27;ip:port1&#x27;</span>]<br>        labels:<br>          instance: app-pull<br><span class="hljs-comment"># push mode</span><br>  - job_name: game-push<br>    static_configs:<br>      - targets: [<span class="hljs-string">&#x27;ip:port2&#x27;</span>]<br>        labels:<br>          instance: app-push<br><br></code></pre></td></tr></table></figure><h3 id="部署-Prometheus"><a href="#部署-Prometheus" class="headerlink" title="部署 Prometheus"></a>部署 Prometheus</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus<br><span class="hljs-comment">#指定prometheus配置文件运行</span><br>docker run -d -p 9090:9090 -v E://project//hotel//hotel-script//prometheus.yml:/etc/prometheus/prometheus.yml  prom/prometheus<br></code></pre></td></tr></table></figure><h3 id="部署-Prometheus-PushGateWay"><a href="#部署-Prometheus-PushGateWay" class="headerlink" title="部署 Prometheus-PushGateWay"></a>部署 Prometheus-PushGateWay</h3><p><a href="https://github.com/Prometheus/pushgateway">Prometheus-PushGateWay</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull prom/pushgateway<br>docker run -d -p 9091:9091 prom/pushgateway<br></code></pre></td></tr></table></figure><p>部署 Grafana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 3000:3000 --name=grafana  grafana/grafana<br></code></pre></td></tr></table></figure><p>启动后，访问：<a href="http://localhost:3000，默认用户名密码">http://localhost:3000，默认用户名密码</a> admin&#x2F;admin。</p><h3 id="添加-Prometheus-数据源"><a href="#添加-Prometheus-数据源" class="headerlink" title="添加 Prometheus 数据源"></a>添加 Prometheus 数据源</h3><p>Settings-&gt;Data sources -&gt; Add data source -&gt; Prometheus </p><p>● 在HTTP URL中填写本机IP+Prometheus服务器运行的port.<br>● HTTP Method选择Get方法</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>1.Error reading Prometheus: An error occurred within the plugin</strong><br>将添加数据源的ip设置为本机ip，当设置为localhost时由于容器环境运行的grafana，所以localhost在容器内部可能有自己的定义。</p><p><strong>2.prometheus有数据 grafana无数据</strong><br>grafana可以通过PromeSQL语句查询对应的参数</p><p><a href="https://www.modb.pro/db/412613">Prometheus | Grafana导入模板后发现没有数据排查步骤 - 墨天轮</a><br><a href="https://blog.csdn.net/weixin_52837796/article/details/120768817">prometheus+grafana监控jvm，grafana上没有数据_吃葡萄不吐西瓜皮~的博客-CSDN博客_grafana没有监控数据</a><br><img src="/../image/develop/grafana_interface.png" alt="在这里插入图片描述"></p><p><strong>3 Prometheus Histogram</strong><br>prometheus的histogram是一个累计直方图，正常理解直方图的桶内时对应范围（a&lt;x&lt;b）的数据，prometheus的直方图的桶是累计的值，即当前这个桶的数据包含前一个桶，方便函数筛选，用户最后自己想要啥数据，自己用函数筛选；使用计时相关的api单位默认就是秒，自定义的数据类型就是自定义的数据类型对应的单位。<br>rate(histogram_showcase_metric_bucket[1m]) 查看每个 bucket 的每秒变化率来了解这些 bucket 是如何随时间变化；histogram_quantile() 可以计算出哪个 bucket 标签包含给定的分位数（例如第 95 个百分位数）。<br><img src="/../image/develop/prometheus_bucket.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">histogram_quantile(0.95,rate(requests_latency_seconds_bucket[1m]))<br></code></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1495303">一文搞懂 Prometheus 的直方图 - 腾讯云开发者社区-腾讯云</a><br><a href="https://juejin.cn/post/7152837166190739486">深入理解和使用 Prometheus 的 Histogram 指标类型 - 掘金</a><br><a href="https://blog.csdn.net/qq_34556414/article/details/123151789">PromQL 直方图 跟踪请求的延迟或响应大小 99%的请求是在多少延迟下完成的？_富士康质检员张全蛋的博客-CSDN博客_promql 直方图</a></p><p><strong>4.这俩行代码不在一个线程好像没法用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">new PerfCustomCollector().register();<br>HTTPServer server = new HTTPServer(1234);<br></code></pre></td></tr></table></figure><p><strong>5. windows install curl</strong><br>假设您是从<a href="https://curl.haxx.se/download.html%E8%8E%B7%E5%BE%97%E7%9A%84%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%B0%86%E5%85%B6%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%88%B0%E6%82%A8%E6%83%B3%E8%A6%81%E7%9A%84%E4%BB%BB%E4%BD%95%E4%BD%8D%E7%BD%AE%E3%80%82%E6%97%A0%E9%9C%80%E5%AE%89%E8%A3%85%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E6%89%93%E7%AE%97%E4%BD%BF%E7%94%A8">https://curl.haxx.se/download.html获得的，只需将其解压缩到您想要的任何位置。无需安装。如果您打算使用</a> SSL，则需要下载 OpenSSL DLL，可从 curl 的网站获得。<br>下载卷曲压缩包<br>提取内容（如果您下载了正确的版本，您应该找到 curl.exe）<br>将 curl.exe 放在您保存软件的文件夹中（例如 D:\software\curl\curl.exe）<br>从命令行运行 curl<br>a) 右击“我的电脑”图标<br>b) 选择属性<br>c) 点击“高级系统设置”链接<br>d) 转到选项卡 [高级] - “环境变量”按钮<br>e) 在系统变量下选择“路径”和“编辑”按钮<br>f) 添加一个分号，后跟放置 curl.exe 的路径（例如；D:\software\curl）<br>现在您可以通过键入以下命令从命令行运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl www.google.com<br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.cn/post/6844904062157062151">https://juejin.cn/post/6844904062157062151</a></p><p><a href="https://cloud.tencent.com/developer/article/1495303">https://cloud.tencent.com/developer/article/1495303</a></p><p><a href="https://juejin.cn/post/7152837166190739486">https://juejin.cn/post/7152837166190739486</a></p><p><a href="https://blog.csdn.net/qq_34556414/article/details/123151789">https://blog.csdn.net/qq_34556414/article/details/123151789</a></p>]]></content>
    
    
    <categories>
      
      <category>运维部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Operating System Three Pieces</title>
    <link href="/2023/10/24/Operating-System-Three-Pieces/"/>
    <url>/2023/10/24/Operating-System-Three-Pieces/</url>
    
    <content type="html"><![CDATA[<h2 id="第-9-章-调度：比例份额"><a href="#第-9-章-调度：比例份额" class="headerlink" title="第 9 章 调度：比例份额"></a>第 9 章 调度：比例份额</h2><p><strong>关键问题：如何按比例分配 CPU</strong></p><p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</p><p>比例份额调度程序有一个非常优秀的现代例子，由 Waldspurger 和 Weihl 发现，名为彩 票调度（lottery scheduling） [WW94]。</p><h4 id="彩票调度（lottery-scheduling）"><a href="#彩票调度（lottery-scheduling）" class="headerlink" title="彩票调度（lottery scheduling）"></a>彩票调度（lottery scheduling）</h4><h5 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h5><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><p>彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式 常常是既可靠又简单的选择。</p><p>随机方法相对于传统的决策方式，至少有 3 点优势</p><p>1.随机方法常常可以避免奇怪的边角情况，较传统的算法可能在处理这些情况时遇到麻烦。例如 LRU 替换策略（稍后会在虚拟内存的章节详 细介绍）。虽然 LRU 通常是很好的替换算法，但在有重复序列的负载时表现非常差。但随机方法就没有这种最差情况；</p><p>2.随机方法很轻量，几乎不需要记录任何状态。在传统的公平份额调度算法中，记录每个进程已经获得了多少的 CPU 时间，需要对每个进程计时，这必须在每次运行结束后更新。而采用随机方式后每个进程只需要非常少的状态（即每个进程拥有的彩票号码）；</p><p>3.随机方法很快。只要能很快地产生随机数，做出决策就很快。因此，随机方式在对运行速度 要求高的场景非常适用。当然，越是需要快的计算速度，随机就会越倾向于伪随机。</p><h5 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h5><p>彩票调度还提供了一些机制，以不同且有效的方式来调度彩票。</p><p><strong>彩票货币</strong>（ticket currency）。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币， 将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p><p><strong>彩票转让</strong>（ticket transfer）。通过转让，一个进程可以临时将自己 的彩票交给另一个进程。这种机制在客户端&#x2F;服务端交互的场景中尤其有用，在这种场景中， 客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行， 客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服 务端执行结束后会将这部分彩票归还给客户端。</p><p><strong>彩票通胀</strong>（ticket inflation）。利用通胀，一个进程可以临时提升或 降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么 意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进 程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 CPU 时间，就可以 增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>实现简单，只需要一个不错的随机数生成器来选 择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p><h5 id="如何分配彩票"><a href="#如何分配彩票" class="headerlink" title="如何分配彩票"></a>如何分配彩票</h5><p>系统的运行严重依赖于彩票的分配。假设用户自己知道如何分配，因此可以 给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。然而这种方案似乎什 么也没有解决——还是没有给出具体的分配策略。</p><h5 id="为什么不是确定的"><a href="#为什么不是确定的" class="headerlink" title="为什么不是确定的"></a>为什么不是确定的</h5><p>究竟为什么要利用随机性？从上面的内容可以看出，虽然随机方式 可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作 运行时间很短的情况下。由于这个原因，Waldspurger 提出了步长调度（stride scheduling）， 一个确定性的公平分配算法[W95]。</p><p>待补充</p><h2 id="第-10-章-多处理器调度（高级）"><a href="#第-10-章-多处理器调度（高级）" class="headerlink" title="第 10 章 多处理器调度（高级）"></a>第 10 章 多处理器调度（高级）</h2><p><strong>关键问题：如何在多处理器上调度工作</strong></p><h4 id="背景：多处理器架构"><a href="#背景：多处理器架构" class="headerlink" title="背景：多处理器架构"></a>背景：多处理器架构</h4><p><strong>在单 CPU 系统中</strong>，存在多级的硬件缓存（hardware cache），一般来说会让处理器更快地执行程序。缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。通过将频繁访问的数据放在缓存中， 系统似乎拥有又大又快的内存。</p><h2 id="第-13-章-抽象：地址空间"><a href="#第-13-章-抽象：地址空间" class="headerlink" title="第 13 章 抽象：地址空间"></a>第 13 章 抽象：地址空间</h2><p><strong>关键问题：如何虚拟化内存</strong></p><p>虚拟内存（VM）系统的一个主要目标是透明（transparency），另一个目标是效率（efficiency），第三个目标是保护（protection）</p><h2 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a>第 15 章 机制：地址转换</h2><p>实现 CPU 虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct Execution，LDE）。</p><p>LDE思想：让程序运行的大部分指令直接访问硬件，只在 一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间， 正确的地点，做正确的事”。</p><p><strong>关键问题：如何高效、灵活地虚拟化内存</strong></p><p>利用了一种通用技术，有时被称为基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）。</p><p>利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此， 在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际 的位置。仅仅依靠硬件不足以实现虚拟内存，只是提供了底层机制来提高效率。</p><p>操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。因此它必须管 理内存（manage memory），记录被占用和空闲的内存位置，并明智而谨慎地介入，保持对 内存使用的控制。</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>先假设用户的地址空间必须连续地放在物理内存中。</p><h3 id="动态（基于硬件）重定位"><a href="#动态（基于硬件）重定位" class="headerlink" title="动态（基于硬件）重定位"></a>动态（基于硬件）重定位</h3><p>一个简单的思想，称为基址加界限 机制（base and bound），有时又称为动态重定位（dynamic relocation）：每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">physical <span class="hljs-built_in">address</span> = virtual <span class="hljs-built_in">address</span> + <span class="hljs-built_in">base</span> <br></code></pre></td></tr></table></figure><p>进程中使用的内存引用都是虚拟地址（virtual address），硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址（physical address），再发给内存系统。</p><p>Example:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-number">128</span>: movl <span class="hljs-number">0</span>x0(<span class="hljs-built_in">%ebx</span>), <span class="hljs-built_in">%eax</span> <br></code></pre></td></tr></table></figure><p>程序计数器（PC）首先被设置为 128。当硬件需要获取这条指令时，它先将这个值加上基 址寄存器中的 32KB(32768)，得到实际的物理地址 32896，然后硬件从这个物理地址获取指令。 接下来，处理器开始执行该指令。这时，进程发起从虚拟地址 15KB 的加载，处理器同样将虚 拟地址加上基址寄存器内容（32KB），得到最终的物理地址 47KB，从而获得需要的数据。</p><p> 界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。界限寄存器确保了进程产生的所有地址都在进程的地址“界限”中，提供了访问保护。</p><p>在上面的例子中，界限寄存器被置为 16KB。如果进 程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。</p><p>通常有两种使用方式。在一种方式中（像上面那样），它记 录地址空间的大小，硬件在将虚拟地址与基址寄存器内容求和前，就检查这个界限。另一种方 式是界限寄存器中记录地址空间结束的物理地址，硬件在转化虚拟地址到物理地址之后才去检 查这个界限。</p><h3 id="操作系统的问题"><a href="#操作系统的问题" class="headerlink" title="操作系统的问题"></a>操作系统的问题</h3><p>支持动态重定位，硬件添加了新的功能，使得操作系统有了一些必须处理的新问题。</p><p>第一，在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。</p><p>第二，在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些 工作，回收它的所有内存，给其他进程或者操作系统使用。在进程终止时，操作系统会将 这些内存放回到空闲列表，并根据需要清除相关的数据结构。</p><p>第三，在上下文切换时，操作系统也必须执行一些额外的操作。每个 CPU 毕竟只有一 个基址寄存器和一个界限寄存器，但对于每个运行的程序，它们的值都不同，因为每个程序被加载到内存中不同的物理地址。因此，在切换进程时，操作系统必须保存和恢复基础和界限寄存器。</p><p>第四，操作系统必须提供异常处理程序（exception handler），或要一些调用的函数，像上面提到的那样。操作系统在启动时加载这些处理程序（通过特权命令）。</p><h3 id="带来的挑战"><a href="#带来的挑战" class="headerlink" title="带来的挑战"></a>带来的挑战</h3><p>在我们当前的方式 中，即使有足够的物理内存容纳更多进程，但我们目前要求将地址空间放在固定大小的槽块 中，因此会出现内部碎片。内部碎片（internal fragmentation）， 指的是已经分配的内存单元内部有未使用的空间（即碎片），造成了浪费。以便更好地利用物理内存，避免 内部碎片。第一次尝试是将基址加界限的概念稍稍泛化，得到分段（segmentation）的概念。</p><h2 id="第-16-章-分段"><a href="#第-16-章-分段" class="headerlink" title="第 16 章 分段"></a>第 16 章 分段</h2><p>我们一直假设将所有进程的地址空间完整地加载到内存中。利用基址和 界限寄存器，操作系统很容易将不同进程重定位到不同的物理内存区域。但是，对于这些 内存区域，你可能已经注意到一件有趣的事：栈和堆之间，有一大块“空闲”空间。</p><p><strong>关键问题：怎样支持大地址空间</strong></p><h3 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&#x2F;界限"></a>分段：泛化的基址&#x2F;界限</h3><p>想法很简单，在 MMU 中引入不止 一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是 地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈 和堆。</p><p><strong>分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</strong></p><h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>分段的基本原理：系统运行时，地址空间中的不同段被重定位到物理内存中。与我们之前介绍的整个地址空间只有一个基址&#x2F;界限寄存器对的方式相比， 大量节省了物理内存。具体来说，栈和堆之间没有使用的区域就不需要再分配物理内存， 让我们能将更多地址空间放进物理内存。</p><h4 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h4><p>第一个是老问题：操作系统在上下文切换时应该做什么？你可能已经猜到了：各个段寄存器中的 内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进 程运行前，确保这些寄存器被正确地赋值。</p><p>第二个问题更重要，即管理物理内存的空闲空间。新的地址空间被创建时，操作系统 需要在物理内存中为它的段找到空间。之前，我们假设所有的地址空间大小相同，物理内 存可以被认为是一些槽块，进程可以放进去。现在，每个进程都有一些段，每个段的大小也可能不同。物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为外部碎片（external fragmentation）[R69]，</p><p>一种解决方案是紧凑（compact）物理内存，重新安排原有的段。另一种更简单的做法是利用空闲列表管理算法，试图保留大的内存块用于分配。</p><p>相关的算法包括传统的最优匹配（best-fit，从空闲链表中找最接近需要分配空 间的空闲块返回）、最坏匹配（worst-fit）、首次匹配（first-fit）以及像伙伴算法（buddy algorithm） [K68]这样更复杂的算法。</p><p>但遗憾的是，无论算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>分段解决了一些问题，帮助我们实现了更高效的虚拟内存。不只是动态重定位，通过 避免地址空间的逻辑段之间的大量潜在的内存浪费，分段能更好地支持稀疏地址空间。它 还很快，因为分段要求的算法很容易，很适合硬件完成，地址转换的开销极小。分段还有 一个附加的好处：代码共享。如果代码放在独立的段中，这样的段就可能被多个运行的程 序共享。</p><h2 id="第-17-章-空闲空间管理"><a href="#第-17-章-空闲空间管理" class="headerlink" title="第 17 章 空闲空间管理"></a>第 17 章 空闲空间管理</h2><p>如果需要管理的空间被划分为固定大小的单元，只需要维护这 些大小固定的单元的列表；</p><p> 如果要管理的空闲空间由大小不同的单元构成，出现在用户级的内存分配库（如 malloc()和 free()），或者操作系统用分段（segmentation） 的方式实现虚拟内存。</p><p>在这两种情况下，出现了外部碎片（external fragmentation）的问题： 空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够 大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</p><p><strong>关键问题：如何管理空闲空间</strong></p><p>要满足变长的分配请求，应该如何管理空闲空间？什么策略可以让碎片最小化？不同方法的时间和 空间开销如何？</p><h3 id="假设-1"><a href="#假设-1" class="headerlink" title="假设"></a>假设</h3><p>假定基本的接口就像 malloc()和 free()提供的：函数返回一个指针（没有具体的类型， 在 C 语言的术语中是 void 类型），指向这样大小（或较大一点）的一块空间。对应的函数 void free(void *ptr)函数接受一个指针，释放对应的内存块。请注意该接口的隐含意义，在释 放空间时，用户不需告知库这块空间的大小。因此，在只传入一个指针的情况下，库必须能够弄清楚这块内存的大小。</p><p>该库管理的空间由于历史原因被称为堆，在堆上管理空闲空间的数据结构通常称为空 闲列表（free list）。该结构包含了管理内存区域中所有空闲块的引用。</p><p>当然，该数据结构不 一定真的是列表，而只是某种可以追踪空闲空间的数据结构。</p><h2 id="第-18-章-分页：介绍"><a href="#第-18-章-分页：介绍" class="headerlink" title="第 18 章 分页：介绍"></a>第 18 章 分页：介绍</h2><h2 id="第-19-章-分页：快速地址转换（TLB）"><a href="#第-19-章-分页：快速地址转换（TLB）" class="headerlink" title="第 19 章 分页：快速地址转换（TLB）"></a>第 19 章 分页：快速地址转换（TLB）</h2><h2 id="第-20-章-分页：较小的表"><a href="#第-20-章-分页：较小的表" class="headerlink" title="第 20 章 分页：较小的表"></a>第 20 章 分页：较小的表</h2><h2 id="第-21-章-超越物理内存：机制"><a href="#第-21-章-超越物理内存：机制" class="headerlink" title="第 21 章 超越物理内存：机制"></a>第 21 章 超越物理内存：机制</h2><h2 id="第-22-章-超越物理内存：策略"><a href="#第-22-章-超越物理内存：策略" class="headerlink" title="第 22 章 超越物理内存：策略"></a>第 22 章 超越物理内存：策略</h2><h2 id="第-23-章-VAX-VMS-虚拟内存系统"><a href="#第-23-章-VAX-VMS-虚拟内存系统" class="headerlink" title="第 23 章 VAX&#x2F;VMS 虚拟内存系统"></a>第 23 章 VAX&#x2F;VMS 虚拟内存系统</h2><h2 id="内存管理总结"><a href="#内存管理总结" class="headerlink" title="内存管理总结"></a>内存管理总结</h2><h3 id="独占式内存管理"><a href="#独占式内存管理" class="headerlink" title="独占式内存管理"></a>独占式内存管理</h3><p>在多任务并发运行时，每次任务切换都会涉及内存和磁盘之间的数据拷贝，效率低下；</p><p>最直观的解决方法是将程序的数据都常驻在内存中（假设内存足够），避免数据拷贝。但程序之间的内存地址空间是没有隔离的。引入虚拟化管理。</p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>OS为每个程序都虚拟化出一段内存空间，并映射到一段物理内存上。对程序而言，只看得到自己的虚拟地址空间。</p><h3 id="程序内存管理"><a href="#程序内存管理" class="headerlink" title="程序内存管理"></a>程序内存管理</h3><p>虚拟内存空间分为3个区域，<strong>Code</strong>区域存储的是程序代码的机器指令；<strong>Heap</strong>区域存储程序运行过程中动态申请的内存；<strong>Stack</strong>区域则是存储函数入参、局部变量、返回值等。Heap和Stack会在程序运行过程中不断增长，分别放置在虚拟内存空间的上方和下方，并往相反方向增长。</p><p>虚拟地址空间到物理地址空间的映射，需要一个转换。位于CPU芯片内的MMU（内存管理单元）负责。</p><p>MMU需要<strong>base</strong>和<strong>bound</strong>两个寄存器。其中<strong>base</strong>寄存器用来存储程序在物理内存上的<strong>基地址</strong>；<strong>bound</strong>寄存器（有时候也叫<strong>limit</strong>寄存器）则保存虚拟地址空间的Size，主要用来避免越界访问</p><blockquote><p><strong>物理地址 &#x3D; 虚拟地址 + 基地址</strong></p></blockquote><p>但Heap，Stack区域之间有很大一部分空闲内存是“已申请，未使用”的空闲状态。但再也无法分配给其他程序使用，导致内存利用率低下的问题。为解决这个问题，引入段式内存管理。</p><h3 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h3><p><strong>段（Segment）是逻辑上的概念，本质上是一块连续的、有一定大小限制的内存区域</strong>，前文中，我们一共提到过3个段：Code、Heap和Stack。</p><p>段式内存管理以段为单位进行管理，它允许OS将每个段灵活地放置在物理内存的空闲位置上，因此也避免了“已申请，未使用”的内存区域出现：</p><h4 id="内存共享和保护"><a href="#内存共享和保护" class="headerlink" title="内存共享和保护"></a>内存共享和保护</h4><p>段式内存管理还可以很方便地<strong>支持内存共享</strong>，从而达到节省内存的目的。比如，如果存在多个程序都是同一个可执行文件运行起来的，那么这些程序是可以共享Code段的。为了实现这个功能，我们可以在虚拟地址上设置保护位，当保护位为只读时，表示该段可以共享。另外，如果程序修改了只读的段，则转换地址失败，因此也可以达到<strong>内存保护</strong>的目的。</p><h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>段式内存管理的最明显的缺点就是<strong>容易产生内存碎片</strong>，这是因为在系统上运行的程序的各个段的大小往往都不是固定的，而且段的分布也不是连续的。当系统的内存碎片很多时，内存的利用率也会急剧下降，对外表现就是<strong>虽然系统看起来还有很多内存，却无法再运行起一个程序</strong>。</p><p>碎片整理的代价极大，一方面需要进行多次内存拷贝；另一方面，在拷贝过程中，正在运行的程序必须停止，这对于一些以人机交互任务为主的应用程序，将会极大影响用户体验。</p><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p>页式内存管理的思路，是将虚拟内存和物理内存都划分为多个<strong>固定大小的区域</strong>，这些区域我们称之为<strong>页</strong>（<strong>Page</strong>）。页是内存的最小分配单位，一个应用程序的虚拟页可以存放在任意一个空闲的物理页中。</p><blockquote><p>物理内存中的页，我们通常称之为页帧（Page Frame）</p></blockquote><p><strong>因为页的大小是固定的，而且作为最小的分配单位，这样就可以解决段式内存管理中内存碎片的问题了</strong>。但页内仍然有可能存在内存碎片。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程浅学</title>
    <link href="/2023/10/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B5%85%E5%AD%A6/"/>
    <url>/2023/10/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B5%85%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程编程由浅入深"><a href="#多线程编程由浅入深" class="headerlink" title="多线程编程由浅入深"></a>多线程编程由浅入深</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>程序(program)<strong>：</strong>为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指一段静态的代码，静态对象。</p><p><strong>进程(process)<strong>：程序的一次执行过程，或是</strong>正在运行的一个程序</strong>。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p><p>（1）<strong>进程为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域</p><p><strong>线程(thread)<strong>，进程可进一步细化为线程，是</strong>一个程序内部的一条执行路径</strong>。</p><p>（1）若一个进程同一时间并行执行多个线程，就是支持多线程的<br>（2）<strong>线程是调度和执行的单位</strong>，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小<br>（3）一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间—》它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p><p><strong>并行</strong>：多个CPU同时执行多个任务。比如：多个人同时做不同的事。是真正的同时。</p><p><strong>并发</strong>：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p><h2 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h2><h3 id="方式1-继承Thread类"><a href="#方式1-继承Thread类" class="headerlink" title="方式1:继承Thread类"></a>方式1:继承Thread类</h3><p>（1）创建一个继承于Thread类的子类</p><p>（2）重写Thread类的run（）–》将此线程执行的操作声明在run（）中</p><p>（3）创建THread类的子类的对象</p><p>（4）通过此对象调用start（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class Thread extends Object implements Runnable</span><br><span class="hljs-comment"> * Thread 类也是 Runnable 接口的子类，但在Thread类中并没有完全实现 Runnable 接口中的 run() 方法</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <span class="hljs-comment">// 继承Thread类，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> String name ;       <span class="hljs-comment">// 表示线程的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;      <span class="hljs-comment">// 通过构造方法配置name属性</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行，i = &quot;</span> + i) ;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程A &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程B &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        mt1.start() ;   <span class="hljs-comment">// 调用线程主体</span><br>        mt2.start() ;   <span class="hljs-comment">// 调用线程主体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方式2-实现Runnable接口"><a href="#方式2-实现Runnable接口" class="headerlink" title="方式2:实现Runnable接口"></a>方式2:实现Runnable接口</h3><p>（1）创建一个实现了Runnable接口得类</p><p>（2）实现类去实现Runnable中的抽象方法:run()</p><p>（3）创建实现类的对象</p><p>（4）将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><p>（5）通过Thread类的对象调用start()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现 Runnable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> String name ;       <span class="hljs-comment">// 表示线程的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;      <span class="hljs-comment">// 通过构造方法配置name属性</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行，i = &quot;</span> + i) ;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程A &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程B &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt2) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h3><ul><li>开发中：优先选择：实现Runnable接口的方式</li><li>原因：</li><li><ol><li>实现的方式没有类的单继承性的局限性</li></ol></li><li><ol start="2"><li>实现的方式更适合来处理多个线程有共享数据的情况。</li></ol></li><li>联系：public class Thread implements Runnable—Thread 类也是 Runnable 接口的子类，但在Thread类中并没有完全实现 Runnable 接口中的 run() 方法</li><li>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</li></ul><h2 id="测试Thread类的常用方法"><a href="#测试Thread类的常用方法" class="headerlink" title="测试Thread类的常用方法"></a>测试Thread类的常用方法</h2><ul><li>1.start():启动当前线程，执行当前线程的run()</li><li>2.run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>3.currentThread(): 静态方法，返回当前代码执行的线程</li><li>4.getName():获取当前线程的名字</li><li>5.setName():设置当前线程的名字</li><li>6.yield():释放当前CPU的执行权</li><li>7.join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才</li><li>结束阻塞状态。</li><li>8.stop():已过时。当执行此方法时，强制结束当前线程。</li><li>9.sleep(long millitime)：让当前线程“睡眠”指定时间的millitime毫秒)。在指定的millitime毫秒时间内，</li><li>当前线程是阻塞状态的。</li><li>10.isAlive()：返回boolean，判断线程是否还活着</li></ul><h2 id="多线程的调度"><a href="#多线程的调度" class="headerlink" title="多线程的调度"></a>多线程的调度</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>时间片</p><p>抢占式：高优先级的线程抢占CPU</p><h3 id="JAVA调度方法"><a href="#JAVA调度方法" class="headerlink" title="JAVA调度方法"></a>JAVA调度方法</h3><p>同优先级线程组成先进先出队列，先到先服务，使用时间片策略</p><p>对高优先级，使用优先调度的抢占式策略</p><p>MAX_PRIORITY:10:</p><p>MIN_PRIORITY:1</p><p>NORM_PRIORITY:5</p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>setPriority()</p><p>getPriority()</p><p><strong>说明</strong>：高优先级的线程要抢占低优先级线程CPU的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完才能执行低优先级的线程</p><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="/../image/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A21.png"></p><h3 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h3><p>创建后尚未启动。</p><h3 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h3><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p>一旦调用start（），线程即进入runnable状态</p><h3 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h3><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h3 id="等待（Waiting）"><a href="#等待（Waiting）" class="headerlink" title="等待（Waiting）"></a>等待（Waiting）</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>-</td></tr></tbody></table><h3 id="计时等待（Timed-Waiting）"><a href="#计时等待（Timed-Waiting）" class="headerlink" title="计时等待（Timed Waiting）"></a>计时等待（Timed Waiting）</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 &#x2F; 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>-</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>-</td></tr></tbody></table><h3 id="终止（Terminated）"><a href="#终止（Terminated）" class="headerlink" title="终止（Terminated）"></a>终止（Terminated）</h3><p>（1）可以是线程结束任务之后自己结束，</p><p>（2）或者产生了异常而结束。</p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>使用多线程的好处和坏处？</p><h5 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h5><p>（1）提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p><p>（2）提高计算机系统CPU的利用率</p><p>（3）改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p><p>（4）可以分别设置各个任务的优先级以优化性能。</p><h5 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h5><p>（1）等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。</p><p>（2）对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担 超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。</p><p>（3）线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。</p><p>（4）对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个 线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机 器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错 误是程序员无法预知的。</p></li><li><p>多线程的使用场景</p><p>（1）程序需要同时执行两个或多个任务。</p><p>（2）程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p><p>（3）需要一些后台运行的程序时。</p></li><li><p>什么是线程并发？</p><p>一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p></li><li><p>各种锁的使用场景？</p></li><li><p>常用的高并发队列？</p></li><li><p>锁和队列的区别？</p></li></ol><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.multithread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wenhoulai &lt;wenhoulai@kuaishou.com&gt;</span><br><span class="hljs-comment"> * Created on 2021-07-09</span><br><span class="hljs-comment"> * Java中线程实现的方式:</span><br><span class="hljs-comment"> * (1)一种是继承 Thread 类;</span><br><span class="hljs-comment"> * (2)另一种就是实现 Runnable 接口。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//实现 Runnable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;              <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//synchronized</span><br>            <span class="hljs-keyword">synchronized</span> (MyThread.class) &#123;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; :run, num = &quot;</span> + num);<br>                    num--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;     <span class="hljs-comment">// 实例化对象</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br><br>        t1.setName(<span class="hljs-string">&quot;线程A&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;线程B&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;线程C&quot;</span>);<br><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t3.start() ;    <span class="hljs-comment">// 启动多线程</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;              <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; :run, num = &quot;</span> + num);<br>            num--;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;     <span class="hljs-comment">// 实例化对象</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br><br>        t1.setName(<span class="hljs-string">&quot;线程A&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;线程B&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;线程C&quot;</span>);<br><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t3.start() ;    <span class="hljs-comment">// 启动多线程</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-keyword">return</span> s1 + s2 + s3;<br>&#125;<br></code></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    sb.append(s3);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，<strong>对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作</strong>。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，<strong>ConcurrentHashMap中的分段锁称为Segment</strong>，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即**内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)**。</p><p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是<strong>先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁</strong>，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<strong>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p><h2 id="锁分类-按性质分类"><a href="#锁分类-按性质分类" class="headerlink" title="锁分类-按性质分类"></a>锁分类-按性质分类</h2><h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h3><p><strong>公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</strong>。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，<strong>通过构造函数指定该锁是否是公平锁，默认是非公平锁。</strong>非公平锁的优点在于吞吐量比公平锁大。对于<strong>Synchronized而言，也是一种非公平锁</strong>。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<strong>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式</strong>。悲观的认为，不加锁的并发操作一定会出问题。<strong>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</strong>从上面的描述我们可以看出，<strong>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景</strong>，不加锁会带来大量的性能提升。<strong>悲观锁在Java中的使用，就是利用各种锁</strong>。<strong>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</strong></p><h3 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h3><p><strong>独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有</strong>。<strong>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁</strong>。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<strong>对于Synchronized而言，当然是独享锁。</strong></p><h3 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h3><p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。互斥锁在Java中的具体实现就是<strong>ReentrantLock</strong>，<strong>读写锁在Java中的具体实现就是ReentrantReadWriteLock</strong></p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，<strong>其名字是Reentrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。</strong>可重入锁的一个好处是可一定程度避免死锁。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></p><p><a href="https://blog.csdn.net/PorkBird/article/details/113695725">十：多线程</a></p><p><a href="https://blog.csdn.net/qq_35212671/article/details/52969068">多线程的优缺点</a></p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划浅学</title>
    <link href="/2023/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%85%E5%AD%A6/"/>
    <url>/2023/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%85%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>现在，你点进来可能是准备弄清楚啥是动态规划，，，好学的孩子呀，请问你想了解的是金规划还是银规划呀？</p><p>很抱歉，本文没有准备将动态规划给讲的透彻，但是如果能让你对动态规划有一些新的体会，那么，这扇门就可以关上了。。。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a><strong>引例</strong></h2><p>每当听到动态规划这个词的时候，总有一种抽象，排斥的想法，我们准备先不管TM的动态规划是个啥，家在哪，在哪工作？玩个游戏先，这个游戏叫<strong>爬楼梯</strong></p><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>邻居家的小孩总是爱爬楼梯，有一天你去邻居家做客，看见小朋友又在爬楼梯。你，伫立良久…</p><p>这时，阿姨给你洗了个水果，招呼你快坐，你拉着阿姨，深情地看着她，又指了指小朋友，问道：假如你家有$n$ 阶楼梯，才能到达二楼。每次小朋友可以爬 $1 $或 $2$ 个台阶。小朋友有多少种不同的方法可以爬到楼顶呢？</p><p>阿姨：…</p><p>你能帮阿姨解决这个问题吗？</p><p><strong>分析</strong></p><p>（1）位于一个阶梯时，小朋友都只有俩种选择，下一次爬一个或俩个台阶</p><p>（2）爬到终点即结束</p><p>（3）凡事不懂，画个图先</p><p>假如阿姨家有$20$阶楼梯，爬到第$20$层有$F(20)$种方法</p><p><img src="/../image/ds/climbstairs.png" alt="climbstairs"></p><h4 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>（1）递归遍历所有情况</p><p>（2）终止条件为完成了一次完整的爬行过程，计数为1次</p><p>（3）叠加所有情况的次数，得到总次数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">climbStairs(int n)&#123;<br>// 自顶向下<br>// 每次爬1阶或2阶，爬n阶楼梯，总共有多少种方法<br>// 输入：楼梯数n<br>// 输出：每次爬1阶或2阶，爬n阶楼梯，总共有多少种方法<br>// 递归终止条件,n==0时算一次有效爬行方法<br>  if(n &lt; 0) return 0;<br>  if(n==0) return 1;<br>  int allSteps = 0;<br>  allSteps += climbStairs(steps, n - 1) + climbStairs(steps, n - 2);<br>  return allSteps;<br>&#125;<br></code></pre></td></tr></table></figure><p>在递归的过程中，发现，每次递归总会递归到部分重复的子问题，并且重复的子问题的计算方式依然相同，那么这些重复的计算是否还有必要？可否，每次记录后保存下来，下次直接用？确认这个子问题的结果的状态一旦计算好之后，与后续的状态无关，可以作为直接用的量。</p><p><img src="/../image/ds/climbStairs2.png" alt="climbStairs2"></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairsDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jumps, <span class="hljs-type">int</span> n)</span> &#123;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>阿姨长舒一口气，“打完收工…”，</p><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>过了几年，你又被邀请去邻居家做客，注意，你不姓王，这个小朋友恰巧又在家，蹦蹦跳跳，真可爱，阿姨热情地看了看你，开始陷入回忆，那还是几年前了，</p><p>你开心的和小朋友玩了掐来，蹦蹦跳跳，真好玩，你问小朋友，一共有5阶台阶，每阶台阶有跳跃的阶数限制，你最初位于第一个阶梯。有这么一个非负整数数组 $nums$ ，数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。请问你最少跳几次？</p><p>阿姨闻声而来：….</p><p>请问你能帮小朋友解决这个问题吗？</p><p>输入: $nums &#x3D; [2,3,1,1,4]$<br>输出: $2$<br>解释: 跳到最后一个位置的最小跳跃数是 $2$。<br>从下标为$ 0 $跳到下标为$ 1$ 的位置，跳 $1$ 步，然后跳 $3$ 步到达数组的最后一个位置。</p><p>我们需要求到达第$5$个台阶的最小步数，令为$F(4)$</p><p><img src="/../image/ds/jumpGames.png" alt="jumpGames"></p><h4 id="暴力求解-1"><a href="#暴力求解-1" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>（1）递归遍历每个位置所有可能跳跃的情况</p><p>（2）终止条件：跳完收工</p><p>（3）求最少次数，那么<strong>到达当前台阶的最少次数</strong>一定是由<strong>跳到当前台阶的之前的那个台阶的最少次数+1</strong>，比如跳到$F(4)$的最少步数一定是由能跳到$F(4)$的台阶$F(1)$和$F(3)$俩者的最少步数决定，所以记个临时变量，求每一阶台阶的最少次数，算到最后，求最少次数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs txt">jumpGame(int[] nums, int start)&#123;<br>// 自底向上<br>// 使用最少的跳跃次数到达数组的最后一个位置<br>// 输入：nums：非负整数数组，数组中的每个元素代表你在该位置可以跳跃的最大长度；start:表示每次跳跃的起点，有效位从0开始<br>// 输出：到达最后一个位置的最少次数<br>// 递归终止条件,跳跃起点到达最后一个位置<br>  if(start &gt;= nums.length - 1) return 0;<br>  minSteps = Integer.MAX_VALUE;<br>  for (int i = 1; i &lt;= jumps[start]; i++) &#123;<br>   // 当前起跳的起点<br>    cur = start + i;<br>    steps = jumpGame(nums, cur) + 1;<br>    if (steps == -1) &#123;<br>      continue;<br>    &#125;<br>    minSteps = min(minSteps, steps);<br>  &#125;<br>  if (minSteps != Integer.MAX_VALUE) &#123;<br>    return minSteps;<br>  &#125;<br>return -1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可以优化吗？"><a href="#可以优化吗？" class="headerlink" title="可以优化吗？"></a>可以优化吗？</h4><p>分析：同样存在大量重复计算；是否可以避免重复运算？</p><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jumpGamesDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jumps)</span> &#123;<br><span class="hljs-comment">// 记录每一个位置到达终点的最小步数</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[jumps.length];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jumps.length; i++) &#123;<br>dp[i] = Integer.MAX_VALUE;<br>&#125;<br><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jumps.length; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= jumps[i]; j++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxPos</span> <span class="hljs-operator">=</span> i + j;<br><span class="hljs-keyword">if</span> (maxPos &gt;= jumps.length) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dp[maxPos] = Math.min(dp[maxPos], dp[i] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (dp[jumps.length - <span class="hljs-number">1</span>] == Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[jumps.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>小朋友跳了俩步，闯关成功，与此同时，阿姨也收工了，长呼一口气…</p><h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p>相较于暴力解法，动态规划通过记忆数组记录重复运算的数据状态。</p><p>那TM的是么是动态规划？</p><p>是阿姨的功夫还是小朋友的才智，注意你不姓王。。。</p><p><strong>wikipedia大哥是这么说的</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a href="https://en.wikipedia.org/wiki/Dynamic_programming">定义</a></h2><p><strong>Dynamic programming</strong> is both a <a href="https://en.wikipedia.org/wiki/Mathematical_optimization">mathematical optimization</a> method and a computer programming method. The method was developed by <a href="https://en.wikipedia.org/wiki/Richard_Bellman">Richard Bellman</a> in the 1950s and has found applications in numerous fields, from <a href="https://en.wikipedia.org/wiki/Aerospace_engineering">aerospace engineering</a> to <a href="https://en.wikipedia.org/wiki/Economics">economics</a>.</p><p>In both contexts <strong>it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a <a href="https://en.wikipedia.org/wiki/Recursion">recursive</a> manner</strong>. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively. Likewise, in computer science, if a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have optimal substructure.</p><p><a href="https://www.techiedelight.com/introduction-dynamic-programming/"><strong>你的邻居大哥是这么解释的：</strong></a></p><p><strong>Dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map, etc.).</strong> Each subproblem solution is indexed in some way, typically based on its input parameters’ values, to facilitate its lookup. So, the next time the same subproblem occurs, instead of recomputing its solution, one looks up the previously computed solution, thereby saving computation time. This technique of storing solutions to subproblems instead of recomputing them is called <code>memoization</code>.</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h2><p><strong>动态规划方法，是对一种具有重叠子问题的问题进行求解的技术《算法设计与分析基础》</strong>。将给定问题拆解为子问题，递归的去找到子问题的最优解来最优的解决问题，这也被称为最优子结构。每次将子问题的结果保存起来，可以称为记忆化，同时这也是动态规划的核心。</p><h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p><strong>如果给定问题可以拆解成多个子问题，且所有子问题都需要用同一种方式求解，那么它们就属于重叠子问题。</strong></p><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>**如果给定问题的最优解可以通过使用其子问题的最优解来获得，则给定问题具有最优子结构性质。 **</p><h4 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h4><p><strong>如果给定某一阶段的状态，这一阶段以后过程的发展，不受这阶段以前各段状态的影响，就称为无后效性，即：未来与过去无关。</strong></p><p>这几个特点保证了，通过数组形式记忆化记录下来各个子问题的状态结果可以复用，并且原问题可以由子问题的记忆结果计算得到。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>那么问题就来了，阿姨问了，动态规划和分治有啥区别吗？还有贪心呢？</p><p><strong>是时候表现自己了：</strong></p><p><strong>分治方法将问题划分为互不相交的子问题</strong>，递归的求解子问题，再将它们的解组合起来，求出原问题的解。</p><p>先举一个典型的分治思想的例子</p><p><strong><a href="http://t.zoukankan.com/l199616j-p-10604351.html">归并排序</a></strong></p><p>归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序。</p><p><img src="/../image/ds/mergeSort.gif" alt="mergeSort"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 归并排序中的思路<br>MergeSort(arr[], l,  r)<br>If r &gt; l<br>     1. 找到数组中的中间点，把数组分为两部分<br>             middle m = (l+r)/2<br>     2. 对数组的左部分调用MergeSort 函数  <br>             Call mergeSort(arr, l, m)<br>     3. 对数组的右部分调用MergeSort 函数 <br>             Call mergeSort(arr, m+1, r)<br>     4. 合并2,3中的两部分<br>             Call merge(arr, l, m, r)<br></code></pre></td></tr></table></figure><p>与之相反，<strong>动态规划应用于子问题重叠的情况</strong>，即不同的子问题具有公共的子子问题（子问题的解是递归进行的，将其划分为更小的子子问题），在这种情况下，分治算法会做很多不必要的工作，会反复的求解哪些公共子问题，而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算，避免了这种不必要的计算工作。《算法导论》</p><p>我们在求解最优化问题过程中，但动态规划也有缺点，每个步骤都面临很多选择，很多选择可能是没有必要的，<strong>贪心算法，在每一步都做出当前最佳选择，总是找到局部最优解，寄希望这样的选择可以导致全局最优。</strong></p><p>比如刚才小朋友玩的跳跃游戏,我们使用了数组去记录跳到每个台阶的最少步数，但实际上我们更关心跳到终点位置的最少步数，所以我们可以每次去记录每个位置能跳到的最远位置，如果到达终点了，那么游戏结束。</p><p><img src="/../image/ds/jump.png" alt="jump"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jumpGamesGa</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxPosition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">// 贪心：每次找能跳的最远的位置</span><br>maxPosition = Math.max(maxPosition, nums[i] + i);<br>     <span class="hljs-comment">// 由于求最少步数，所以只有当前位置到达上一轮能找到的跳的最远位置才更新步数</span><br><span class="hljs-keyword">if</span> (i == end) &#123; <span class="hljs-comment">//遇到边界，就更新边界，并且步数加一</span><br>end = maxPosition;<br>steps++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> steps;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结来说，动态规划和分治都是将大问题划分为小问题，小问题间独立是分治，小问题间有状态关系，并且需要用到之前状态是动态规划，不需要的是贪心法。</p><p><strong>情景小对话</strong></p><p>你：我已经知道了动态规划的精华了，是时候去拳打敬老院，脚踢幼儿园，新的一代小区霸主即将诞生</p><p>我：搞不赢的</p><p>你：搞得赢的</p><p>我：搞不赢的</p><p>你：我劝你</p><p><img src="/../image/ds/win.gif" alt="win"></p><h2 id="三个基本例子"><a href="#三个基本例子" class="headerlink" title="三个基本例子"></a>三个基本例子</h2><p>那么动态规划，到底难在哪里呢？私以为难在子问题的多样化和抽象化，</p><p>下文我们把每个子问题的计算结果称为状态，原问题与子问题的计算关系，称为状态与状态的关系。</p><p>（1）但对于可被记录子问题的状态数组来说，无非是用一维和N维来表示。</p><p>（2）对于当前状态可选择的选项来说，找出对其直接影响的状态</p><p>（3）对于可以使用动态规划问题，画图往往能清晰明了</p><h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><p>最近你在小区楼下开了个小卖店，今天阿姨领着小朋友来买棒棒糖，棒棒糖9块钱，阿姨掏出20块钱，恶狠狠的盯着你骂道：你TM棒棒糖金子做的呀？给我找最少的纸币，我只要1，2，5的纸币，其他的我不要。</p><p>我：你可以扫码嘛？</p><p>阿姨：扫码？扫码，扫码，。。。扫尼玛</p><p>打完收工…</p><p>但是生意还是要做的。。。接着找钱</p><p><strong>分析：</strong></p><p>（1）不管零钱多少，均需要拆解成对应面值的硬币，即可被找零的面值硬币固定</p><p>（2）每次被找零后，数值会减小，只有当零钱为0了才不需要被找零，除非你是个大善人，</p><p><img src="/../image/ds/coinChange.png" alt="coinChange"></p><p>考虑著名的找零问题的一般情形，需要找零金额为$n$,最少要用多少面值为$d_1&lt;d_2&lt;…&lt;d_m$的硬币。假设有$m$种面值为$d_1&lt;d_2&lt;…&lt;d_m$的硬币，$d_1&#x3D;1$，且每种面值的硬币数量无限可得。</p><h4 id="暴力求解-2"><a href="#暴力求解-2" class="headerlink" title="暴力求解"></a>暴力求解</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">coinChange(int[] coins, int amount)&#123;<br><span class="hljs-comment">// 自顶向下</span><br><span class="hljs-comment">// 使用最少的跳跃次数到达数组的最后一个位置</span><br><span class="hljs-comment">// 输入：coins：非负整数数组，可以被用来找零的零钱价值；amount:表示当前需要找零的金额</span><br><span class="hljs-comment">// 输出：找零需要的最少硬币数</span><br><span class="hljs-comment">// 递归终止条件,需要找零的金额为0，则结束，小于0，表示找不开，也结束找零方案</span><br>  <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 记录需要被找零的最少硬币数</span><br>  minChangeNum = Integer.MAX_VALUE;<br>  <span class="hljs-comment">// 在这里开始做选择</span><br>  <span class="hljs-keyword">for</span> (int coin : coins) &#123;<br>    changeNum = coinChange(coins, amount - coin);<br>    <span class="hljs-keyword">if</span> (changeNum == -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>minChangeNum = Math.min(minChangeNum, changeNum + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (minChangeNum != Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> minChangeNum;<br>&#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推关系</strong></p><p>$$\begin{cases}<br>F(n)&#x3D;min\left{ F(n-d_j)\right}+1&amp; \text{n&gt;0}\<br>F(0)&#x3D;0&amp; \text{n&#x3D;0}<br>\end{cases}$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ChangeMaking(D[<span class="hljs-number">1.</span>.m],n)<br><span class="hljs-comment">//应用动态规划算法求解找零问题，找出使硬币加起来等于n时所需的最少的硬币数目</span><br><span class="hljs-comment">//输入：正整数n，以及用于表示的币值的递增整数数组D[1..m]，D[1]=1</span><br><span class="hljs-comment">//输出：总金额等于n的硬币的最少的数目</span><br>F[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>  tmp = Math.min(F[i-D[j]],tmp)<br>  &#125;<br>F[i] = tmp+<span class="hljs-number">1</span>;<br>&#125;Í<br><span class="hljs-keyword">return</span> F[n];<br></code></pre></td></tr></table></figure><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doCoinChangeDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>dp[i] = Integer.MAX_VALUE;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br><span class="hljs-keyword">if</span> ((i - coin) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dp[i] = Math.min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (dp[n] == Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="币值最大化问题"><a href="#币值最大化问题" class="headerlink" title="币值最大化问题"></a>币值最大化问题</h3><p>小区最近来来一个小偷，你们小区只有一个入口，所以只能先从那家偷，但小区治安好，每俩家之间有一个警报器，如果相邻的俩家同时被偷了，那么警报器就会报警，小偷从小数学比较好，勘查地形后，又和邻居家的阿姨闲聊，套出了咱们小区每家每户室内的金币数额，回到家想着我该怎么偷才能在这和小区偷到最大化的价值的东西呢？</p><p><strong>分析</strong></p><p>（1）相邻金币不可同时获得</p><p>（2）要想币值最大化，相邻硬币必定要获得一个</p><p>考虑更一般的问题，给定一排$n$个硬币，其面值均为正整数，$c_1,c_2,..c_n$，这些整数并不一定俩俩不同，请问如何选择硬币，是的其在原始位置互不相邻的条件下，所选硬币的总金额最大。<strong>为方便形象化理解，这里<a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">参考</a>了的解释和图形。</strong></p><p><img src="/../image/ds/robbery1.jpg" alt="robbery1"></p><p><img src="/../image/ds/robbery2.jpg" alt="robbery2"></p><p><img src="/../image/ds/robbery3.jpg" alt="robbery3"></p><h4 id="暴力求解-3"><a href="#暴力求解-3" class="headerlink" title="暴力求解"></a>暴力求解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自底向上</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RobberySolution</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRobberyMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values)</span> &#123;<br><span class="hljs-keyword">return</span> robberyMoney(values, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span> start)</span> &#123;<br><span class="hljs-keyword">if</span> (start &gt;= values.length) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 在这里开始做选择</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Math.max(values[start] + robberyMoney(values, start + <span class="hljs-number">2</span>), robberyMoney(values, start + <span class="hljs-number">1</span>));<br>maxValue += value;<br><span class="hljs-keyword">return</span> maxValue;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/ds/robbery4.jpg" alt="robbery4"></p><p><strong>递推关系</strong></p><p>$F(n)&#x3D;max { F(n-2)+c_n, F(n-1) }$</p><p>$F(0) &#x3D; 0, F(1) &#x3D; c_1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CoinRow(C[<span class="hljs-number">1.</span>.n])<br><span class="hljs-comment">//自底向上：求最大金额</span><br><span class="hljs-comment">//在满足所选硬币不相邻的条件下，从一排硬币中选择最大金额的硬币</span><br><span class="hljs-comment">//输入：数组C[1..n]保存n个硬币的面值</span><br><span class="hljs-comment">//输出：可选硬币的最大金额</span><br>F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>F[<span class="hljs-number">1</span>] = C[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>F[i] = Math.max(C[i]+F[i-<span class="hljs-number">2</span>], F[i-<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span> F[n]<br></code></pre></td></tr></table></figure><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoneyDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>dp[i] = Integer.MIN_VALUE;<br>&#125;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>&#125;<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>dp[i] = Math.max(nums[i] + dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">return</span> Math.max(dp[n - <span class="hljs-number">1</span>], dp[n - <span class="hljs-number">2</span>]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../image/ds/robbery5.gif" alt="robbery5"></p><h4 id="空间优化版本"><a href="#空间优化版本" class="headerlink" title="空间优化版本"></a>空间优化版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoneyDp2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pprev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 每次循环，计算“偷到当前房子为止的最大金额”</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br><span class="hljs-comment">// 循环开始时，prev 表示 dp[k-1]，pprev 表示 dp[k-2]</span><br><span class="hljs-comment">// dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> Math.max(prev, pprev + i);<br>pprev = prev;<br>prev = curr;<br><span class="hljs-comment">// 循环结束时，prev 表示 dp[k]，pprev 表示 dp[k-1]</span><br>&#125;<br><br><span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="硬币收集问题"><a href="#硬币收集问题" class="headerlink" title="硬币收集问题"></a>硬币收集问题</h3><p>疫情防控期间，你们楼被要求隔离，在家无聊的很，你邀请邻居家的小朋友来家里面玩游戏，这个游戏呢能赚钱，你在$n\times m$格木板种放有一些硬币，每格的硬币数目最多为一个，小朋友在木板左上方需要收集尽可能多的硬币可能多的硬币并把它们带到右下方的单元格。每一步，小朋友可以从当前的位置向右移动一格或向下移动一格。当小朋友遇到一个有硬币的单元格时，就会将这枚硬币收集起来。设计一个算法找出机器人能找到的最大硬币数。</p><h4 id="暴力求解-4"><a href="#暴力求解-4" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>怎么解？你来想想？</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m], <span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span> &gt;= m &amp;&amp; <span class="hljs-built_in">col</span> == n)&#123;<br><span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">return</span> <span class="hljs-built_in">max</span>(RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m],<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">col</span>),RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m],<span class="hljs-built_in">row</span>,<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>)) + C[<span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>];<br></code></pre></td></tr></table></figure><h4 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h4><p>怎么做？你来想想？</p><p><strong>递推关系</strong></p><p>$$\begin{cases}<br>F(i,j)&#x3D;max\left{ F(i-1,j),F(i,j-1)\right}+c_{ij}&amp; \text{1&lt;&#x3D;i&lt;&#x3D;n,1&lt;&#x3D;j&lt;&#x3D;m}\<br>F(0,j)&#x3D;0,1&lt;&#x3D;j&lt;&#x3D;m,F(i,0)&#x3D;0&amp;\text{1&lt;&#x3D;i&lt;&#x3D;m}<br>\end{cases}$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">RobotCoinCollection(C[<span class="hljs-number">1.</span>.n,<span class="hljs-number">1.</span>.m])<br><span class="hljs-comment">//利用动态规划算法计算机器人在n*m木板上所能收集的最大硬币数</span><br><span class="hljs-comment">//机器人从(1,1)出发，每次向右或向下移动，从左上方移动到右下方</span><br><span class="hljs-comment">//输入：矩阵C[1..n,1..m],矩阵元素为1或0分别表示单元格中有一枚硬币或没有</span><br><span class="hljs-comment">//输出：机器人在单元格（n,m）中收集到的最大硬币数</span><br>F[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]=C[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j &lt;= m; j++)&#123;<br>F[<span class="hljs-number">1</span>,j] = F[<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>]+C[i,j];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>F[i,<span class="hljs-number">1</span>] = F[i-<span class="hljs-number">1</span>]+C[i,<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>; j &lt;= m; j++)&#123;<br>F[i,j] = max&#123;F[i-<span class="hljs-number">1</span>,j], F[i,j-<span class="hljs-number">1</span>]&#125;+C[i,j]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> F[n,m]<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 $0$ 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TXT">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。<br></code></pre></td></tr></table></figure><p><img src="/../image/ds/lcs.png" alt="lcs"></p><h4 id="暴力求解-5"><a href="#暴力求解-5" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>假设$ m&lt;n$， 对于text1，我们可以暴力找出$2^m$次方个子序列，然后依次在text2中匹配，算法的时间复杂度会达到指数级$O(n*2^m)$。显然，暴力求解不太适用于此类问题。</p><h4 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> text1.charAt(i - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> text2.charAt(j - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：每次计算新的一行的时候, 用到的都是上一行或者本行之前算过的数据, 所以可以优化到一维数组. 如下图:</p><p><img src="/../image/ds/lcs1.png" alt="lcs1"></p><p>比如计算$dp[3][2]$的时候, 用到的可能有他的左上角, 正上方, 和左侧数据. 左侧数据是在同一行, 上方数据还未被覆盖,还是上一行的老数据, 所以都可以直接用, 这里唯一注意就是左上方的数据, 因为在计算前一列的时候会被覆盖, 需要在被覆盖之前保存下旧值,因此二维的状态数组可以被优化为一维数组。</p><p><strong>二维DP优化一维DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence_1</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>dp[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">upLeft</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> text1.charAt(i - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> dp[j];<br><span class="hljs-type">int</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> text2.charAt(j - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>dp[j] = upLeft + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[j] = Math.max(dp[j - <span class="hljs-number">1</span>], dp[j]);<br>&#125;<br>upLeft = tmp;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题和记忆功能"><a href="#背包问题和记忆功能" class="headerlink" title="背包问题和记忆功能"></a>背包问题和记忆功能</h2><p>动态规划法建议，与其对交叠的子问题一次又一次地求解，还不如对每个较小的子问题只解一次并把结果记录在表中，这样从表中就可以得出原始问题的解。</p><p>记忆功能技术试图把自顶向下和自底向上的优势结合起来，对具有重叠子问题的问题求解。它用自顶向下的方式，<strong>对给定问题的必要子问题只作一次求解，并把结果记录在表中。</strong></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>给定$n$个重量为$w_1,w_n$,价值为$v_1,..v_n$的物品和一个承重量为$W$的背包，求这些物品中最有价值的一个子集，并且要能够装到背包中。</p><p>让我们来考虑一个由前$i$个物品$(1&lt;&#x3D;i&lt;&#x3D;n)$定义的实例，物品重量为$w_1,w_i$,价值为$v_1,..v_i$的物品</p><p>$F(i,j)$为该实例的最优解的物品的总价值，即，能够放进承重量为$j$的背包中的前$i$个物品中最有价值子集的总价值</p><p><img src="/../image/ds/beibao.png" alt="beibao"></p><p>（1）根据定义，在不包括第$i$个物品的子集中，最优子集的价值是$F(i-1,j)$</p><p>（2）在包括第$i$个物品的子集中（因此，$j-w_i&gt;&#x3D;0$）,最优子集是由该物品和前$i-1$个物品中能够放进承重量为$j-w_i$的背包的最优子集组成，这种最优子集的总价值等于$v_i+F(i-1,j-w_i)$</p><p>因此<br>$$<br>F(i,j)&#x3D;\begin{cases}max\left{ F(i-1,j),F(i-1,j-w_i)\right}, j-w_i&gt;&#x3D;0 \<br>F(i-1,j), j-w_i&lt;0<br>\end{cases}<br>$$<br>当$j&gt;&#x3D;0$时，$F(0,j) &#x3D; 0$</p><p>当$i&gt;&#x3D;0$时，$F(i,0) &#x3D; 0$</p><p>我们需要求的是$F(n,W)$</p><h3 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h3><p>动态规划涉及问题的解，满足一个用交叠子问题表示的递推关系，直接自顶向下对这样一个递推式求解导致一个算法要不止一次地解公共子问题，因此，效率非常低，一般来说时指数级，甚至更差；另一方面，经典的动态规划方法时自底向上工作的：它用所有较小子问题的解填充表格，但是每个子问题的解只解一次。</p><p>这种方法无法令人满意的一面是，在求解给定问题时，有些较小的子问题的解常常不是必需的。</p><p>由于这个缺点没有在自顶向下法中表现出来，所以自然而然的希望把自顶向下和自底向上的优势结合起来；</p><p>目标是得到这么一种方法，它只对必要的子问题求解，并且只解一次，这种方法存在，以<strong>记忆化功能</strong>为基础</p><p>该方法用自顶向下的方式对给定问题求解，但还需要维护一个类似自底向上动态规划使用的表格，一开始的时候，用“nu l l”初始化表中所有单元格，用来表示未被计算过，之后一旦需要计算一个新值，先检查是否被计算过，不为null则直接取值，否则递归调用进行计算，然后把返回的结构记录在表中。</p><p><img src="/../image/ds/beibao1.png" alt="beibao1"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">MFKnapsack(i,j)<br>//对背包问题实现记忆功能方法<br>//输入：一个非负整数i表示先考虑的物品数量，一个非负整数j表示背包的承重量<br>//输出：前i个物品的最优可行子集的价值<br>//注意：我们把输入数组Weights[1..n],Values[1..n]和表格F[0..n,0,,W]作为全局变量<br>//除了行0和列0用0初始化外，F的所有单元格都用-1初始化<br>if F[i,j] &lt; 0<br>if j &lt; Weights[i]<br>value = MFKnapsack(i-1,j)<br>else<br>  value = max(MFKnapsack(i-1,j),Values[i]+MFKnapsack(i-1,j-Weights[i]))<br>  F[i,j] = value<br>return F[i,j]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计基础与分析</title>
    <link href="/2023/10/24/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/24/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>一系列解决问题的明确指令，对于符合一定规范的输入，能够在有限的时间内获得要求的输出。</p><p>例子：最大公约数：俩个不全为0 的非负整数$m$和$n$的最大公约数记为$gcd(m,n)$​,代表能够整除（即余数为0）$m$ 和$n$的最大正整数。</p><p><strong>欧几里得算法</strong></p><p>$gcd(m,n)&#x3D;gcd(n, m \ mod \ n)(m \ mod \ n 表示m除以n 之后的余数)$​​​</p><p>$until\ m \ mod\ n &#x3D; 0$​​ 其中 $gcd(m, 0) &#x3D; m$</p><p><strong>证明</strong>：$m$​ , $n$​, 其中 $m &gt; n$​​</p><p>则 $m &#x3D; n*k+r \ , \ r &#x3D; m \ mod \ n, k是整数$​​​​​</p><p>假设存在$u$​​.使得$m &#x3D; s<em>u, n &#x3D; t</em>u$​​ , $u$​​ 为$m$​​,$n$​​的约数</p><p>则$r &#x3D; s<em>u - k</em>(t<em>u) &#x3D; (s-k</em>t)*u$​，</p><p> <strong>$m$​ 和 $n$​ 的约数也整除它们的余数$r$​​​</strong></p><p>所以$m$​ 和 $n$​  的任一约数同时也是$n$​和$r$​​ 的约数</p><p>反之，$n$和$r$ 的任一约数也是$m$ 和 $n$​​​  的约数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Euclid(m,n)</span><br><span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>  r = m / n;<br>  m = n;<br>  n = r;<br>&#125;<br><span class="hljs-keyword">return</span> m;<br></code></pre></td></tr></table></figure><p><strong>连续值检测算法</strong></p><p>选取俩者的最小值，向下连续检测数值</p><p>局限：当$m$, $n$​中输入为0时，结果是错误的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">t = min(m, n);<br><span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span>）&#123;<br> <span class="hljs-keyword">if</span>(m % t == <span class="hljs-number">0</span> &amp;&amp; n % t == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> t;<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>    t--;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>质因数相乘法</strong></p><p>找出俩者公共的质因数，相乘得到结果</p><p>总结：对比三种计算最大公约数的方法，连续值检测法未能清晰规定算法输入的值域，当输入为0时，计算结果出错；质因数相乘法，对于如果计算质因数未能明确给定计算步骤。算法，应当清晰定义输入输出的值域，清晰定义计算的步骤。</p><p>例子：用来阐述一个不大于给定整数$n$的连续质数序列</p><p><strong>埃拉托色尼筛选法</strong></p><ol><li>初始化 $2$ ​~$n$​​ 的连续整数序列作为候选质数</li><li>第一次循环，消去$2$​的倍数（不包括2）</li><li>第二次循环，消去$3$的倍数（不包括3）</li><li>第三次循环，消去$5$的倍数（不包括5），4之前已经被消去了</li><li>…$until \ n$​</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Sievea(n)</span><br><span class="hljs-comment"> * 连续质数序列产生算法</span><br><span class="hljs-comment"> * Input:正整数n&gt;1</span><br><span class="hljs-comment"> * Output:包含所有小于等于n的质数的数组L</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">Sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt;= n; ++p)&#123;<br>A[p] = p;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt;= Math.sqrt(n); ++p)&#123;<br><span class="hljs-keyword">if</span>(A[p] != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> p * p;<br><span class="hljs-keyword">while</span>(j &lt;= n)&#123;<br>A[j] = <span class="hljs-number">0</span>;<br>j += p;<br>&#125;<br>&#125;<br>&#125;<br>List&lt;Integer&gt; L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt; n+<span class="hljs-number">1</span>; ++p)&#123;<br><span class="hljs-keyword">if</span>(A[p] != <span class="hljs-number">0</span>)&#123;<br>L.add(A[p]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们正在消去p的倍数，第一个值得考虑的是$p*p$ ，因其他更小的倍数$2p, \cdots ,(p-1)<em>p$已经在之前的步骤中从序列中消去了，所以$p</em>p &lt;&#x3D; n$， 因此$p &lt;&#x3D; sqrt(n)$​​</p><h2 id="算法问题求解基础"><a href="#算法问题求解基础" class="headerlink" title="算法问题求解基础"></a>算法问题求解基础</h2><p>算法是问题程序化解决方案</p><ol><li><p>理解问题：输入输出范围、特殊情况考虑（边界条件等）</p></li><li><p>确定：</p><p>（1）计算方法（了解设备性能，并行&#x2F;串行）</p><p>（2）精确或近似解法</p><p>（3）算法设计技术</p></li><li><p>设计算法：确定合适的数据结构，伪代码描述，流程图</p></li><li><p>正确性证明</p></li><li><p>分析算法：简单（易读，易懂），一般（问题的一般性，接受输入的一般性），时间、空间</p></li><li><p>根据算法写代码</p></li></ol><h1 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h1><h3 id="效率分析框架"><a href="#效率分析框架" class="headerlink" title="效率分析框架"></a>效率分析框架</h3><ol><li>算法的时间效率和空间效率都用输入规模的函数进行度量</li><li>算法基本操作的执行次数来度量算法的时间效率；通过计算算法消耗的额外存储单元的数量来度量空间效率</li><li>输入规模相同的情况下，部分算法的效率会有显著差异，需要区分最差效率，平均效率，最优效率</li><li>当算法的输入规模趋向于无限大时，它的运行时间（消耗的额外空间）函数的增长次数</li></ol><h3 id="渐近符号和基本效率类型"><a href="#渐近符号和基本效率类型" class="headerlink" title="渐近符号和基本效率类型"></a>渐近符号和基本效率类型</h3><p>效率分析框架主要关心一个算法的基本操作次数的增长次数，并把它作为算法效率的主要指标，主要用三种渐进符号表示</p><ol><li>$O(g(n))$:增长次数小于等于$g(n)$​(及其常数倍，$n$​趋向于无穷大)的函数集合</li><li>$\Omega(n)$:代表增长次数大于等于$g(n)$(及其常数倍，$n$趋向于无穷大)的函数集合</li><li>$\Theta(n)$：增长次数等于$g(n)$(及其常数倍，$n$趋向于无穷大)的函数集合</li></ol><p>利用极限比较增长次数</p><p>基本的效率类型</p><table><thead><tr><th>类型</th><th>名称</th><th align="left">注释</th></tr></thead><tbody><tr><td>$1$</td><td>常量</td><td align="left">为数很少的效率最高的算法，很难举出几个合适的例子，因为典型情况下，当输入的规模变得无穷大时，算法的运行时间也会趋向于无穷大</td></tr><tr><td>$log \ n$​</td><td>对数</td><td align="left">一般来说，算法的每一次循环都消去问题规模的一个常数因子，注意，一个对数算法不可能关注它的输入的每一个部分（哪怕是输入的一个固定部分）：对任何能做到这一点的算法最起码拥有线性运行时间</td></tr><tr><td>$n$</td><td>线性</td><td align="left">扫描规模为$n$的列表（顺序查找）的算法属于这个类型</td></tr><tr><td>$n \ log \ n$​</td><td>线性对数</td><td align="left">许多分治算法，包括合并排序和快速排序的平均效率，都属于这个类型</td></tr><tr><td>$n^2$</td><td>平方</td><td align="left">一般来说，这是包含两重嵌套循环的算法的典型效率。线性代数中一些著名的算法属于这一类型</td></tr><tr><td>$n^3$</td><td>立方</td><td align="left">一般来说，这是包含三重嵌套循环的算法的典型效率。线性代数中一些著名的算法属于这一类型</td></tr><tr><td>$2^n$</td><td>指数</td><td align="left">求$n$个元素集合的所有子集是这种类型的典型例子，“指数”这个术语常常被用在一个更广的层面上，不仅包括这种类型，还包括那些增长速度更快的类型</td></tr><tr><td>$n!$</td><td>阶乘</td><td align="left">求$n$个元素集合的完全排列的算法是这种类型的典型例子</td></tr></tbody></table><h3 id="非递归算法的数学分析"><a href="#非递归算法的数学分析" class="headerlink" title="非递归算法的数学分析"></a>非递归算法的数学分析</h3><p>例1：从$n$​个元素的列表中查找元素最大值的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">MaxElement(A[<span class="hljs-number">0.</span>..n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 求给定数组中的最大元素的值</span><br><span class="hljs-comment">// 输入：实数数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：A中最大元素的值</span><br>maxVal = A[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>  <span class="hljs-keyword">if</span>(A[i] &gt; maxVal)&#123;<br>    maxVal = A[i];<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxVal;<br></code></pre></td></tr></table></figure><h4 id="分析非递归算法时间效率的通用方案"><a href="#分析非递归算法时间效率的通用方案" class="headerlink" title="分析非递归算法时间效率的通用方案"></a>分析非递归算法时间效率的通用方案</h4><ol><li>决定用哪个（哪些）参数表示输入规模</li><li>找出算法的基本操作（作为一个规律，总是位于算法的最内层循环）</li><li>检查基本操作的执行次数是否之依赖于输入规模，如果还依赖于一些其他的特性，则最差效率，平均效率以及最优效率（如有必要）需要分析研究。</li><li>建立一个算法的基本操作执行次数的求和表达式</li><li>利用求和运算的标准共识和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数</li></ol><p>例2: 元素唯一性问题，验证给定数组的$n$个元素是否全部唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">UniqueElements(A[<span class="hljs-number">0</span>,,n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">//验证给定数组中的元素是否全部唯一</span><br><span class="hljs-comment">//输入：数组A[0,,n-1]</span><br><span class="hljs-comment">//输出：如果A中的元素全部唯一，返回true</span><br><span class="hljs-comment">//     否则，返回false</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n-<span class="hljs-number">1</span>; j++)&#123;<br>    <span class="hljs-keyword">if</span>(A[i] == A[j])&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>例3:矩阵乘积计算问题 $C&#x3D;AB$​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MatrixMultiplication(A[0..n-1,0..n-1],B[0..n-1,0..n-1])</span><br><span class="hljs-comment">// 用基于定义的算法计算俩个n阶矩阵的乘积</span><br><span class="hljs-comment">// 输入：两个n阶矩阵A，B</span><br><span class="hljs-comment">// 输出：矩阵C=ABx</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>C[i,j]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++)&#123;<br>C[i,j] = C[i,j]+A[i,k]+B[k,j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> C;<br></code></pre></td></tr></table></figure><p>例4: 十进制正整数在二进制表示中的数字个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Binary(n)</span><br><span class="hljs-comment">// 输入：十进制正整数n</span><br><span class="hljs-comment">// 输出：n在二进制表示中的二进制数字个数</span><br>count = <span class="hljs-number">1</span>；<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">1</span>)&#123;<br>count += <span class="hljs-number">1</span>;<br>n = Math.floor(n/<span class="hljs-number">2</span>);<span class="hljs-comment">//向下取整</span><br>&#125;<br><span class="hljs-keyword">return</span> count;<br></code></pre></td></tr></table></figure><h3 id="递归算法的数学分析"><a href="#递归算法的数学分析" class="headerlink" title="递归算法的数学分析"></a>递归算法的数学分析</h3><p>例1:计算 $n!$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// F(n) = n!</span><br><span class="hljs-comment">// 递归计算n!</span><br><span class="hljs-comment">// 输入：非负整数n</span><br><span class="hljs-comment">// 输出：n!的值</span><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">return</span> F(n-<span class="hljs-number">1</span>)*n;<br>&#125;<br></code></pre></td></tr></table></figure><p>当$n &gt; 0$, $F(n)&#x3D;F(n-1)+1$</p><p>$M(n)$表示乘法的执行次数，则$M(n) &#x3D; M(n-1)+1$</p><p>$M(0) &#x3D; 0$</p><p>$M(n)&#x3D;M(n-1)+1&#x3D;…&#x3D;M(n-i)+i&#x3D;…&#x3D;M(n-n)+n&#x3D;n$</p><h4 id="分析递归算法时间效率的通用方案"><a href="#分析递归算法时间效率的通用方案" class="headerlink" title="分析递归算法时间效率的通用方案"></a>分析递归算法时间效率的通用方案</h4><ol><li>决定用哪个（哪些）参数作为输入规模的度量标准</li><li>找出算法的基本操作</li><li>检查一下，对于相同规模的不同输入，基本操作的执行次数是否可能不同。如果有这个可能，则必须对最差效率，平均效率以及最优效率做单独研究</li><li>对于算法基本操作的执行次数，建立一个递推关系以及相应的初始条件</li><li>解这个递推式，或者至少确定它的解的增长次数</li></ol><p>例2: 汉诺塔游戏</p><p>$M(n)&#x3D;M(n-1)+1+M(n-1)&#x3D;2M(n-1)+1$</p><p>$M(1)&#x3D;1$</p><p>$M(n)&#x3D;2[2M(n-2)+1]+1&#x3D;2^2M(n-2)+1$​</p><p>…</p><p>$M(n)&#x3D;2^{n-1}M(n-(n-1))+2^{n-1}+1$</p><p>$M(n)&#x3D;2^n-1$</p><h3 id="计算斐波那契数列讨论"><a href="#计算斐波那契数列讨论" class="headerlink" title="计算斐波那契数列讨论"></a>计算斐波那契数列讨论</h3><p>$F(n)&#x3D;F(n-1)+F(n-2)$</p><p>$F(0)&#x3D;0,F(1)&#x3D;1$</p><h3 id="算法的经验分析"><a href="#算法的经验分析" class="headerlink" title="算法的经验分析"></a>算法的经验分析</h3><h4 id="对算法效率做经验分析的通用方案"><a href="#对算法效率做经验分析的通用方案" class="headerlink" title="对算法效率做经验分析的通用方案"></a>对算法效率做经验分析的通用方案</h4><ol><li>了解实验的目的</li><li>决定用来度量效率的度量标准M和度量单位（用操作次数还是直接用时间）</li><li>决定输入样本的特性（它的范围和大小等）</li><li>为实验准备算法（或若干算法）的程序实现</li><li>生成输入样本</li><li>对输入样本运行算法（或若干算法），并记录观察到的实验数据</li><li>分析获得的实验数据</li></ol><h1 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h1><h2 id="选择排序和冒泡排序"><a href="#选择排序和冒泡排序" class="headerlink" title="选择排序和冒泡排序"></a>选择排序和冒泡排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择出当前元素应该放置的元素（升序排列，找出当前轮次的最小元素），依次循环</p><p>$\Theta(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">SelectionSort(A[<span class="hljs-number">0</span>],,A[n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法用选择排序对给定的数组排序</span><br><span class="hljs-comment">// 输入：一个可排序的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：升序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; ++i)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">minPos</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br><span class="hljs-keyword">if</span>(A[minPos] &gt; A[j])&#123;<br>minPos = j;<br>&#125;<br>swap(A[i], A[minPos]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>比较相邻元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">BubbleSort(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法用冒泡排序对数组A[0.n-1]进行排序</span><br><span class="hljs-comment">// 输入：一个可排序数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; ++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n-<span class="hljs-number">1</span>-i; ++j)&#123;<br><span class="hljs-keyword">if</span>(A[j] &gt; A[j+<span class="hljs-number">1</span>])&#123;<br>swap(A[j], A[j+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="顺序查找和蛮力字符串匹配"><a href="#顺序查找和蛮力字符串匹配" class="headerlink" title="顺序查找和蛮力字符串匹配"></a>顺序查找和蛮力字符串匹配</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">SequentialSearch(A[<span class="hljs-number">0.</span>.n],K)<br><span class="hljs-comment">// 顺序查找的算法实现。它用了查找键来作限位器</span><br><span class="hljs-comment">// 输入：一个n个元素的数组A和一个查找键K</span><br><span class="hljs-comment">// 输出：第一个值等于K的元素的位置，如果找不到这样的元素，返回-1</span><br>A[n] = K；<br>i = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">while</span>(A[i] != K)&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(i &lt; n)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果查找序列是有序的话，可以查找到或者大于查找键后直接返回</p><h3 id="蛮力字符串匹配"><a href="#蛮力字符串匹配" class="headerlink" title="蛮力字符串匹配"></a>蛮力字符串匹配</h3><p>给定一个$n$​个字符串组成的串[称为文本(text)],一个$m(m&lt;&#x3D;n)$个字符的串[称为模式(pattern)]，从文本中寻找匹配模式的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">BrureForeStringMatch(T[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>],P[<span class="hljs-number">0.</span>.m-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法实现了蛮力字符串匹配</span><br><span class="hljs-comment">// 输入：一个n个字符的数组T[0..n-1],代表一段文本</span><br><span class="hljs-comment">// 一个m个字符的数组P[0..m-1],代表一个模式</span><br><span class="hljs-comment">// 输出：如果查找成功，返回文本的第一个匹配子串中第一个字符的位置，否则返回-1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-m+<span class="hljs-number">1</span>; )&#123;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; P[j] = T[i+j])&#123;<br>j++;<br><span class="hljs-keyword">if</span>(j == m)&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>最坏情况 $O(nm)$​​</p><h2 id="最近对和凸包问题的蛮力算法"><a href="#最近对和凸包问题的蛮力算法" class="headerlink" title="最近对和凸包问题的蛮力算法"></a>最近对和凸包问题的蛮力算法</h2><h3 id="最近对问题"><a href="#最近对问题" class="headerlink" title="最近对问题"></a>最近对问题</h3><p>最近点对问题要求在一个包含$n$个点的集合中，找出距离最近的俩个点。</p><p>一个重要的应用是统计学中的聚类分析。对于$n$个数据点的集合，层次聚类分析希望基于某种相似度度量标准将数据点构成的簇按照层次关系组织起来。</p><p>（1）对于<strong>数值型数据</strong>，相似度度量标准的通常采用<strong>欧几里得距离</strong>；</p><p>（2）对于<strong>文本和其他非数值型数据</strong>，通常采用诸如<strong>汉明距离</strong>这样的相似度度量标准。</p><p>$d(p_i,p_j)&#x3D;\sqrt {(x_i-x_j)^2+(y_i-y_j)^2}$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">BruteForceClosestPoints(p)<br><span class="hljs-comment">// 使用蛮力法求平面中距离最近的俩点</span><br><span class="hljs-comment">// 输入：一个n（n&gt;=2)个点的列表p,p1=(x1,y1)...pn=(xn,yn)</span><br><span class="hljs-comment">// 输出：俩个最近点的距离</span><br>$d = \infin$<br><span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)</span>&#123;<br><span class="hljs-keyword">for</span>(j = i+<span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; ++j)&#123;<br>d = min(d, sqrt((xi-xj)^<span class="hljs-number">2</span>+(yi-yj)^<span class="hljs-number">2</span>));<span class="hljs-comment">//sqrt是平方根函数</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d;<br></code></pre></td></tr></table></figure><p>基本操作是计算平方根，其实可以转而比较平方本身，而避免平方根计算，算法的基本操作转为求平方，加快内层循环的速度。</p><h3 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h3><p>凸集合：对于平面上的一个点集合（有限的&#x2F;无限的），如果以集合中的任意俩点$p$,$q$为端点的线段都属于该集合，我们说这个集合是凸的。</p><p>凸包概念：对于平面上$n$个点的集合，它的凸包就是包含所有这些点（或者在内部，或者在边界上）的最小的凸多边形。</p><p>凸包：一个点集合$S$的凸包是包含$S$的最小凸集合，（“最小”意指$S$ 的凸包一定是所有包含$S$ 的凸集合的子集）。</p><p>定理：任意包含$n&gt;2$个点（不共线的点）的集合S的凸包是以S中的某些点为顶点的凸多边形（如果所有的点都位于一条直线上），多边形退化为一条线段，但它的俩个端点仍然包含在S中。</p><p>凸集合中的<strong>极点</strong>：对于任何以集合中的点为端点的线段来说，它不是这种线段的中点。</p><p>单纯形法用于解决现行规划问题，找到极点也就解出了凸包问题。</p><p>对于一个$n$个点集合中的俩个点$p_i,p_j$​​​,当且仅当该集合中的其他点都位于穿过这俩点的直线的同一边时，他们的连线是该集合凸包边界的一部分。<strong>对每一对点都做一遍检验之后，满足条件的线段构成了凸包的边界。</strong></p><p>在坐标平面上穿过俩个点$(x_1,y_1),(x_2,y_2)$的直线有下列方程定义：</p><p>$ax+by&#x3D;c$​</p><p>其中</p><p>$a&#x3D;y_2-y_1$</p><p>$b &#x3D; x_1-x_2$</p><p>$c&#x3D;x_1y_2-y_1x_2$</p><p>这样直线可以将平面划分为俩个半平面，其中一个半平面的点都满足$ax+by&gt;c$</p><p>另一个半平面中的点$ax+by&lt;c$（直线上的点满足$ax+by&#x3D;c$）。</p><p>为检验某些点事都位于直线的同一边，只需把每个点带入$ax+by-c$,检验这个表达式的符号是否相同。</p><h2 id="穷举查找"><a href="#穷举查找" class="headerlink" title="穷举查找"></a>穷举查找</h2><h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>(Traveling salesman problem, TSP), 要求找出一条$n$ 个给定城市间的最短路径，使我们在回到出发的城市之前，对每个城市都只访问一次。</p><p>该问题可以表述为求一个图的最短哈密顿回路。</p><p>哈密顿回路：一个对图的每一个顶点都只穿越一次的回路。</p><p>可以假设，所有的回路都开始和结束于相同的特定顶点。可以通过生成$n-1$个中间城市的组合来得到所有的旅行线路，计算这些线路的长度，然后求得最短的线路。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>给定$n$个重量为$w_1,w_2,…w_n$，价值为$v_1,v_2,…v_n$的物品和一个承重为$W$的背包，求这些物品中一个最有价值的子集，并且能够装到背包中。</p><p>穷举查找需要考虑给定的$n$个物品集合的所有子集，为了找出可行的子集（也就是说，总重量不超过背包承重能力的子集），要计算出每个子集的总重量，然后找出它们中间价值最大的子集。</p><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><p>有$n$个任务需要分配给$n$个人执行，一个任务对应一个人（每个任务只分配给一个人，每个人只分配一个任务），对于每一对$i,j&#x3D;1,2,…,n$来说，将第$j$个任务分配给第$i$个人的成本是$C[i,j]$。该问题是要找出总成本最小的分配方案。</p><p>一般情况下，需要考虑的排列数量是$n!$，对于该问题有一个效率高效得多的算法是<strong>匈牙利算法</strong>。</p><h2 id="深度优先查找和广度优先查找"><a href="#深度优先查找和广度优先查找" class="headerlink" title="深度优先查找和广度优先查找"></a>深度优先查找和广度优先查找</h2><h3 id="深度优先查找"><a href="#深度优先查找" class="headerlink" title="深度优先查找"></a>深度优先查找</h3><p>可以从任意顶点开始访问图的顶点，然后把该顶点标记为已访问。在每次迭代的时候，该算法紧接着处理与当前顶点邻接的未访问顶点。（如果有若干个这样的顶点，可以任意选择一个顶点，选择哪一个邻接的未访问的候选顶点主要是由表示图的数据结构决定的）。过程持续直到遇到一个终点，该顶点的所有邻接点都已被访问过，在后退到起始顶点。如果未访问的顶点仍然存在，该算法必须从其中一顶点开始，重复上述过程。</p><p>用栈跟踪深度优先查找的操作是比较方便的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">DFS(G)<br><span class="hljs-comment">//  实现给定图的深度优先查找遍历</span><br><span class="hljs-comment">// 输入：图G=（V，E）</span><br><span class="hljs-comment">// 输出：图G的顶点，按照DFS遍历第一次访问到的先后次序，用连续的整数标记将V</span><br><span class="hljs-comment">//      中的每个顶点标记为0，表示“未访问”</span><br>count = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">for</span>(Vertex v: V)&#123;<br><span class="hljs-keyword">if</span>(v.markedCount == <span class="hljs-number">0</span>)&#123;<br>    dfs(v);<br>  &#125;<br>&#125;<br>dfs(v);<br><span class="hljs-comment">// 递归访问所有和v相接的未被访问的顶点，然后按照全局变量count的值</span><br><span class="hljs-comment">// 根据遇到他们的先后顺序，给他们赋值相应的数字</span><br>count++;<br><span class="hljs-comment">// 标记v访问</span><br>v.markedCount = count;<br><span class="hljs-keyword">for</span>(Vertex w : V)&#123;<br>  <span class="hljs-comment">// w是v的邻接点并且未被访问过</span><br>  <span class="hljs-keyword">if</span>(w.adjacent(v) &amp;&amp; w.markedCount == <span class="hljs-number">0</span>)&#123;<br>dfs(w);    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS产生俩种节点的排列顺序，第一次访问顶点（入栈）的次序和顶点称为终点（出栈）的次序。</p><p>DFS在访问所有和厨师顶点有路径相连的顶点后结束，可以用于检查一个图的连通性以及连通分量，利用图的DFS森林形式的表示法可以检查图中是否包含回路。</p><h3 id="广度优先查找"><a href="#广度优先查找" class="headerlink" title="广度优先查找"></a>广度优先查找</h3><p>首先访问所有和初始顶点邻接的点，然后是离它俩条边的所有未访问顶点，以此类推，直到所有与初始顶点同在一个连通分量中的顶点都被访问过了为止。如果仍然存在未被访问的顶点，该算法必须从图中的其他连通分量重的任意顶点重新开始。</p><p>使用队列来跟踪广度优先查找操作时比较方便的。</p><p>该队列从遍历的初始顶点开始，将该顶点标记为已访问，在每次迭代的时候，该算法找出所有和队头顶点邻接的未访问顶点，将它们标记为已访问，再把他们入队，然后将队头顶点从队列中移去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">BFS(G)<br><span class="hljs-comment">// 实现给定图的广度优先遍历</span><br><span class="hljs-comment">// 输入：图G=（V，E）</span><br><span class="hljs-comment">// 输出：图G的顶点，按照BFS遍历访问到的先后次序，用连续的整数标记</span><br><span class="hljs-comment">//      将V中的每个顶点标记为0，表示还“未访问”</span><br>count = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">for</span>(Vertex v: V)&#123;<br>  <span class="hljs-keyword">if</span>(v.markerdCount == <span class="hljs-number">0</span>)&#123;<br>    bfs(v);<br>  &#125;<br>&#125;<br>bfs(v);<br><span class="hljs-comment">//访问所有和v连接的未访问顶点，然后按照全局变量count的值</span><br><span class="hljs-comment">//根据访问他们的先后次序，给它们赋上相应的数字</span><br>count++;<br>v.markedCount = count;<br><span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>  <span class="hljs-keyword">for</span>(Vertex w : V)&#123;<br>    <span class="hljs-keyword">if</span>(w.adjacent(v) &amp;&amp; w.markedCount == <span class="hljs-number">0</span>)&#123;<br>      count++;<br>      w.markedCount = count;<br>      queue.push(w);<br>    &#125;<br>  &#125;<br>  queue.pop(w);<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS 只产生顶点的一种排序，因为队列时先进先出的结构，所以顶点入队和出队次序一致。</p><p>BFS检查图的连通性和无环性，可以求俩个顶点间边的数量最少的路径。</p><h1 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h1><p>利用来一个问题给定实例的解和同样问题较小实例的解之间的某种关系，一旦建立了这种关系，我们既可以从顶向下也可以由底向上来运用该关系。</p><p><strong>3种主要变化形式</strong></p><ul><li>减去一个常量</li><li>减去一个常量因子</li><li>减去的规模是可变的</li></ul><p>减一技术：规模为$n$​的问题—&gt;规模为$n-1$​的问题—&gt;子问题的解—&gt;原问题的解</p><p>减半技术：规模为$n$​的问题—&gt;规模为$n&#x2F;2$​​的问题—&gt;子问题的解—&gt;原问题的解</p><p>减可变规模：计算最大公约数的欧几里得算法$gcd(m,n)&#x3D;gcd(n,m\ mode\  n)$​</p><h2 id="减一技术"><a href="#减一技术" class="headerlink" title="减一技术"></a>减一技术</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>数组$A[0..n-1]$</p><p>遵循减一的思路，假设数组$A[0…n-2]$​​已经有序，$A[0]\le … \le A[n-2]$​​​</p><p>则对于$A[n-1]$,我们需要做的就是在这些有序的元素中为$A[n-1]$找到合适的位置，插入进去。</p><p>一般来说，可以从左至右扫描该有序数组的子数组，直到遇到一个小于等于$A[n-1]$的元素，然后把$A[n-1]$​插在这个元素的后面，这种被称为<strong>直接插入排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">InsertionSort(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 用插入排序对给定数组排序</span><br><span class="hljs-comment">// 输入：n个可排序数组构成的一个数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>val = A[i]<br>j = i-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; val)&#123;<br>A[j+<span class="hljs-number">1</span>] = A[j];<br>j--;<br>&#125;<br>A[j+<span class="hljs-number">1</span>] = val;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向图：一个对所有边都指定方向的图</p><p>邻接矩阵和邻接链表是俩种表示有向图的主要手段。</p><p>当采用这这俩种方式表示时，无向图和有向图只有俩个显著的差异：</p><p>（1）有向图的邻接矩阵并不一定表现出对称性</p><p>（2）有向图的一条边在图的邻接链表中只有一个相应的节点（不是俩个）</p><p>有向图的遍历，深度优先和广度优先查找是主要的遍历算法</p><p>在对图的边引入方向后，讨论一个问题，</p><p>例如：</p><p>一个必修课集合${}$${C_1,C_2,C_3,C_4,C_5}$​学生必须在某个阶段修完这几门课程，可以按照任何次序学习这些课程，只要满足下列条件：</p><p>（1） $C_1$​和$C_2$​没有任何先决条件</p><p>（2）修完$C_1$​，$C_2$​才能修$C_3$​</p><p>（3）修完$C_3$​才能修$C_4$​</p><p>（4）修完$C_3$​和$C_4$​才能修$C_5$​​</p><p>（5）每个学习只能修一门课程</p><p>是否可以按照这种次序列出它的顶点，使得对于图中每一条边来说，边的起始顶点总是排在边的结束顶点之前（是不是能够求出该图节点的这样一个序列？）这个问题称为<strong>拓扑排序</strong></p><p>如果有向图具有一个有向的回路，该问题无解，为使得拓扑排序成为可能，充要条件是问题中的图必须是一个无环有向图。</p><p>有俩种高效的算法是既可以验证是否是无环有向图，又可以在是的情况下输出拓扑排序的一个顶点序列。</p><p><strong>第一种：深度优先查找的一个简单应用（DFS）</strong>：执行一次DFS遍历，并记住顶点变成死端（即推出遍历栈）的顺序。</p><p>将该次序反过来就得到拓扑排序的一个解，当然，在遍历的时候不能遇到回边。</p><p>如果遇到一条回边，该图就不是无环有向图，并且对它的顶点的拓扑排序是不可能的。</p><p>当一个顶点$v$退出DFS栈时，在比$v$更早退出栈的顶点中，不可能存在顶点$u$拥有一条从$u$到$v$的边（否则，$(u,v)$会成为一条回边），所以，在退栈的队列中，任何这样的顶点$u$都会排在$v$的后面，并且在逆序队列中会排在$v$的前面。</p><p><strong>第二种：基于减一技术的一个直接实现（源删除算法）：</strong>不断地做这样一件事，在余下的有向图中求出一个源（source），它是一个没有输入边的顶点，然后把它和从它出发的边都删除，（如果有多个这样的源，可以任意选择一个。如果这样的源不存在，算法停止，因为该问题无解）顶点被删除的次序就是拓扑排序问题的一个解。</p><p>拓扑排序在计算机科学中有很多应用，包括程序编译中的指令调度，电子表格单元格的公式求值顺序以及解决链接器中的符号依赖问题。</p><h3 id="生成组合对象的算法"><a href="#生成组合对象的算法" class="headerlink" title="生成组合对象的算法"></a>生成组合对象的算法</h3><p>组合对象中最重要的类型就是排列，组合，给定集合的子集。离散数学有一个分支名为组合数学，专门研究组合对象。我们这里感兴趣的主要是如何生成它们。</p><h4 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h4><p>假如需要对元素进行排列的集合是从$1$到$n$的简单整数集合，解释为$n$个元素${a_1，..a_n}$​的元素下标。</p><p>对于生成${1,…n}$的所有$n!$个排列的问题：</p><p>减一技术：将问题规模减一，转化成$(n-1)!$​​个排列，把$n$插入$n-1$个元素的每一种排列中的$n$个可能位置中去，来得到较大规模问题的一个解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Johnson <span class="hljs-title function_">Trotter</span><span class="hljs-params">(n)</span><br><span class="hljs-comment">// 实现用来生成排列的Johnson Trotter算法</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出： &#123;1,...,n&#125;的所有排列的列表</span><br>将第一个排列初始化为<span class="hljs-number">12.</span>.n<br><span class="hljs-title function_">while</span><span class="hljs-params">(存在一个移动元素)</span>&#123;<br>   求最大的移动元素k<br>   把k和它箭头指向的相邻元素互换<br>   调转所有大雨k的元素的方向<br>   将新排列添加到列表中<br>&#125;<br></code></pre></td></tr></table></figure><p>对于$n&#x3D;3$，字典序：</p><p>$123, 132，213，231，312，321$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">LexicograhicPermute(n)<br><span class="hljs-comment">// 以字典序产生排列</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出：在字典序下&#123;1,..,n&#125;所有排列的列表</span><br>init(第一个排列为<span class="hljs-number">12.</span>.n)<br><span class="hljs-keyword">while</span>(最后一个排列有俩个连续升序的元素)&#123;<br>  找出使得a_i&lt;a_i+<span class="hljs-number">1</span>的最大的i（a_i+<span class="hljs-number">1</span>&gt;a_i+<span class="hljs-number">2</span>&gt;..&gt;a_n）<br> <br>  找到使得a_i&lt;a_j的最大索引j(j&gt;=i+<span class="hljs-number">1</span>)因为a_i &lt; a_i+<span class="hljs-number">1</span><br>  <span class="hljs-comment">// 交换a_i，a_j</span><br>  swap(a_i,a_j);<br>  <span class="hljs-comment">// 将a_i+1到a_n反序</span><br>  reverse(a,i+<span class="hljs-number">1</span>,n);<br>  <span class="hljs-comment">// 将这个新排列添加到列表中</span><br>  resultList.add(a);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成子集"><a href="#生成子集" class="headerlink" title="生成子集"></a>生成子集</h4><p>幂集：一个集合的所有子集的集合称为它的幂集。</p><p>是否存在一种生成位串的最小变化算法，使得每一个位串和它直接前趋之间仅仅相差一位（就子集来说，我们希望每一个子集和它的直接前趋之间的区别，要么是增加一个元素，要么是删除一个元素，但俩者不能同时发生）</p><p>》〉》〉》 二进制反射格雷码（binary reflected Gray code）</p><p>例如$n&#x3D;3$,</p><p>$000 \ 001 \ 011\ 010\ 110\ 111\ 101\ 100$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">BRGC(n)<br><span class="hljs-comment">// 递归生成n位的二进制反射格雷码</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出：所有长度为n的格雷码位串列表</span><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>  表L包含位串<span class="hljs-number">0</span>和位串<span class="hljs-number">1</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">// 生成长度为n-1的位串列表L1</span><br> L1 = BRGC(n-<span class="hljs-number">1</span>)<br>  <span class="hljs-comment">// 把表L1倒序后复制给L2</span><br>  copy(reverse(L1), L2)<br>  <span class="hljs-comment">// 把0加到表L1中的每个位串前面</span><br>  L1.addFront(<span class="hljs-number">0</span>)<br>  <span class="hljs-comment">// 把1加到表L2中的每个位串前面</span><br>  L2.addFront(<span class="hljs-number">1</span>)<br>  <span class="hljs-comment">// 把表L2添加到表L1后面得到表L</span><br>  L = L1.addTail(L2)<br>&#125;<br><span class="hljs-keyword">return</span> L;<br></code></pre></td></tr></table></figure><h2 id="减常因子算法"><a href="#减常因子算法" class="headerlink" title="减常因子算法"></a>减常因子算法</h2><p>减常因子算法常常具有对数时间效率，非常高效，因此实例并不多。</p><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>对于有序数组来说，折半查找是一种性能卓越的算法，它通过逼阿胶查找键K和数组中间元素$A[m]$来完成查找工作，如果它们相等，算法结束。否则，如果$K&lt;A[m]$​，就对数组的前半部分执行该操作，如果$K&gt;A[m]$,则对数组的后半部分执行该操作。</p><p>折半查找是基于递归的思想，也可以非递归算法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">BinarySearch(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>],K)<br><span class="hljs-comment">// 实现非递归的折半查找</span><br><span class="hljs-comment">// 输入：一个升序数组A[0..n-1]和一个查找键K</span><br><span class="hljs-comment">// 输出：一个数组元素的下标，该元素等于K；如果没有这样一个元素，返回-1</span><br>l = <span class="hljs-number">0</span>, r = n-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span><br>  <span class="hljs-keyword">if</span>(K == A[m]) <span class="hljs-keyword">return</span> m;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &lt; A[m]) r = m-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &gt; A[m]) l = m+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>$C_{avg} \ &#x3D; \log_2n$​​</p><h3 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a>假币问题</h3><p>在$n$枚外观相同的硬币中，有一枚假币。</p><p>在一架天平上，可以比较任意俩组硬币，可以通过观察天平向右倾还是向左倾还是水平，判断俩组硬币重量是否相同，或者哪一组更重，要求设计一个高效的算法来检测出这枚假币。</p><p>假设假币相对真币较轻</p><p>最自然的思路是将$n$枚硬币分为俩摊，每堆有$n&#x2F;2$枚硬币</p><p>（1）如果$n$​​为奇数，就留下一枚额外的硬币，然后把俩堆硬币放在天平上，如果俩堆硬币重量相同，那么放在旁边的即为假币；否则循环比较较轻的一堆硬币</p><p>（2）如果$n$​为偶数，则循环比较较轻的一堆硬币</p><p>$W(n)&#x3D;W(n&#x2F;2)+1,当n&gt;1，W(1)&#x3D;0$</p><p>$W(n)&#x3D;log_2n$</p><p>这并不是最高效的解法，如果把硬币分为三堆呢？每堆$n&#x2F;3$枚硬币，将会更好</p><p>$W(n)&#x3D;log_3n$</p><h3 id="俄式乘法"><a href="#俄式乘法" class="headerlink" title="俄式乘法"></a>俄式乘法</h3><p>假设$n$和$m$​是俩个真整数，需要计算它们的乘积。</p><p>同时，我们用$n$​的值作为实例规模的度量标准，这样，</p><p>（1）如果$n$​是偶数，一个规模为原来一半的实例必须要对$n&#x2F;2$​进行处理，对于该问题较大的实例的解和较小实例的解的关系，有一个显而易见的公式：</p><p>$n<em>m&#x3D;n</em>2m&#x2F;2$​</p><p>（2）如果$n$是奇数，只需要对该公式做轻微调整：</p><p>$n<em>m&#x3D;(n-1)&#x2F;2</em>2m+m$</p><p>通过应用这个公式，并以$1*m&#x3D;m$作为算法停止的条件。</p><p>既可以采用递归也可以采用迭代计算，该算法只包括折半，加倍，相加这几个操作，硬件实现速度也很快，使用移位即可完成折半和加倍操作</p><h3 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h3><p>$n$个人围成一个圈，并将他们从$1$到$n$​​编上号码。从编号为$1$的那个人那里开始这个残酷的计数，每次消去第二个人直到只留下最后一个幸存者。</p><p>要求算出幸存者的号码$J(n)$​</p><p>（1）如果$n$为偶数，$n&#x3D;2k$，对整个圆圈处理第一遍之后，生成了同样问题的规模减半的实例。唯一差别是位置的编号。</p><p>例如一个初始位置为$3$​的人在第$2$​轮会处于$2$​号位置上，初始位置$5$​的人会处在$3$​号位置上，以此类推，</p><p>$J(2k)&#x3D;2J(k)-1$​​</p><p>（2）如果$n$​为奇数，$n&#x3D;2k+1$​。第一轮消去所有偶数位置上的人，如果把紧接着消去的位置 $1$​上的人也加进来，留下一个规模为$k$​的实例。这里，为了得到与新的位置编号相对应的初始位置编号，我们必须把新的位置编号乘$2$​再加上$1$​,因此对于奇数$n$​,</p><p>$J(2k+1)&#x3D;2J(k)+1$</p><p>由于这个游戏可以看成一个环形，位置的变化是一种环形内位置的移位过程，我们可以对$n$本身做一次向左的循环移位来得到$J(n)$，</p><p>$J(6)&#x3D;J(110_2)&#x3D;101_2&#x3D;5$</p><p>$J(7)&#x3D;J(111_2)&#x3D;111_2&#x3D;7$​</p><h2 id="减可变规模算法"><a href="#减可变规模算法" class="headerlink" title="减可变规模算法"></a>减可变规模算法</h2><p>在减治法的第三个主要变化形式中，算法在每次迭代时，规模减小的模式和另一次迭代时不同的，计算最大公约数的欧几里得算法提供了这类算法的一个非常好的例子。</p><h3 id="计算中值和选择问题"><a href="#计算中值和选择问题" class="headerlink" title="计算中值和选择问题"></a>计算中值和选择问题</h3><p><strong>选择问题</strong>是求一个$n$个数列表的第$k$个最小元素的问题。</p><p>这个数字被称为<strong>第$k$​个顺序统计量</strong></p><p>对于$k&#x3D;1,k&#x3D;n$，可以扫描元素列表，获取最小或最大元素。</p><p>该问题的一个有意思的情况是在$k&#x3D;n&#x2F;2$​​时，要求找出这样一个元素，列表中的一半元素哒，又比一半元素小。这个元素称为<strong>中值</strong>。</p><p>（1）一种方法是先将列表排序，选出第$k$个元素。算法的运行时间取决于排序算法的效率，选用类似合并排序的算法，效率是$O(nlog_n)$​</p><p>当然，整个列表的排序可能没有必要，毕竟我们只是找出第$k$小的元素</p><p>（2）划分的思路。将一个给定列表根据某个值$p$（例如列表的第一个元素）进行划分，对列表元素进行重新整理，使左边部分包含所有小于等于$p$的元素，紧接着是中轴本身，右边是所有大于或等于$p$的元素</p><p>又俩种主要的划分算法，$Lomuto划分$，$Hoare算法$​</p><p>$|所有小于等于p的元素|$      $|p|$     $|所有大于或等于p的元素|$​</p><p>这里讨论$Lomuto划分$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LomutoPartition(A[l,,r])</span><br><span class="hljs-comment">// 采用Lomuto算法，用第一个元素作为中轴子对数组进行划分</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]的一个子数组A[l..r],它由左右俩边的索引l和r(l&lt;=r)定义</span><br><span class="hljs-comment">// 输出：A[l..r]的划分和中轴的新位置</span><br>p = A[l]<br>s = l<br><span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = l+<span class="hljs-number">1</span>; i &lt;= r; i++)</span>&#123;<br><span class="hljs-keyword">if</span>(A[i] &lt; p)&#123;<br>s = s+<span class="hljs-number">1</span>;<br>    swap(A[s],A[i]);<br>&#125;<br>&#125;<br>swap(A[l],A[s]);<br><span class="hljs-keyword">return</span> s;<br></code></pre></td></tr></table></figure><p>如何利用划分列表来寻找第$k$最小元素呢？</p><p><strong>快速选择</strong>：假设列表时以数组实现的，其元素索引从$0$开始，而$s$是划分的分割位置，也就是划分后中轴所在元素的索引。</p><p>（1）如果$s&#x3D;k-1$，中轴$p$即为第$k$小的元素</p><p>（2）如果$s&gt;k-1$​，第$k$​小元素就是被划分数组左边部分的第$k$​​小元素</p><p>（3）如果$s&lt;k-1$​,第$k$​小元素就是被划分数组右边部分的第$(k-s)$​​​小元素　</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Quickselect(A[l..r],k)</span><br><span class="hljs-comment">// 用基于划分的递归算法解决选择问题</span><br><span class="hljs-comment">// 输入：可排序的数组A[0..n-1]的子数组A[l..r]和整数k(1&lt;=k&lt;=r-l+1)</span><br><span class="hljs-comment">// 输出：A[0..n-1]中第k小元素的值</span><br>s = LomutoPartition(A[l,,r]) <span class="hljs-comment">// 或者另一个划分算法</span><br><span class="hljs-keyword">if</span> s == l+k-<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> A[s]<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; l+k-<span class="hljs-number">1</span> Quickslect(A[l,,s-<span class="hljs-number">1</span>], k)<br><span class="hljs-keyword">else</span> Quickselect(A[s+<span class="hljs-number">1</span>,,r], l+k-<span class="hljs-number">1</span>-s)<br></code></pre></td></tr></table></figure><p>非递归</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>如果是求取第$k$大元素，类似</p><p><strong>效率分析</strong>：$O(n^2)$</p><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>作为减可变规模算法的下一个例子，我们考虑一个查找有序数组的算法，<strong>插值查找</strong></p><p>不同于折半查找总是查找键和给定有序数组的中间元素进行比较（也因此把问题规模消减了一半），插值查找为了找到用来和查找键进行比较的数组，考虑了查找键的值。</p><h3 id="二叉树的查找和插入"><a href="#二叉树的查找和插入" class="headerlink" title="二叉树的查找和插入"></a>二叉树的查找和插入</h3><p>二叉查找树：这种二叉查找树的节点包含了可排序项集合中的元素，每个节点一个元素，并使得对于每个节点来说，所有左子树的元素都小于子数根节点的元素，所有右子树的元素都大于子树根节点的元素。</p><p>当在这样一棵树中查找给定值$v$的元素时，可以递归采用下面的方法。</p><p>（1）如果这棵树为空，则查找失败；</p><p>（2）如果这棵树不为空，把$v$和根节点$K$​作比较，</p><ul><li>如果等于$K$，查找结束​</li><li>如果比$K$​​小，继续在左子树中查找</li><li>如果比$K$​​​大。继续在右子树中查找</li></ul><p>一棵查找树的规模的最佳度量标准就是树的高度，树的高度的减少通常都不相同，这给我们一个很好的减可变规模算法的例子。</p><p>查找效率最差是当二叉查找树只有一边时，效率为$\Theta(n)$​,平均查找效率为$\Theta(logn)$​</p><h3 id="拈游戏"><a href="#拈游戏" class="headerlink" title="拈游戏"></a>拈游戏</h3><p>一般来说，该游戏中会有若干堆棋子，但我们先来考单堆棋子的版本。</p><p>现在只有一堆$n$个棋子。</p><p>俩个玩家轮流从堆中拿走最少一个，最多$m$​个棋子。每次拿走的棋子数都可以不同，但能够拿走的上下限数量不变。如果每个玩家都做出了选择，哪个玩家能够胜利拿到最后那个棋子？是先走的还是后走的？</p><p>当且仅当$n \mod\ (m+1) \neq 0$​​​，胜局</p><p>因此，胜利的策略是每次拿走$n \mod\ (m+1)$​个棋子，如果背离这个策略，则会把胜局留给对手</p><p>一般来说，拈游戏包含$I&gt;1$堆棋子，每堆的棋子数分别$n_1,n_2,…n_I$​。每次走的时候，玩家可以从任意一堆棋子中拿走任意允许数量的棋子，甚至可以把一堆都拿光。游戏的目的同样是成为最后一个还能走的玩家。</p><p>这种形式的拈游戏的解出人意料，竟然基于堆中棋子数的二进制表示。$b_1,b_2,..b_I$​分别表示各堆棋子数的二进制表示。计算它们的二进制数位和，也称为拈和，即对每一位分别求和并忽略进位。</p><p>可以证实，当且仅当二进制数位和中包含至少一个$1$​时，该实例是一个胜局，只包含$0$​时是一个败局。</p><p>例如：$n_1&#x3D;3,n_2&#x3D;4,n_3&#x3D;5$​,数位和（拈和）:011+100+101&#x3D;010。该实例对于先走的玩家来说是一个胜局，要找到该局的一个胜手，玩家需要改变三个位串在中的一个，使得新的二进制数位和仅包含$0$​。因此，先手玩家从第一堆中拿走$2$​个棋子。</p><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>分治法是按照一下方案工作的：</p><ol><li>将一个问题划分为同一类型的若干子问题，子问题最好规模相同。</li><li>对这些子问题求解（一般使用递归方法，但在问题规模足够小时，有时也会利用另一个算法）</li><li>有必要的话，合并这些子问题的解，已得到原始问题的答案。</li></ol><p>分治法对于并行计算时非常理想的，因为各个子问题都可以由各自的CPU同时计算。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>合并排序</strong>是成功应用分治技术的一个完美例子。</p><p>对一个需要排序的数组$A[0..n-1]$ ，合并排序把它一分为二：$A[0..\lfloor n&#x2F;2\rfloor-1]$和$A[\lfloor n&#x2F;2\rfloor..n-1]$。并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MergeSort(A[0..n-1])</span><br><span class="hljs-comment">// 递归调用mergersort来对数组A[0..n-1]排序</span><br><span class="hljs-comment">// 输入：一个可排序的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列数组A[0..n-1]</span><br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>copy A[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>] to B[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>]<br>copy A[[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1.</span>.n-<span class="hljs-number">1</span>] to C[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>]<br>MergeSort(B[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>])<br>MergeSort(C[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// Merge()见下文</span><br>Merge(B,C,A)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对俩个有序数组的合并</strong>，可以通过下面的算法完成。</p><p>初始状态下，俩个指针（数组下标）分别指向俩个带合并数组的第一个元素。</p><p>然后比较这俩个元素的大小，将较小的元素添加到一个新创建的数组中。</p><p>接着，被复制数组的指针后移，指向较小元素的后继元素。</p><p>上述操作，一直持续到两个数组中的一个被处理完为止。</p><p>最后，在未处理完的数组中，剩下的元素被复制到新数组的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Merge(B[0..p-1],C[0..q-1],A[0..p+q-1)</span><br><span class="hljs-comment">// 将俩个有序数组合并为一个有序数组</span><br><span class="hljs-comment">// 输入：俩个有序数组B[0..p-1],C[0..q-1]</span><br><span class="hljs-comment">// 输出：A[0..p+q-1]中已经有序存放了B和C中的元素</span><br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; p &amp;&amp; j &lt; q)&#123;<br><span class="hljs-keyword">if</span>(B[i] &lt;= C[j])&#123;<br>A[k] = B[i];<br>i++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>A[k] = C[j];<br>j++;<br>&#125;<br>k++;<br>&#125;<br><span class="hljs-keyword">if</span>(i == p)&#123;<br>copy C[j..q-<span class="hljs-number">1</span>] to A[k..p+q-<span class="hljs-number">1</span>]<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>copy B[i..p-<span class="hljs-number">1</span>] to A[k..p+q-<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>合并排序算法的效率，简单起见，假设$n$是$2$的乘方</p><p>键值比较次数$C(n)$的递归关系式为：</p><p>当$n&gt;1$,$C(n)&#x3D;2C(n&#x2F;2)+C_{merge}(n),C(1)&#x3D;0$</p><p>$C_{merge}(n)$即合并阶段进行键值比较的次数。每做一步都需要进行一次比较，比较之后，俩个数组中尚需处理的元素总个数减$1$。在最坏情况下，无论那个数组都不会为空，除非另一个数组只剩下最后一个元素（举例来说，最小的元素轮流来自于不同的数组）。因此，对于最坏情况来说，$C_{merge}(n)&#x3D;n-1$,有以下递推式：当$n&gt;1$,$C_{worst}(n)&#x3D;2C_{worst}(n&#x2F;2)+(n-1),C_{worst}(1)&#x3D;0$</p><p>$C_{worst}(n)&#x3D;nlog_2n-n+1$,效率属于$\Theta(nlogn)$。</p><p>合并排序的显著优点在于其稳定性，主要缺点是该算法需要线性的额外空间。主要有俩类变化形式。</p><p>首先，算法可以自底向上合并数组的一个个元素对，然后再合并这些有序对，以此类推，这就避免了使用堆栈处理递归调用时的时间和空间开销。</p><p>其次，可以吧数组划分为待排序的多个部分，再对它们递归排序，最后将其合并在一起。这个方案尤其适合在对存放在二级存储空间的文件进行排序。也被称为多路合并排序。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是另一种基于分治技术的重要排序算法。不像合并排序是按照元素在数组中的位置对他们进行划分，快速排序按照元素的值对它们进行划分。</p><p>建立了一个划分之后，$A[s]$已经位于它在有序数组中的最终位置，接下来我们可以继续对$A[s]$前和$A[s]$后的子数组分别进行排序。</p><p><strong>快排与合并排序的不同之处在于</strong>：在合并排序算法中，将问题划分成俩个子问题是很快的，算法的主要工作在于合并子问题的解，而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并子问题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Quicksort(A[l..r])</span><br><span class="hljs-comment">// 用Quicksort对子数组排序</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]中的子数组A[l..r],由左右下表l和r定义</span><br><span class="hljs-comment">// 输出：非降序排列的子数组A[l..r]</span><br><span class="hljs-keyword">if</span> (l &lt; r)&#123;<br>  <span class="hljs-comment">// s是分裂位置</span><br>s = Partition(A[l..r])<br>QuickSort(A[l..s-<span class="hljs-number">1</span>])<br>QuickSort(A[s+<span class="hljs-number">1.</span>.r])<br>&#125;<br></code></pre></td></tr></table></figure><p>作为一种划分算法，我们当然可以使用之前讨论的Lomuto划分，也可以使用Hoare划分。Hoare是英国杰出的计算机科学家，快速排序算法的发明者。</p><p>与以前一样，我们要选择一个中轴，接下来会根据该元素的值来划分子数组，选择中轴有许多不同的策略，这个选择与算法的效率有关，暂定我们选择子数组中的第一个元素，即$p&#x3D;A[l]$。</p><p>分别从子数组的俩端进行扫描，并且将扫描到的元素与中轴比较，从左到右的扫描（用指针$i$表示）从第二个元素开始，因为我们希望小于中轴的元素位于子数组的左半部分，扫描会忽略小于中轴的元素，直到遇到第一个大于等于中轴的元素才停止。从右至左的扫描（下面用指针$j$表示）从最后一个元素开始。因为我们希望大于中轴的元素位于子数组的右半部分，扫描会忽略大于中轴的元素，直到遇到第一个小于等于中轴的元素才会停止。</p><p>俩次扫描全部停止以后取决于扫描的指针是否相交：会发生$3$种不同的情况。</p><p>（1）扫描指针$i$和$j$不相交，即$i&lt;j$，$swap(A[i],A[j])，i++,j–$，</p><p>（2）扫描指针$i$和$j$相交，即$i&#x3D;&#x3D;j$，被指向元素的值一定等于$p$</p><p>（3）$i&gt;&#x3D;j$，$swap(A[i],A[j])$。</p><p><strong>为啥当遇到与中轴元素相等的元素时值得停止扫描？</strong></p><p>因为当遇到有很多相同元素的数组时，这个方法可以将数组分得更加平均，从而使得算法运行得更快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HoarePartition(A[l..r])</span><br><span class="hljs-comment">// 以第一个元素为中轴，对子数组进行划分</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]中的子数组A[l..r]，由左右下标l和r定义</span><br><span class="hljs-comment">// 输出：A[l..r]的一个划分，分裂点的位置作为函数的返回值</span><br>p = A[l]<br>i = l;j = r+<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span>(i &lt; j)&#123;<br><span class="hljs-keyword">while</span>(A[i] &lt; p)&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">while</span>(A[j] &gt; p)&#123;<br>j--;<br>&#125;<br>swap(A[i],A[j]);<br>&#125;<br><span class="hljs-comment">// 当i&gt;=j撤销后最后一次交换</span><br>swap(A[i],A[j]);<br>swap(A[l],A[j]);<br><span class="hljs-keyword">return</span> j;<br></code></pre></td></tr></table></figure><p>快速排序时不稳定的，同时还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到$O(logn)$，但是还是比堆排序$O(1)$的空间效率差。</p><h2 id="二叉树遍历及其相关特性"><a href="#二叉树遍历及其相关特性" class="headerlink" title="二叉树遍历及其相关特性"></a>二叉树遍历及其相关特性</h2><p>如何把分治技术应用到二叉树中。二叉树定义为若干节点的一个有限集合，它要么为空，要没由一个根和俩棵树称为$T_L$和$T_R$的不相交二叉树构成。这俩棵二叉树分别为根的左右子树。</p><p>定义本身把二叉树划分为同样类型的俩个更小的组成部分-左子树和右子树。</p><p>作为一个例子，考虑计算二叉树高度的递归算法。</p><p><strong>树的高度</strong>：从叶子到根之间的最长路径长度。</p><p>二叉树的高度计算：它是根的左右子树最大高度加$1$（加$1$代表根所在的那一层），如果把空树的高度定义为$-1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Height(T)</span><br><span class="hljs-comment">// 递归计算二叉树的高度</span><br><span class="hljs-comment">// 输入：一棵二叉树T</span><br><span class="hljs-comment">// 输出：T的高度</span><br><span class="hljs-keyword">if</span> T == <span class="hljs-literal">null</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> max(Height(T_L), Height(T_R))+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>给定的二叉树的节点数$n(T)$来度量问题实例的规模。为计算俩数中的较大值，算法执行比较次数等于算法执行的加法操作次数$A(n(T))$.对于$A(n(T))$,有如下递推关系：</p><p>当$n(T)&gt;0$,$A(n(T))&#x3D;A(n(T_{left}))+A(n(T_{right}))+1$</p><p>$A(0)&#x3D;0$</p><p>在了解这个递推关系之前，先指出，加法运算并不是该算法中最频繁执行的操作，那是哪个操作呢？检查树是否为空，这才是二叉树算法中的典型操作。</p><p>对于非空完全为叉树来说，$n$和$x$分别代表父母节点和叶子极点的数量</p><p>回到$Height$算法中，检查树是否为空的比较操作次数为：</p><p>$C(n)&#x3D;n+x&#x3D;2n+1$</p><p>而加法操作的次数为：$A(n)&#x3D;n$</p><p><strong>二叉树的三种经典遍历算法</strong></p><p>前序遍历：根在访问左右子树之前就被访问</p><p>中序遍历：根在访问左子树后，但在访问右子树之前被访问</p><p>后序遍历：根在访问左右子树之后被访问</p><h2 id="大整数乘法和Strassen矩阵乘法"><a href="#大整数乘法和Strassen矩阵乘法" class="headerlink" title="大整数乘法和Strassen矩阵乘法"></a>大整数乘法和Strassen矩阵乘法</h2><p>俩个数的乘法和俩个方阵的乘法，俩个算法都巧妙的运用分治技术获得更好的渐进效率。</p><h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>如果我们使用经典的笔算算法来对俩个$n$位整数相乘，第一个数中的$n$个数字都要分别被第二个数中的$n$个数字相乘，这样$n^2$次位乘。虽然看上去设计一个乘法次数小于$n^2$的算法是不可能的，但事实证明并非如此。</p><p>举例：$23 \times 14$</p><p>$23&#x3D;2\times10^1+3\times10^0$</p><p>$14&#x3D;1\times10^1+4\times10^0$</p><p>$23\times14&#x3D;(2\times10^1+3\times10^0)\times(1\times10^1+4\times10^0)$</p><p>$23\times14&#x3D;(2\times1)\times10^2+(2\times4+3\times1)+(3\times4)\times10^0&#x3D;322$</p><p>但这和笔算算法一样，都是用来$4$次位乘，由于$2\times1$和$3\times4$是无论如何都需要计算的。可以复用它们的乘积</p><p>$2\times4+3\times1&#x3D;(2+3)\times(1+4)-(2\times1)-(3\times4)$</p><p> <strong>计算俩个$n$位整数$a$和$b$的积$c$</strong></p><p>其中$n$是一个正的偶数。我们从中间把数字一分为二，</p><p>把$a$的前半部分记为$a_1$,后半部分记为$a_0$;同理$b$记为$b_1$和$b_0$</p><p>$a&#x3D;a_110^{n&#x2F;2}+a_0$</p><p>$b&#x3D;b_110^{n&#x2F;2}+b_0$</p><p>$c&#x3D;a\times b&#x3D;(a_110^{n&#x2F;2}+a_0)\times (b_110^{n&#x2F;2}+b_0)&#x3D;(a_1\times b_1)10^n+(a_1b_0+a_0\times b_1)10^{n&#x2F;2}+(a_0\times b_0)&#x3D;c_210^n+c_110^{n&#x2F;2}+c_0$</p><p>其中$c_2&#x3D;a_1 \times b_1,c_0&#x3D;a_0\times b_0, c_1&#x3D;(a_1+a_0)\times (b_1+b_0)-(c_2+c_0)$</p><p>$c_2$是它们前半部分的积，$c_0$是它们后半部分的积，$c_1$是$a$俩部分和与$b$俩部分和的积减去$c_2$与$c_0$的和。</p><p>如果$n&#x2F;2$也是偶数，即可以应用相同的方法计算$c_2$和$c_0$和$c_1$。</p><p>因此，如果$n$是$2$的乘方，我们就得到了一个计算俩个$n$位数积的递归算法。当$n&#x3D;&#x3D;1$时停止。</p><p>该算法会做多少次位乘呢？</p><p>因为$n$位数的乘法需要对$n&#x2F;2$位数做三次乘法运算，乘法次数$M(n)$递归式如下：</p><p>当$n&gt;1$时，$M(n)&#x3D;3M(n&#x2F;2),M(1)&#x3D;1$</p><p>当$n&#x3D;2^k$时，可以反向替换法对它求解：</p><p>$M(2^k)&#x3D;3M(2^{k-1})&#x3D;3^iM(2^{k-i})&#x3D;3^kM(2^{k-k})&#x3D;3^k$</p><p>因为$k&#x3D;log_2n$，$M(n)&#x3D;3^{log_2n}&#x3D;n^{log_23}\approx n^{1.585}$,</p><p>$a^{log_bc}&#x3D;c^{log_ba}$</p><p>该算法需要的加法和减法的次数呢？</p><p>用$A(n)$代表使用上述算法对俩个$n$位十进制数相乘所需要的加减法运算次数。</p><p>除了需要对$n&#x2F;2$位数之间进行三次相乘操作，即$3A(n&#x2F;2)$次乘法运算，上面的公式还需要$5$次加运算和$1$次减运算。因此有递推式：</p><p>当$n&gt;1$时，$A(n)&#x3D;3A(n&#x2F;2)+cn,A(1)&#x3D;1$</p><p>应用本章开头介绍的主定理，得到$A(n)\in \Theta (n^{log_23})$</p><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><p>$\left[<br>\begin{matrix}<br>   c_{00}&amp;c_{01}\c_{10}&amp;c_{11}<br>  \end{matrix}<br>  \right] &#x3D; \left[<br>\begin{matrix}<br>   a_{00}&amp;a_{01}\a_{10}&amp;a_{11}<br>  \end{matrix}<br>  \right] \times \left[\begin{matrix}<br>   b_{00}&amp;b_{01}\b_{10}&amp;b_{11}<br>  \end{matrix}<br>  \right] &#x3D; \left[<br>\begin{matrix}<br>   m_1+m_4-m_5+m_7 &amp; m_3+m_5\m_2+m_4 &amp; m_1+m_3-m_2+m_6<br>  \end{matrix}<br>  \right] $</p><p>其中：</p><p>$m_1 &#x3D; (a_{00}+a_{11})\times(b_{00}+b_{11})$</p><p>$m_2 &#x3D; (a_{10}+a_{11})\times b_{00}$</p><p>$m_3 &#x3D; a_{00}\times(b_{01}-b_{11})$</p><p>$m_4 &#x3D; a_{11}\times(b_{10}-b_{00})$</p><p>$m_5 &#x3D; (a_{00}+a_{01})\times b_{11}$</p><p>$m_6 &#x3D; (a_{10}-a_{00}) \times (b_{00}+ b_{11})$</p><p>$m_7 &#x3D; (a_{01}-a_{11}) \times (b_{10}+ b_{11})$</p><h2 id="分治法解最近对问题和凸包问题"><a href="#分治法解最近对问题和凸包问题" class="headerlink" title="分治法解最近对问题和凸包问题"></a>分治法解最近对问题和凸包问题</h2><h3 id="最近对问题-1"><a href="#最近对问题-1" class="headerlink" title="最近对问题"></a>最近对问题</h3><p>令$P$为笛卡尔平面上$n&gt;1$个点构成的集合，假设集合中的每个点都不一样，且是按照其$x$轴坐标升序排列的。</p><p>$Q$为$P$中集合的点，但是按照其$y$轴坐标升序排列的。</p><p>求最近点对之间的欧几里得距离</p><h4 id="蛮力法-1"><a href="#蛮力法-1" class="headerlink" title="蛮力法"></a>蛮力法</h4><p>当$2&lt;&#x3D;n&lt;&#x3D;3$时，枚举俩个点对，得到最小距离的点对，时间复杂度为$O(n^2)$</p><h4 id="分治求解法"><a href="#分治求解法" class="headerlink" title="分治求解法"></a>分治求解法</h4><p>当$n&gt;3$时，可以利用点集在$x$轴方向上的中位数$m$，在该处作一条垂线，将点集分成大小为$\lceil n&#x2F;2 \rceil 和 \lfloor n&#x2F;2 \rfloor$的俩个子集$P_l$和$P_r$。通过递归求解子问题$P_l$, $P_r$来得到最近点对问题的解。其中$d_l$和$d_r$分别表示在$P_l$和$P_r$中最近对的问题，并定义$d&#x3D;min(d_l,d_r)$</p><h3 id="凸包问题-1"><a href="#凸包问题-1" class="headerlink" title="凸包问题"></a>凸包问题</h3><h1 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h1><p>本章讨论一组设计方法，基于变换的思想，称为变治法，因为这些方法都是分成俩个阶段工作的。在“变”的阶段，出于这样或者那样的原因，把问题的实例变得更容易求解，然后在第二阶段“治”的阶段，对于实例进行求解。</p><p>主要$3$种类型：</p><p><strong>实例化简</strong>：变换同样问题为一个更简单或更方便的实例</p><p><strong>改变表现</strong>：变换同样实例的不同表现</p><p><strong>问题化简</strong>：变换为另一个问题的实例，这种问题的算法时已知的</p><h2 id="预排序"><a href="#预排序" class="headerlink" title="预排序"></a>预排序</h2><p>对于排序算法有这样一个事实，如果列表时有序的，许多关于列表的问题的更容易求解。为简单起见，假设所有列表都是用数组来实现的。</p><p><strong>检查数组中的元素唯一性</strong></p><p>蛮力法对数组中的元素对进行比较，直到找到俩个相等的元素，或者所有的元素对都已比较完毕，它的最差效率为$\Theta (n^2)$。</p><p>换一种做法，可以预先对数组进行排序，然后只检查它的连续元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PresortElementUniqueness(A[0..n-1]</span><br><span class="hljs-comment">//先对数组排序来解元素唯一性问题</span><br><span class="hljs-comment">//输入：n个可排序元素构成一个数组A[0..n-1]</span><br><span class="hljs-comment">//输出：如果A没有相等元素，返回true,否则返回false</span><br>对数组A排序<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++)&#123;<br><span class="hljs-keyword">if</span>(A[i]==A[i+<span class="hljs-number">1</span>])&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>$T(n)&#x3D;T_{sort}(n)+T_{scan}(n)\in\Theta(nlogn)+\Theta(n)&#x3D;\Theta(nlogn)$</p><p><strong>模式计算</strong></p><p>在给定的数字列表中最经常出现的一个数值称为<strong>模式</strong>。</p><p>如果用蛮力法对计算模式将会对列表进行扫描，并计算它的所有不同值出现的频率。为实现这个思路，可以在另一个列表中存储已经遇到的值和它们出现的频率。不难发现，该算法的最差输入是一个没有相等元素的列表，对于这样一个列表，它的第$i$个元素和目前唯一数值的辅助列表中$i-1$个元素比较，然后再加入到辅助列表中，并把出现频率设为$1$。因此，在创建频率列表时，该算法的最差比较次数为：</p><p>$C(n)&#x3D;\sum_{i&#x3D;1}^n&#x3D;0+1+..+(n-1)&#x3D;\frac {(n-1)n}2\in\Theta(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PresortMode(A[0..n-1])</span><br><span class="hljs-comment">// 先对数组排序来计算它的模式</span><br><span class="hljs-comment">// 输入： 可排序元素构成的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出： 该数组的模式</span><br>i = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前一轮从为止i开始</span><br>modeFrequency = <span class="hljs-number">0</span>;<span class="hljs-comment">//目前为止求出的最高频率</span><br><span class="hljs-keyword">while</span>(i &lt;= n-<span class="hljs-number">1</span>)&#123;<br>runLength = <span class="hljs-number">1</span>;<br>runValue = A[i];<br><span class="hljs-keyword">while</span>(runLength + i &lt;= n-<span class="hljs-number">1</span> &amp;&amp; A[i+runLength]==runValue)&#123;<br>runLength = runLength + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(runLength &gt; modeFrequency)&#123;<br>modeFrequency = runLength;<br>modeValue = runValue;<br>&#125;<br>i += runLength; <br>&#125;<br><span class="hljs-keyword">return</span> modeValue;<br></code></pre></td></tr></table></figure><p><strong>查找问题</strong></p><p>考虑$n$个可排序项构成一个给定数组中查找某个给定值$v$的问题。这里的蛮力接发是顺序查找，最坏情况下需要进行$n$此比较。如果该数组是预先排好序的，我们就可以应用折半查找，最坏情况下只需进行$\lfloor log_2n \rfloor +1$</p><p>假设使用最搞笑的$nlogn排序$，这个查找算法再最差情况下的总运行时间是</p><p>$T(n)&#x3D;T_{sort}(n)+T_{select}(n)&#x3D;\Theta(nlogn)+\Theta(logn)&#x3D;\Theta(nlogn)$</p><p>然而这比顺序查找还要差，对于平均效率来说，也是同样的情况，当然如果需要再同一个列表中查找多次，在排序上花费时间应该是值得的。</p><p>那么如果使得预排序有意义，至少需要进行多少次查找？</p><h2 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h2><p>由俩个线性方程构成的二元联立方程组<br>$$<br>{方程组}\begin{cases}a_{11}x+a_{12}y&#x3D;b_1 \a_{21}x+a_{22}y&#x3D;b_2 \end{cases}<br>$$</p><p>求解的方法是无论用哪个方程，先把一个变量表示为另一个变量的函数，再把这个结果代入另一个方程中，得到一个线性方程，然后用它的解来求出另一个变量的值。</p><p>当需要解一个包含$n$个方程的$n$元联立方程组：<br>$$<br>\begin{equation}<br>\begin{cases}<br>a_{11}x_{1}+a_{12}x_{2}+…+a_{1n}x_{n}&#x3D;b_1\<br>a_{21}x_{1}+a_{22}x_{2}+…+a_{2n}x_{n}&#x3D;b_2\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots\<br>a_{n1}x_{1}+a_{n2}x_{2}+…+a_{nn}x_{n}&#x3D;b_n\<br>\end{cases}<br>\end{equation}<br>$$<br>其中$n$是一个大数，对于俩个联立方程的解法推广到这种方程组上求解显得笨重，高斯消元法：思路是将$n$个线性方程构成的$n$元联立方程组变换为一个等价的方程组（即解和原来的方程组一样），该方程组有着一个上三角的系数矩阵，这种矩阵的主对角线下方元素全部为$0$.</p><p>用矩阵的符号可以表示为$$Ax&#x3D;b \Rightarrow A’x&#x3D;b’$$</p><p>其中</p><p>$$A &#x3D; \left[\begin{array}{}      a_{11}&amp;a_{21}&amp; … &amp;a_{n1}\  a_{21}&amp;a_{22}&amp; … &amp;a_{n2} \  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \  a_{n1}&amp;a_{n2}&amp; … &amp;a_{nn}    \end{array} \right] $$</p><p>$$A’&#x3D;\left[    \begin{array}{}      a’<em>{11}&amp;a’</em>{21}&amp; … &amp;a’<em>{n1}\  0&amp;a’</em>{22}&amp; … &amp;a’<em>{n2} \  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \  0&amp;0&amp; … &amp;a’</em>{nn}    \end{array} \right]$$</p><p><strong>前向消去算法</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ForwardElimination<span class="hljs-params">(A[1..n,1..n],b[1..n])</span><br><span class="hljs-string">//</span>对一个方程组的系数矩阵A应用高斯消去法<br><span class="hljs-string">//</span>用该方程组右边的值构成的向量b来扩展该矩阵<br><span class="hljs-string">//</span>输入：矩阵A[1.<span class="hljs-string">.n</span>,1.<span class="hljs-string">.n</span>]和列向量b[1.<span class="hljs-string">.n</span>]<br><span class="hljs-string">//</span>输出：一个代替A的上三角形等价矩阵图，相应的右边的值位于第<span class="hljs-params">(n+1)</span>列中<br>for<span class="hljs-params">(int <span class="hljs-attr">i</span> = 1; i &lt; n; ++i)</span>&#123;<br>A[i,n+1] = b[i]<br>&#125;<br>for<span class="hljs-params">(int <span class="hljs-attr">i</span> = 1; i &lt; n-1; ++i)</span>&#123;<br>for<span class="hljs-params">(int <span class="hljs-attr">j</span> = i+1; j &lt; n; ++j)</span>&#123;<br>for<span class="hljs-params">(int <span class="hljs-attr">k</span> = n+1; k &gt; i; k--)</span>&#123;<br>A[j,k] = A[j,k] - A[i,k]*A[j,i]<span class="hljs-string">/A</span>&#123;i,i]<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的俩个事实</p><ol><li>并不总是正确的，如果A[i,i]&#x3D;0，不能作除数；在该算法的第$i$次迭代中不能把$i$作为基点。同时，$A[i,i]$可能非常小，那么$A[j,i]&#x2F;A[i,i]$很大，以至于$A[j,k]$的新值会因为舍入误差而歪曲，这个误差是在俩个数量级相差非常大的时候相减时发生的。</li><li>最内层的循环效率十分低</li></ol><p>为了避免问题1，可以每次都去找第$i$列系数的绝对值最大的行，然后把它作为第$i$次迭代的基点。这种修改称为<strong>部分选主元法</strong>，它能保证比例因子的绝对值永远不会大于1.</p><p><strong>优化后的算法</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">BetterForwardElimination</span><span class="hljs-params">(A[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..n],b[<span class="hljs-number">1</span>..n])</span></span><br><span class="hljs-comment">// 用部分选主元法实现高斯消去法</span><br><span class="hljs-comment">// 输入：矩阵A[1..n,1..n]和列向量b[1..n]</span><br><span class="hljs-comment">// 输出：一个代替A的上三角形等价矩阵图，相应的右边的值位于第(n+1)列中</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">1</span>; i &lt; n; ++i)</span></span>&#123;<br>A<span class="hljs-selector-attr">[i,n+1]</span> = <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[i]</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p> java中的集合包括三大类，它们是Set、List和Map。它们都处于java.util包中，Set、List和Map都是接口。 本文参考源码为 jdk1.7u79。开始之前，先简单描述下类之间的关系，方便后续看类图。</p><table><thead><tr><th>集合架构</th><th>特性</th></tr></thead><tbody><tr><td>Collection</td><td>接口存储一组不唯一，无序的对象</td></tr><tr><td>List</td><td>接口存储一组不唯一，有序（索引顺序）的对象</td></tr><tr><td>Set</td><td>接口存储一组唯一，无序的对象</td></tr><tr><td>Map</td><td>接口存储一组键值对象，提供key到value的映射Key 唯一 无序；value  不唯一 无序</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">继承关系    —▷    实线 + 空心三角形    鸟 —▷ 动物；鸟继承动物<br>实现接口    •••▷    虚线 + 空心三角形    大雁 •••▷ 飞翔；大雁实现了飞翔接口<br>实现接口    —○    棒棒糖表示法    唐老鸭 —○ 讲人话；唐老鸭实现讲人话接口<br>关联关系    —&gt;    实线剪头    企鹅 —&gt; 气候；企鹅需要‘知道’气候的变化<br>依赖关系    •••&gt;    虚线剪头    动物 •••&gt; 氧气；动物依赖于氧气<br>聚合关系    ◇—&gt;    空心菱形 + 实线剪头    大雁 ◇—&gt; 翅膀；部分和整体的关系<br>合成关系    ◆—&gt;    实心菱形 + 实线剪头    大雁 ◆—&gt; 雁群；<span class="hljs-selector-tag">A</span>包含<span class="hljs-selector-tag">B</span>，但<span class="hljs-selector-tag">B</span>不是<span class="hljs-selector-tag">A</span>的一部分<br></code></pre></td></tr></table></figure><h2 id="接口继承树"><a href="#接口继承树" class="headerlink" title="接口继承树"></a>接口继承树</h2><p>&#x2F;&#x2F; Todo: 待补充</p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>List：有序  不唯一（可重复）</p><p>ArrayList：在内存中分配连续的空间，实现了长度可变的数组</p><ul><li><p>优点：遍历元素和随机访问元素的效率比较高</p></li><li><p>缺点：添加和删除需大量移动元素效率低，按照内容查询效率低</p></li></ul><p>LinkedList：采用双向链表存储方式。</p><ul><li><p>缺点：遍历和随机访问元素效率低下</p></li><li><p>优点：插入、删除元素效率比较高（但是前提也是必须先低效率查询才可。如果插入删除发生在头尾可以减少查询次数）</p></li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>底层实现：一个长度可以动态增长的Object数组 </p><p>扩容： 容量不足时进行扩容，默认扩容50%。如果扩容50%还不足容纳新增元素，就扩容为能容纳新增元素的最小数量。</p><p>遍历： ArrayList中提供了一个内部类Itr，实现了Iterator接口，实现对集合元素的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestArrayList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个集合对象</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList();</span><br>        <span class="hljs-comment">//实例1</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//泛型</span><br>        <span class="hljs-comment">//List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-number">80</span>);<span class="hljs-comment">//末尾添加</span><br>        list.add(<span class="hljs-number">90</span>);<span class="hljs-comment">//自动填装 int ---- Integer</span><br>        list.add(<span class="hljs-number">80</span>);<br><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">//指定索引添加，底层发生大量元素后移，并且可能扩容</span><br><br>        <span class="hljs-comment">//元素的数量--list.size()</span><br>        System.out.println(list.size());<br>        <span class="hljs-comment">//获取指定索引的元素--list.get(1)</span><br>        System.out.println(list.get(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//遍历元素</span><br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        System.out.println(list.toString());<br>        <span class="hljs-comment">//方法1：for循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) list.get(i);<br>            System.out.println(i + <span class="hljs-string">&quot;---&gt;&quot;</span>+ elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法2：for-each循环</span><br>        <span class="hljs-keyword">for</span>(Object elem:list)&#123;<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法3：Iterator</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)it.next();<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法4：lambda表达式—+流式编程（JDK1。8）</span><br>        <span class="hljs-comment">//list.forEach((i)-&gt;System.out.println(i));</span><br>        list.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在代码实例1，可知添加元素时可以加入任何类型—&gt;不安全；获取元素时需要强制类型转换—&gt;繁琐；为了实现安全和简单，通过使用泛型gerneic。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="对比ArrayList"><a href="#对比ArrayList" class="headerlink" title="对比ArrayList"></a>对比ArrayList</h4><p>问题1：将ArrayList替换成LinkedList之后，不变的是什么？</p><p>（1）运算结果没有变</p><p>（2）执行的功能代码没有变</p><p>问题2：将ArrayList替换成LinkedList之后，变化的是什么？</p><p>（1）底层的结构变了</p><p>​ArrayList：数组 LinkedList：双向链表</p><p>具体的执行过程变化了 list.add(2,99)</p><p>​ArrayList：大量的后移元素 </p><p>LinkedList：不需要大量的移动元素，修改节点的指向即可</p><p>问题3：到底是使用ArrayList还是LinkedList</p><p>（1）根据使用场合而定</p><p>（2）大量的根据索引查询的操作，大量的遍历操作（按照索引0–n-1逐个查询一般），建议使用ArrayList</p><p>（3）如果存在较多的添加、删除操作，建议使用LinkedList</p><p>问题4：LinkedList增加了哪些方法</p><p>（1）增加了对添加、删除、获取首尾元素的方法</p><p>（2）addFirst()、addLast()、removeFirst()、removeLast()、getFirst()、getLast()、</p><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><ol><li>底层实现：双向链表</li><li>LinkedList实现了Deque接口，所以除了可以作为线性表来使用外，还可以当做队列和栈来使用</li><li>链表节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLinkedList1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//LinkedList&lt;Integer&gt; list = new LinkedList();</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList(100);</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        list.add(<span class="hljs-number">80</span>);<br>        list.add(<span class="hljs-number">70</span>);<br>        list.add(<span class="hljs-number">90</span>);<br>        list.remove(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//list.addAll()</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        System.out.println(list.size());<br>        System.out.println(list.isEmpty());<br>        System.out.println(list.indexOf(<span class="hljs-number">780</span>));<br>        System.out.println(list.contains(<span class="hljs-number">80</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>);<br>        System.out.println(elem);<br>        System.out.println(list);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br><br>        <span class="hljs-comment">//list.addFirst(60);</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>);<br>        <span class="hljs-comment">//list.addLast(50);</span><br>        list.add(<span class="hljs-number">50</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map：存储的键值对映射关系，根据key可以找到value</p><p>HashMap: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：key无序</p></li></ul><p>LinkedHashMap: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>key有序（添加顺序）</li></ul><p>TreeMap: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：key有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashMap快</p></li></ul><h3 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h3><p><strong>引入哈希表</strong></p><ol><li><p>在无序数组中按照内容查找，效率低下，时间复杂度是O（n） </p></li><li><p>在有序数组中按照内容查找，可以使用折半查找，时间复杂度O（log2n）</p></li><li><p>在二叉平衡树中按照内容查找，时间复杂度O（log2n）</p></li></ol><p>在数组中按照索引查找，不进行比较和计数，直接计算得到，效率最高，时间复杂度O（1）</p><ol start="4"><li>哈希表：按照内容查找，能否也不进行比较，而是通过计算得到地址，实现类似数组按照索引查询的高效率呢O（1）</li></ol><p><strong>哈希表的结构和特点</strong></p><p>hashtable 也叫散列表；特点：快  很快  神奇的快</p><p>结构：结构有多种。最流行、最容易理解：顺序表+链表</p><p>主结构：顺序表，每个顺序表的节点在单独引出一个链表</p><p><strong>哈希表是如何添加数据的</strong></p><ol><li><p>计算哈希码(调用hashCode(),结果是一个int值，整数的哈希码取自身即可)</p></li><li><p>计算在哈希表中的存储位置  y&#x3D;k(x)&#x3D;x%11</p></li></ol><p> x:哈希码  k(x) 函数y：在哈希表中的存储位置</p><ol start="3"><li>存入哈希表</li></ol><p>（1）情况1：一次添加成功</p><p>（2）情况2：多次添加成功（出现了冲突，调用equals()和对应链表的元素进行比较，比较到最后，结果都是false，创建新节点，存储数据，并加入链表末尾）</p><p>（3） 情况3：不添加（出现了冲突，调用equals()和对应链表的元素进行比较， 经过一次或者多次比较后，结果是true，表明重复，不添加）</p><p>结论1：哈希表添加数据快（3步即可，不考虑冲突）</p><p>结论2：唯一、无序</p><p><strong>哈希表是如何查询数据的</strong></p><p>  和添加数据的过程是相同的</p><p>（1）情况1：一次找到  23  86  76</p><p>（2）情况2：多次找到  67  56  78</p><p>（3）情况3：找不到  100 200</p><p> 结论1：哈希表查询数据快       </p><p><strong>hashCode和equals到底有什么神奇的作用</strong></p><p>hashCode():计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置</p><p>equals()：添加时出现了冲突，需要通过equals进行比较，判断是否相同；查询时也需要使用equals进行比较，判断是否相同  </p><p><strong>各种类型数据的哈希码应该如何获取 hashCode()</strong></p><p>int  取自身 看Integer的源码</p><ol><li><p>double  3.14 3.15  3.145  6.567  9.87  取整不可以  看Double的源码</p></li><li><p>String java  oracle  java  将各个字符的编码值相加不可以</p></li></ol><p>​     abc cba  bac  a:97  b:98  c:99</p><p>​     abc 1<em>97+2</em>98+3*99   </p><p> cba 1<em>99+2</em>98+3*97</p><p>Student 先各个属性的哈希码，进行某些相加相乘的运算</p><p>​    int id    String name      int age      double score;</p><h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><ol><li><p>哈希表的长度和表中的记录数的比例–装填因子：</p><p>如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费， 如果选取小了的话，则容易造成冲突。 在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。</p></li></ol><p>​    <strong>装填因子&#x3D;表中的记录数&#x2F;哈希表的长度， 4&#x2F; 16  &#x3D;0.25  8&#x2F; 16&#x3D;0.5</strong></p><p>​    如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。 有相关文献证明当装填因子在0.5左右时候，Hash性能能够达到最优。 </p><p><strong>因此，一般情况下，装填因子取经验值0.5</strong>。</p><ol start="2"><li>哈希函数的选择</li></ol><p>​     直接定址法   平方取中法  折叠法  <strong>除留取余法（y &#x3D; x%11）</strong></p><ol start="3"><li>处理冲突的方法</li></ol><p>​      链地址法  开放地址法  再散列法  建立一个公共溢出区</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set：无序  唯一（不重复）</p><p>HashSet: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：无序</p></li></ul><p>LinkedHashSet: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>有序（添加顺序）</li></ul><p> TreeSet: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashSet快</p></li></ul><h3 id="源码理解-2"><a href="#源码理解-2" class="headerlink" title="源码理解"></a>源码理解</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h4><p>HashSet的底层使用的是HashMap，所以底层结构也是哈希表</p><p>HashSet的元素到HashMap中做key，value统一是同一个Object()</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h4><p>TreeSet的底层使用的是TreeMap，所以底层结构也是红黑树</p><p>TreeSet的元素e是作为TreeMap的key存在的，value统一为同一个 Object()</p><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>内部比较器只能定义一个，一般将使用频率最高的比较规则定义为内部比较器的规则；外部比较器可以定义多个； </p><p>注意1：对于外部比较器，如果使用次数较少，可以通过匿名内部类来实现。</p><p>注意2：需要比较的场合才需要实现内部比较器或者外部比较器，比如排序、比如TreeSet中数据的存储和查询，在HashSet、LinkedHashSet、ArrayList中存储元素，不需要实现内部比较器或者外部比较器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashSet  哈希表  唯一  无序</p><p>LinkedHashSet  哈希表+链表  唯一 有序（添加顺序）</p><p>TreeSet  红黑树 一种二叉平衡树 唯一  有序（自然顺序）</p><p>List针对Collection增加了一些关于索引位置操作的方法 get(i) add(i,elem),remove(i),set(i,elem)</p><p>Set是无序的，不可能提供关于索引位置操作的方法，set针对Collection没有增加任何方法</p><p>List的遍历方式：for循环、for-each循环、Iterator迭代器、流式编程forEach</p><p>Set的遍历方式： for-each循环、Iterator迭代器、流式编程forEach</p><h2 id="多线程下注意事项"><a href="#多线程下注意事项" class="headerlink" title="多线程下注意事项"></a>多线程下注意事项</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector 或者 CopyOnWriteArrayList 是两个线程安全的List实现。</p><p>ArrayList 不是线程安全的。若必须使用，则需要使用Collections.synchronizedList(List list)进行包装。</p><h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>        &#125;, String.valueOf(i)).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ArrayList线程不安全主要是由它的add()方法引起的.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param e element to be appended to this list</span><br><span class="hljs-comment">     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-comment">//ArrayList的add()源码</span><br><span class="hljs-comment">//ArrayList的add()方法主要有两步，ensureCapacityInternal(size + 1);和elementData[size++] = e;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 确保容量足够，不够则进行扩容</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">// 将元素添加进列表的元素数组里面</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景一：数组越界异常 ArrayIndexOutOfBoundsException</span><br><span class="hljs-comment">单线程下是完全没有问题的，但在多线程中，有可能出现一种情况：假设当前ArrayList的长度是9（源码中ArrayList的初始容量是10），线程A、B同时执行add()方法。当线程A执行ensureCapacityInternal(size + 1);时，因为size等于9，容量为10，线程A判断不需要扩容，此时CPU调度线程B执行，同样执行ensureCapacityInternal(size + 1);，此时size还是等于9（线程A没有改变size的值），线程B也判断不需要扩容，然后线程B继续执行elementData[size++] = e;将元素e放到elementData[9]中，再执行size++并返回，此时size的值等于10。线程B执行完毕后，线程A继续往下执行elementData[size++] = e;，此时size的值是10，相当于线程A将元素e放到elementData[10]中，但ArrayList的容量也只是10（下标只有0-9）,这样就会抛出越界异常。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景二：元素值覆盖和为空问题</span><br><span class="hljs-comment">这个场景主要是与elementData[size++] = e;这句代码有关，因为它不是一个原子操作，有可能被其他线程中断，这句代码至少分为两步：</span><br><span class="hljs-comment">elementData[size] = e；</span><br><span class="hljs-comment">size = size + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">当多线程执行这段代码时，有可能出现这种场景：假设当前size=1，线程A、B执行这段代码，线程A执行elementData[size] = e；后，e被放在elementData[1]中，此时线程A中断，CPU调度线程B，线程B执行elementData[size] = e；，此时size的值还是1（线程A没来得及执行size+1操作就被中断），所以线程B还是把元素放在elementData[1]中，覆盖了线程A已经存放的值，然后对size进行+1操作并返回，此时size=2。线程B执行完后，CPU调度线程A继续执行，线程A对size+1，此时size就变成3。最终，两个线程执行完后，期待的结果是elementData[1]、elementData[2]各有一个元素，现在却是两个线程都把元素放在elementData[1]上，且线程B覆盖了线程A的元素，而elementData[2]为null。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>1.使用Vector（ArrayList所有方法加synchronized，太重）。</p><p>2.使用Collections.synchronizedList()转换成线程安全类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>    ...<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// 必须在同步块中</span><br>    <span class="hljs-keyword">while</span> (i.hasNext())<br>        foo(i.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>3.使用java.concurrent.CopyOnWriteArrayList（推荐）。</p><p> <strong>CopyOnWriteArrayList</strong>：JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。如add()方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//得到旧数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//复制新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//设置新元素</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">//设置新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 优点：CopyOnWriteArrayList属于线程安全的，并发的读是没有异常的，读写操作被分离。缺点：在写入时不止加锁，使用了Arrays.copyOf()进行了数组复制，性能开销较大，遇到复杂对象也会导致内存占用较大。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet和TreeSet都不是线程安全的，对应的有线程安全类CopyOnWriteSet这个线程安全类，类底层维护了一个CopyOnWriteArrayList数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArraySet</span><span class="hljs-params">()</span> &#123;<br>    al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;E&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p>HashMap不是线程安全的，Hashtable是线程安全的，但是跟Vector类似，太重量级。所以也有类似CopyOnWriteMap，叫ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerNotSafeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        listNotSafe();<br>        setNoSafe();<br>        mapNotSafe();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mapNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Map&lt;String,String&gt; map=new HashMap&lt;&gt;();</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + map);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNoSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Set&lt;String&gt; set=new HashSet&lt;&gt;();</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + set);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_39240837/article/details/108006486">Java中的Set、Map、List等数据结构的存取以及基本使用</a></p><p><a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=49">黑马程序员Java数据结构与算法，全网资料最全，154张数据结构图</a></p><p><a href="https://github.com/CarpenterLee/JCFInternals">Java Collections Framework Internals</a></p><p><a href="https://blog.csdn.net/luweibin19/article/details/106215036/">JAVA list、set、map等集合类线程不安全的问题及解决方法</a></p><p><a href="https://blog.csdn.net/weixin_43932465/article/details/103006622">java多线程环境下数据结构的安全问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java踩坑小记</title>
    <link href="/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>迭代器Iterator在遍历时能remove但是不能往集合里添加元素问题。我们都知道如果是像List集合这样的，如果用循环遍历，访问没问题，在这期间如果删除就会报错，这个问题是因为你改变了集合的长度，但是遍历用的原来的长度的原因，</p><p>所以Iterator优秀点就出现了，它的出现让你可以在遍历时删除你想删除的元素，它用while循环遍历，它往下循环也就是while里的判定条件是Iterator.hasNext() 返回的是boolean类型，看这个也明白，它是在你想继续往下遍历时先查询是否存在下一个元素。</p><p>而且集合转Iterator也不麻烦，集合本身就有这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Iterator&lt;泛型&gt; it = 集合.iterator();<br></code></pre></td></tr></table></figure><p>敲黑板 下面要讲两点重要的还容易忘的误区</p><p>如果在遍历时删除元素不要用集合的 remove() 方法，要用迭代器的 iterator.remove() 方法，虽然没有参数，但是它移除的是当前的。 在用迭代器迭代的时候千万不要修改集合和给集合添加元素，这样会报错，因为你迭代时添加元素会破坏迭代器的结构，所以会报错，因为拿ArrayList为例，在遍历到中间的时候，你往集合头部插入元素，集合的结构肯定变吧，那迭代器的数据结构也会跟着变，它就会主动报错，，但是删除就没问题了，因为你用的是迭代器的删除方法，而迭代器没有添加元素的方法</p><p>参考链接：<a href="https://blog.csdn.net/weixin_43113679/article/details/99775014">https://blog.csdn.net/weixin_43113679/article/details/99775014</a></p><h2 id="HashMap未覆写Hash算法"><a href="#HashMap未覆写Hash算法" class="headerlink" title="HashMap未覆写Hash算法"></a>HashMap未覆写Hash算法</h2><p>HashMap以其元素唯一性为开发人员所青睐，然后当元素类型是自定义类型时，需要覆写自定义对象的hashcode和equals方法，否则将无法保证元素唯一。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shuffle 算法</title>
    <link href="/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>其中一种常见的洗牌算法是Fisher-Yates洗牌算法，我将用它来描述原理，并给出Java实现。</p><p><strong>Fisher-Yates洗牌算法原理：</strong></p><ol><li>从数组中最后一个元素开始，从后往前遍历每个元素。</li><li>对于当前遍历到的元素，随机生成一个不超过当前下标的随机数（假设为randIdx）。</li><li>将当前元素与数组中下标为randIdx的元素交换位置，将当前元素放到一个随机位置。</li><li>继续遍历上一个位置的元素，重复步骤2至步骤3，直到第一个元素被处理。</li></ol><p><strong>Fisher-Yates洗牌算法时间复杂度和空间复杂度：</strong></p><p>时间复杂度：洗牌算法的时间复杂度是O(n)，其中n为数组或集合中的元素数量。因为每个元素都需要进行随机交换，而总的交换次数是n次。</p><p>空间复杂度：洗牌算法的空间复杂度是O(1)，因为算法在原地对数组或集合进行交换，没有使用额外的数据结构。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShuffleAlgorithm</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randIdx</span> <span class="hljs-operator">=</span> random.nextInt(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成[0, i]之间的随机数</span><br>            swap(array, i, randIdx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        shuffle(nums);<br>        System.out.println(<span class="hljs-string">&quot;Shuffled array: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>贪心:找到该点到所有点的最短路径</strong></p><p>俩个集合, 一个(dis)是源点到当前该点的最短路径,一个(visited)是源点到该点是否已经找到最短路径; 初始时设定dis[] &#x3D; INT_MAX, dis[start] &#x3D; 0,后续需要比较是否可以找到比当前dis[i]小的值 每轮循环分别找到当前未被访问的点中到源点最短距离的点,加入visited集合中 每轮循环更新dis集合,根据确定的minpos,找到未被访问的点,且小于dis[minpos]+adj[minpos][i]时更新;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 邻接矩阵-无向图</span><br><span class="hljs-comment">// adj[i][j] == 0 表示 i j 不相邻</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj = &#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>&#125;, <br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 基于邻接矩阵dijkstra求解最短路</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, <span class="hljs-type">int</span>&amp; start, <span class="hljs-type">int</span>&amp; end, vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = adj.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(start &gt;= n || start &lt; <span class="hljs-number">0</span> || end &gt;= n || end &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n, INT_MAX)</span></span>;    <span class="hljs-comment">// 当前点到源点的最短距离</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 访问集合</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;       <span class="hljs-comment">// 当前点最短路径的前一节点</span><br><br>    dis[start] = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 保证初始查找点为源点start</span><br>    pre[start] = start;          <span class="hljs-comment">// 设置源点的prepos为start</span><br><br>    <span class="hljs-keyword">for</span>(;;)<br>    &#123;<br>        <span class="hljs-type">int</span> mindis = INT_MAX;<br>        <span class="hljs-type">int</span> minpos = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 找到本轮查找的初始点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; dis[i] &lt; mindis)<br>            &#123;<br>                mindis = dis[i];<br>                minpos = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不存在邻接路径</span><br>        <span class="hljs-keyword">if</span>(minpos == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        visited[minpos] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果终点在确认集合中，则退出查找,保存路径</span><br>        <span class="hljs-keyword">if</span>(visited[end])<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = end;<br>            path.<span class="hljs-built_in">push_back</span>(end);<br>            <span class="hljs-keyword">while</span>(pre[tmp] != start &amp;&amp; pre[tmp] != <span class="hljs-number">-1</span>)<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(pre[tmp]);<br>                tmp = pre[tmp];<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(start);<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; adj[minpos][j] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j] &gt; dis[minpos] + adj[minpos][j])<br>                &#123;<br>                    dis[j] = dis[minpos] + adj[minpos][j];<br>                    pre[j] = minpos;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dis[end];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printpath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i != path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;      <br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> start, end;<br>    cin &gt;&gt; start &gt;&gt; end;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">int</span> mindis = <span class="hljs-built_in">dijkstra</span>(adj, start, end, path);<br>    cout &lt;&lt; mindis &lt;&lt; endl;<br>    <span class="hljs-built_in">printpath</span>(path);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A* 算法</title>
    <link href="/2023/10/24/A-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/A-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>A*算法是一种常用于图形搜索和路径规划的启发式搜索算法。它通过综合考虑实际代价和估计代价，来寻找从起点到目标节点的最优路径。</p><p>算法步骤：</p><ol><li>创建两个空列表：Open列表和Closed列表。</li><li>将起点添加到Open列表。</li><li>重复以下步骤，直到找到目标节点或Open列表为空： a. 从Open列表中选择估计代价最小的节点，将其移动到Closed列表。 b. 遍历该节点的相邻节点：<ul><li>如果相邻节点已经在Closed列表中，跳过它。</li><li>如果相邻节点不在Open列表中，计算其实际代价（从起点到当前节点的代价）和估计代价（从当前节点到目标节点的估计代价），并将其添加到Open列表。</li><li>如果相邻节点已经在Open列表中，检查经过当前节点到达该相邻节点的路径是否更优，如果更优，则更新其实际代价和父节点。</li></ul></li><li>如果Open列表为空，表示没有找到目标节点，搜索失败；否则，从目标节点开始，沿着父节点指针一直回溯到起点，即可得到最优路径。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> g; <span class="hljs-comment">// Actual cost from start node to this node</span><br>    <span class="hljs-type">int</span> h; <span class="hljs-comment">// Heuristic cost from this node to the goal node</span><br>    <span class="hljs-type">int</span> f; <span class="hljs-comment">// f = g + h</span><br>    Node parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.g = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.h = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.f = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AStarAlgorithm</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] grid; <span class="hljs-comment">// 2D array representing the map/grid</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cols;<br>    <span class="hljs-keyword">private</span> Node startNode;<br>    <span class="hljs-keyword">private</span> Node goalNode;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; openList;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; closedList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AStarAlgorithm</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY, <span class="hljs-type">int</span> goalX, <span class="hljs-type">int</span> goalY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.rows = grid.length;<br>        <span class="hljs-built_in">this</span>.cols = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.startNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(startX, startY);<br>        <span class="hljs-built_in">this</span>.goalNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(goalX, goalY);<br>        <span class="hljs-built_in">this</span>.openList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.closedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">findPath</span><span class="hljs-params">()</span> &#123;<br>        openList.add(startNode);<br><br>        <span class="hljs-keyword">while</span> (!openList.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> findLowestFInOpenList();<br>            openList.remove(current);<br>            closedList.add(current);<br><br>            <span class="hljs-keyword">if</span> (current.x == goalNode.x &amp;&amp; current.y == goalNode.y) &#123;<br>                <span class="hljs-keyword">return</span> reconstructPath(current);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip current node</span><br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborX</span> <span class="hljs-operator">=</span> current.x + i;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborY</span> <span class="hljs-operator">=</span> current.y + j;<br><br>                    <span class="hljs-keyword">if</span> (neighborX &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborX &lt; rows &amp;&amp; neighborY &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborY &lt; cols) &#123;<br>                        <span class="hljs-keyword">if</span> (grid[neighborX][neighborY] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip obstacles</span><br><br>                        <span class="hljs-type">Node</span> <span class="hljs-variable">neighbor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(neighborX, neighborY);<br>                        <span class="hljs-keyword">if</span> (closedList.contains(neighbor)) <span class="hljs-keyword">continue</span>;<br><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">tentativeG</span> <span class="hljs-operator">=</span> current.g + <span class="hljs-number">1</span>; <span class="hljs-comment">// Assuming each move has a cost of 1 (can be modified for different costs)</span><br><br>                        <span class="hljs-keyword">if</span> (!openList.contains(neighbor) || tentativeG &lt; neighbor.g) &#123;<br>                            neighbor.parent = current;<br>                            neighbor.g = tentativeG;<br>                            neighbor.h = calculateHeuristic(neighbor);<br>                            neighbor.f = neighbor.g + neighbor.h;<br><br>                            <span class="hljs-keyword">if</span> (!openList.contains(neighbor)) &#123;<br>                                openList.add(neighbor);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Path not found</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLowestFInOpenList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> openList.stream().min(Comparator.comparingInt(node -&gt; node.f)).orElse(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateHeuristic</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// Here, we can use any heuristic function (e.g., Manhattan distance, Euclidean distance, etc.)</span><br>        <span class="hljs-keyword">return</span> Math.abs(node.x - goalNode.x) + Math.abs(node.y - goalNode.y);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title function_">reconstructPath</span><span class="hljs-params">(Node current)</span> &#123;<br>        List&lt;Node&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            path.add(<span class="hljs-number">0</span>, current);<br>            current = current.parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startY</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalX</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalY</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-type">AStarAlgorithm</span> <span class="hljs-variable">aStar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AStarAlgorithm</span>(grid, startX, startY, goalX, goalY);<br>        List&lt;Node&gt; path = aStar.findPath();<br><br>        <span class="hljs-keyword">if</span> (path != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Node node : path) &#123;<br>                System.out.println(<span class="hljs-string">&quot;(&quot;</span> + node.x + <span class="hljs-string">&quot;, &quot;</span> + node.y + <span class="hljs-string">&quot;)&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Path not found!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>。</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p>Mac 用户</p><p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><blockquote><p>Windows 用户</p><p>对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p></blockquote><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/zh-cn/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npmmirror.com/mirrors/node/">淘宝 Node.js 镜像</a> 下载。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB&#x2F;RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/zh-cn/download/package-manager/">指导</a>。</li></ul><p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>)</p><blockquote><p>Windows 用户</p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p></blockquote><blockquote><p>For Mac &#x2F; Linux 用户</p><p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p></blockquote><blockquote><p>Linux</p><p>如果您使用 Snap 来安装 Node.js，在 <a href="https://hexo.io/zh-cn/docs/commands#init">初始化</a> 博客时您可能需要手动在目标文件夹中执行 <code>npm install</code>。</p></blockquote><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#windows下注意安装之后，需要重新打开新的命令行窗口</span><br>git --<span class="hljs-keyword">version</span><br><span class="hljs-keyword">node</span> <span class="hljs-title">--version</span><br>npm --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><h2 id="流程搭建"><a href="#流程搭建" class="headerlink" title="流程搭建"></a>流程搭建</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>新建一个文件夹，存放博客文件，如取名为&#x2F;blog</p><p>在&#x2F;blog文件夹下安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-cli -g<br></code></pre></td></tr></table></figure><p>验证hexo是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>初始化文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>安装必备组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm installs<br></code></pre></td></tr></table></figure><p>生成静态网页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><h3 id="github远程部署"><a href="#github远程部署" class="headerlink" title="github远程部署"></a>github远程部署</h3><p>新建一个远程仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/username/u</span>sername.github.io.git<br></code></pre></td></tr></table></figure><p>配置&#x2F;blog下的_config.yaml中</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/username/username.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p>远程部署</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> your-hexo-site</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></code></pre></td></tr></table></figure><p>启用主题</p><p>与所有 Hexo 主题启用的模式一样。 当 克隆&#x2F;下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">theme:</span> <span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>验证主题</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><p>配置主题配置文件</p><h2 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h2><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><h3 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h3><p>新建一个branch并设置为默认分支,比如新分支叫hexo</p><p>克隆github仓库到本地，将原来的博客根目录下的文件拷贝过来（除.deploy_git, node_modules&#x2F;, public&#x2F;），</p><p>确认.gitignore内容</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></td></tr></table></figure><p>push源文件到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;add branch&quot;<br>git push<br></code></pre></td></tr></table></figure><p>在当前文件夹安装hexo，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>hexo -v ## 验证下是否安装成功<br>npm install<br></code></pre></td></tr></table></figure><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li>npm install -g hexo-cli 异常</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ npm install -<span class="hljs-keyword">g</span> hexo-<span class="hljs-keyword">cli</span><br>npm <span class="hljs-keyword">ERR</span>! code EEXIST<br>npm <span class="hljs-keyword">ERR</span>! path C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! EEXIST: <span class="hljs-keyword">file</span> already exists<br>npm <span class="hljs-keyword">ERR</span>! <span class="hljs-keyword">File</span> exists: C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! Remove the existing <span class="hljs-keyword">file</span> and try again, or <span class="hljs-keyword">run</span> npm<br>npm <span class="hljs-keyword">ERR</span>! with --force to overwrite files recklessly.<br><br>npm <span class="hljs-keyword">ERR</span>! A complete <span class="hljs-keyword">log</span> of this <span class="hljs-keyword">run</span> can be found <span class="hljs-keyword">in</span>:<br>npm <span class="hljs-keyword">ERR</span>!     C:\Users\Administrator\AppData\<span class="hljs-keyword">Local</span>\npm-cache\_logs\2023-10-24T05_13_02_159Z-debug-0.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p>这是由于之前可能装过hexo，需要在npm的appdata中删除原有的hexo modules</p><ul><li>hexo主题切换导致乱码</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&#123;% extends <span class="hljs-string">&#x27;_layout.swig&#x27;</span> %&#125; &#123;% <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;_macro/post.swig&#x27;</span> as post_template %&#125;<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..<br></code></pre></td></tr></table></figure><p>hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>重新生成</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean          <br>hexo <span class="hljs-keyword">generate</span>      <br>hexo server<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">github+hexo搭建个人博客</a></p><p><a href="https://www.cnblogs.com/lanhualan/p/14588669.html">hexo主题切换乱码问题解决</a></p><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E5%88%9B%E5%BB%BA%E3%80%8C%E5%85%B3%E4%BA%8E%E9%A1%B5%E3%80%8D">fluid主题配置</a></p><p><a href="https://dora-cmon.github.io/posts/454ba26/">hexo跨平台搭建</a></p>]]></content>
    
    
    <categories>
      
      <category>运维部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
