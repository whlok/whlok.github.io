---
title: Redis内存管理分析
date: 2023-10-26 09:26:52
categories: 缓存
hide: true
tags: Redis
---

## 内存分配

**分配器**：Redis使用了自己的内存分配器，称为jemalloc。jemalloc是一个高效的内存分配器，专门为多线程应用程序设计。它能够有效地管理内存碎片，并提供了高性能的内存分配和释放操作。 

**分配策略**：Redis使用了两种主要的内存分配策略，即slab分配和字符串分配。 

Slab分配：Redis使用了一种称为slab分配器的机制来管理内存。它将内存空间划分为多个大小相等的slab（内存页），每个slab可以存储相同大小的数据结构。当需要分配内存时，Redis会选择一个合适大小的slab，并将其分配给请求的数据结构。这种方式减少了内存碎片化，并提高了内存利用率。 

字符串分配：Redis还使用了一种称为字符串分配器的机制来管理较小的字符串对象。这种分配器使用了一种更简单的内存分配方式，以减少内存碎片化的影响。 

## 内存优化

Redis提供了一些内存优化的选项，以减少内存使用量。

**压缩**：Redis可以使用压缩算法来减小存储在内存中的数据的大小。这可以在一定程度上减少内存使用量。     - 数据结构优化：Redis提供了多种数据结构，如哈希表、有序集合等。选择合适的数据结构可以减少内存使用量，并提高性能



## 内存回收

Redis使用了多种方式来回收不再使用的内存。 

**过期键处理**：当键的过期时间到达时，Redis会自动删除该键，并释放其占用的内存空间。     

**内存淘汰**：当Redis的内存达到配置的最大限制时，它会根据一定的策略选择一些键进行淘汰，以释放内存空间。常见的淘汰策略包括LRU（最近最少使用）和LFU（最不常用）。 

Redis支持8种不同策略来选择要删除的key：

* noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。
* volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰
* allkeys-random：对全体key ，随机进行淘汰。也就是直接从db->dict中随机挑选
* volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db->expires中随机挑选。
* allkeys-lru： 对全体key，基于LRU算法进行淘汰
* volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰
* allkeys-lfu： 对全体key，基于LFU算法进行淘汰
* volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰
  比较容易混淆的有两个：
  * LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
  * LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。

Redis的数据都会被封装为RedisObject结构：

![1653984029506](E:/BaiduNetdiskDownload/7、Redis入门到实战教程/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984029506.png)

LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：

* 生成0~1之间的随机数R
* 计算 (旧次数 * lfu_log_factor + 1)，记录为P
* 如果 R < P ，则计数器 + 1，且最大不超过255
* 访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1

最后用一副图来描述当前的这个流程吧

![1653984085095](E:/BaiduNetdiskDownload/7、Redis入门到实战教程/Redis-笔记资料/04-原理篇/讲义/原理篇.assets/1653984085095.png)

## 内存监控





## 内存持久化

