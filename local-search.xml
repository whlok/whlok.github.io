<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p> java中的集合包括三大类，它们是Set、List和Map。它们都处于java.util包中，Set、List和Map都是接口。 本文参考源码为 jdk1.7u79。开始之前，先简单描述下类之间的关系，方便后续看类图。</p><table><thead><tr><th>集合架构</th><th>特性</th></tr></thead><tbody><tr><td>Collection</td><td>接口存储一组不唯一，无序的对象</td></tr><tr><td>List</td><td>接口存储一组不唯一，有序（索引顺序）的对象</td></tr><tr><td>Set</td><td>接口存储一组唯一，无序的对象</td></tr><tr><td>Map</td><td>接口存储一组键值对象，提供key到value的映射Key 唯一 无序；value  不唯一 无序</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">继承关系    —▷    实线 + 空心三角形    鸟 —▷ 动物；鸟继承动物<br>实现接口    •••▷    虚线 + 空心三角形    大雁 •••▷ 飞翔；大雁实现了飞翔接口<br>实现接口    —○    棒棒糖表示法    唐老鸭 —○ 讲人话；唐老鸭实现讲人话接口<br>关联关系    —&gt;    实线剪头    企鹅 —&gt; 气候；企鹅需要‘知道’气候的变化<br>依赖关系    •••&gt;    虚线剪头    动物 •••&gt; 氧气；动物依赖于氧气<br>聚合关系    ◇—&gt;    空心菱形 + 实线剪头    大雁 ◇—&gt; 翅膀；部分和整体的关系<br>合成关系    ◆—&gt;    实心菱形 + 实线剪头    大雁 ◆—&gt; 雁群；<span class="hljs-selector-tag">A</span>包含<span class="hljs-selector-tag">B</span>，但<span class="hljs-selector-tag">B</span>不是<span class="hljs-selector-tag">A</span>的一部分<br></code></pre></td></tr></table></figure><h2 id="接口继承树"><a href="#接口继承树" class="headerlink" title="接口继承树"></a>接口继承树</h2><p>&#x2F;&#x2F; Todo: 待补充</p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>List：有序  不唯一（可重复）</p><p>ArrayList：在内存中分配连续的空间，实现了长度可变的数组</p><ul><li><p>优点：遍历元素和随机访问元素的效率比较高</p></li><li><p>缺点：添加和删除需大量移动元素效率低，按照内容查询效率低</p></li></ul><p>LinkedList：采用双向链表存储方式。</p><ul><li><p>缺点：遍历和随机访问元素效率低下</p></li><li><p>优点：插入、删除元素效率比较高（但是前提也是必须先低效率查询才可。如果插入删除发生在头尾可以减少查询次数）</p></li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>底层实现：一个长度可以动态增长的Object数组 </p><p>扩容： 容量不足时进行扩容，默认扩容50%。如果扩容50%还不足容纳新增元素，就扩容为能容纳新增元素的最小数量。</p><p>遍历： ArrayList中提供了一个内部类Itr，实现了Iterator接口，实现对集合元素的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestArrayList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个集合对象</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList();</span><br>        <span class="hljs-comment">//实例1</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//泛型</span><br>        <span class="hljs-comment">//List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-number">80</span>);<span class="hljs-comment">//末尾添加</span><br>        list.add(<span class="hljs-number">90</span>);<span class="hljs-comment">//自动填装 int ---- Integer</span><br>        list.add(<span class="hljs-number">80</span>);<br><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">//指定索引添加，底层发生大量元素后移，并且可能扩容</span><br><br>        <span class="hljs-comment">//元素的数量--list.size()</span><br>        System.out.println(list.size());<br>        <span class="hljs-comment">//获取指定索引的元素--list.get(1)</span><br>        System.out.println(list.get(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//遍历元素</span><br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        System.out.println(list.toString());<br>        <span class="hljs-comment">//方法1：for循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) list.get(i);<br>            System.out.println(i + <span class="hljs-string">&quot;---&gt;&quot;</span>+ elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法2：for-each循环</span><br>        <span class="hljs-keyword">for</span>(Object elem:list)&#123;<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法3：Iterator</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)it.next();<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法4：lambda表达式—+流式编程（JDK1。8）</span><br>        <span class="hljs-comment">//list.forEach((i)-&gt;System.out.println(i));</span><br>        list.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在代码实例1，可知添加元素时可以加入任何类型—&gt;不安全；获取元素时需要强制类型转换—&gt;繁琐；为了实现安全和简单，通过使用泛型gerneic。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="对比ArrayList"><a href="#对比ArrayList" class="headerlink" title="对比ArrayList"></a>对比ArrayList</h4><p>问题1：将ArrayList替换成LinkedList之后，不变的是什么？</p><p>（1）运算结果没有变</p><p>（2）执行的功能代码没有变</p><p>问题2：将ArrayList替换成LinkedList之后，变化的是什么？</p><p>（1）底层的结构变了</p><p>​ArrayList：数组 LinkedList：双向链表</p><p>具体的执行过程变化了 list.add(2,99)</p><p>​ArrayList：大量的后移元素 </p><p>LinkedList：不需要大量的移动元素，修改节点的指向即可</p><p>问题3：到底是使用ArrayList还是LinkedList</p><p>（1）根据使用场合而定</p><p>（2）大量的根据索引查询的操作，大量的遍历操作（按照索引0–n-1逐个查询一般），建议使用ArrayList</p><p>（3）如果存在较多的添加、删除操作，建议使用LinkedList</p><p>问题4：LinkedList增加了哪些方法</p><p>（1）增加了对添加、删除、获取首尾元素的方法</p><p>（2）addFirst()、addLast()、removeFirst()、removeLast()、getFirst()、getLast()、</p><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><ol><li>底层实现：双向链表</li><li>LinkedList实现了Deque接口，所以除了可以作为线性表来使用外，还可以当做队列和栈来使用</li><li>链表节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLinkedList1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//LinkedList&lt;Integer&gt; list = new LinkedList();</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList(100);</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        list.add(<span class="hljs-number">80</span>);<br>        list.add(<span class="hljs-number">70</span>);<br>        list.add(<span class="hljs-number">90</span>);<br>        list.remove(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//list.addAll()</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        System.out.println(list.size());<br>        System.out.println(list.isEmpty());<br>        System.out.println(list.indexOf(<span class="hljs-number">780</span>));<br>        System.out.println(list.contains(<span class="hljs-number">80</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>);<br>        System.out.println(elem);<br>        System.out.println(list);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br><br>        <span class="hljs-comment">//list.addFirst(60);</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>);<br>        <span class="hljs-comment">//list.addLast(50);</span><br>        list.add(<span class="hljs-number">50</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map：存储的键值对映射关系，根据key可以找到value</p><p>HashMap: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：key无序</p></li></ul><p>LinkedHashMap: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>key有序（添加顺序）</li></ul><p>TreeMap: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：key有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashMap快</p></li></ul><h3 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h3><p><strong>引入哈希表</strong></p><ol><li><p>在无序数组中按照内容查找，效率低下，时间复杂度是O（n） </p></li><li><p>在有序数组中按照内容查找，可以使用折半查找，时间复杂度O（log2n）</p></li><li><p>在二叉平衡树中按照内容查找，时间复杂度O（log2n）</p></li></ol><p>在数组中按照索引查找，不进行比较和计数，直接计算得到，效率最高，时间复杂度O（1）</p><ol start="4"><li>哈希表：按照内容查找，能否也不进行比较，而是通过计算得到地址，实现类似数组按照索引查询的高效率呢O（1）</li></ol><p><strong>哈希表的结构和特点</strong></p><p>hashtable 也叫散列表；特点：快  很快  神奇的快</p><p>结构：结构有多种。最流行、最容易理解：顺序表+链表</p><p>主结构：顺序表，每个顺序表的节点在单独引出一个链表</p><p><strong>哈希表是如何添加数据的</strong></p><ol><li><p>计算哈希码(调用hashCode(),结果是一个int值，整数的哈希码取自身即可)</p></li><li><p>计算在哈希表中的存储位置  y&#x3D;k(x)&#x3D;x%11</p></li></ol><p> x:哈希码  k(x) 函数y：在哈希表中的存储位置</p><ol start="3"><li>存入哈希表</li></ol><p>（1）情况1：一次添加成功</p><p>（2）情况2：多次添加成功（出现了冲突，调用equals()和对应链表的元素进行比较，比较到最后，结果都是false，创建新节点，存储数据，并加入链表末尾）</p><p>（3） 情况3：不添加（出现了冲突，调用equals()和对应链表的元素进行比较， 经过一次或者多次比较后，结果是true，表明重复，不添加）</p><p>结论1：哈希表添加数据快（3步即可，不考虑冲突）</p><p>结论2：唯一、无序</p><p><strong>哈希表是如何查询数据的</strong></p><p>  和添加数据的过程是相同的</p><p>（1）情况1：一次找到  23  86  76</p><p>（2）情况2：多次找到  67  56  78</p><p>（3）情况3：找不到  100 200</p><p> 结论1：哈希表查询数据快       </p><p><strong>hashCode和equals到底有什么神奇的作用</strong></p><p>hashCode():计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置</p><p>equals()：添加时出现了冲突，需要通过equals进行比较，判断是否相同；查询时也需要使用equals进行比较，判断是否相同  </p><p><strong>各种类型数据的哈希码应该如何获取 hashCode()</strong></p><p>int  取自身 看Integer的源码</p><ol><li><p>double  3.14 3.15  3.145  6.567  9.87  取整不可以  看Double的源码</p></li><li><p>String java  oracle  java  将各个字符的编码值相加不可以</p></li></ol><p>​     abc cba  bac  a:97  b:98  c:99</p><p>​     abc 1<em>97+2</em>98+3*99   </p><p> cba 1<em>99+2</em>98+3*97</p><p>Student 先各个属性的哈希码，进行某些相加相乘的运算</p><p>​    int id    String name      int age      double score;</p><h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><ol><li><p>哈希表的长度和表中的记录数的比例–装填因子：</p><p>如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费， 如果选取小了的话，则容易造成冲突。 在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。</p></li></ol><p>​    <strong>装填因子&#x3D;表中的记录数&#x2F;哈希表的长度， 4&#x2F; 16  &#x3D;0.25  8&#x2F; 16&#x3D;0.5</strong></p><p>​    如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。 有相关文献证明当装填因子在0.5左右时候，Hash性能能够达到最优。 </p><p><strong>因此，一般情况下，装填因子取经验值0.5</strong>。</p><ol start="2"><li>哈希函数的选择</li></ol><p>​     直接定址法   平方取中法  折叠法  <strong>除留取余法（y &#x3D; x%11）</strong></p><ol start="3"><li>处理冲突的方法</li></ol><p>​      链地址法  开放地址法  再散列法  建立一个公共溢出区</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set：无序  唯一（不重复）</p><p>HashSet: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：无序</p></li></ul><p>LinkedHashSet: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>有序（添加顺序）</li></ul><p> TreeSet: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashSet快</p></li></ul><h3 id="源码理解-2"><a href="#源码理解-2" class="headerlink" title="源码理解"></a>源码理解</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h4><p>HashSet的底层使用的是HashMap，所以底层结构也是哈希表</p><p>HashSet的元素到HashMap中做key，value统一是同一个Object()</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h4><p>TreeSet的底层使用的是TreeMap，所以底层结构也是红黑树</p><p>TreeSet的元素e是作为TreeMap的key存在的，value统一为同一个 Object()</p><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>内部比较器只能定义一个，一般将使用频率最高的比较规则定义为内部比较器的规则；外部比较器可以定义多个； </p><p>注意1：对于外部比较器，如果使用次数较少，可以通过匿名内部类来实现。</p><p>注意2：需要比较的场合才需要实现内部比较器或者外部比较器，比如排序、比如TreeSet中数据的存储和查询，在HashSet、LinkedHashSet、ArrayList中存储元素，不需要实现内部比较器或者外部比较器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashSet  哈希表  唯一  无序</p><p>LinkedHashSet  哈希表+链表  唯一 有序（添加顺序）</p><p>TreeSet  红黑树 一种二叉平衡树 唯一  有序（自然顺序）</p><p>List针对Collection增加了一些关于索引位置操作的方法 get(i) add(i,elem),remove(i),set(i,elem)</p><p>Set是无序的，不可能提供关于索引位置操作的方法，set针对Collection没有增加任何方法</p><p>List的遍历方式：for循环、for-each循环、Iterator迭代器、流式编程forEach</p><p>Set的遍历方式： for-each循环、Iterator迭代器、流式编程forEach</p><h2 id="多线程下注意事项"><a href="#多线程下注意事项" class="headerlink" title="多线程下注意事项"></a>多线程下注意事项</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector 或者 CopyOnWriteArrayList 是两个线程安全的List实现。</p><p>ArrayList 不是线程安全的。若必须使用，则需要使用Collections.synchronizedList(List list)进行包装。</p><h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>        &#125;, String.valueOf(i)).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ArrayList线程不安全主要是由它的add()方法引起的.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param e element to be appended to this list</span><br><span class="hljs-comment">     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-comment">//ArrayList的add()源码</span><br><span class="hljs-comment">//ArrayList的add()方法主要有两步，ensureCapacityInternal(size + 1);和elementData[size++] = e;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 确保容量足够，不够则进行扩容</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">// 将元素添加进列表的元素数组里面</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景一：数组越界异常 ArrayIndexOutOfBoundsException</span><br><span class="hljs-comment">单线程下是完全没有问题的，但在多线程中，有可能出现一种情况：假设当前ArrayList的长度是9（源码中ArrayList的初始容量是10），线程A、B同时执行add()方法。当线程A执行ensureCapacityInternal(size + 1);时，因为size等于9，容量为10，线程A判断不需要扩容，此时CPU调度线程B执行，同样执行ensureCapacityInternal(size + 1);，此时size还是等于9（线程A没有改变size的值），线程B也判断不需要扩容，然后线程B继续执行elementData[size++] = e;将元素e放到elementData[9]中，再执行size++并返回，此时size的值等于10。线程B执行完毕后，线程A继续往下执行elementData[size++] = e;，此时size的值是10，相当于线程A将元素e放到elementData[10]中，但ArrayList的容量也只是10（下标只有0-9）,这样就会抛出越界异常。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景二：元素值覆盖和为空问题</span><br><span class="hljs-comment">这个场景主要是与elementData[size++] = e;这句代码有关，因为它不是一个原子操作，有可能被其他线程中断，这句代码至少分为两步：</span><br><span class="hljs-comment">elementData[size] = e；</span><br><span class="hljs-comment">size = size + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">当多线程执行这段代码时，有可能出现这种场景：假设当前size=1，线程A、B执行这段代码，线程A执行elementData[size] = e；后，e被放在elementData[1]中，此时线程A中断，CPU调度线程B，线程B执行elementData[size] = e；，此时size的值还是1（线程A没来得及执行size+1操作就被中断），所以线程B还是把元素放在elementData[1]中，覆盖了线程A已经存放的值，然后对size进行+1操作并返回，此时size=2。线程B执行完后，CPU调度线程A继续执行，线程A对size+1，此时size就变成3。最终，两个线程执行完后，期待的结果是elementData[1]、elementData[2]各有一个元素，现在却是两个线程都把元素放在elementData[1]上，且线程B覆盖了线程A的元素，而elementData[2]为null。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>1.使用Vector（ArrayList所有方法加synchronized，太重）。</p><p>2.使用Collections.synchronizedList()转换成线程安全类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>    ...<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// 必须在同步块中</span><br>    <span class="hljs-keyword">while</span> (i.hasNext())<br>        foo(i.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>3.使用java.concurrent.CopyOnWriteArrayList（推荐）。</p><p> <strong>CopyOnWriteArrayList</strong>：JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。如add()方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//得到旧数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//复制新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//设置新元素</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">//设置新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 优点：CopyOnWriteArrayList属于线程安全的，并发的读是没有异常的，读写操作被分离。缺点：在写入时不止加锁，使用了Arrays.copyOf()进行了数组复制，性能开销较大，遇到复杂对象也会导致内存占用较大。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet和TreeSet都不是线程安全的，对应的有线程安全类CopyOnWriteSet这个线程安全类，类底层维护了一个CopyOnWriteArrayList数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArraySet</span><span class="hljs-params">()</span> &#123;<br>    al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;E&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p>HashMap不是线程安全的，Hashtable是线程安全的，但是跟Vector类似，太重量级。所以也有类似CopyOnWriteMap，叫ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerNotSafeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        listNotSafe();<br>        setNoSafe();<br>        mapNotSafe();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mapNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Map&lt;String,String&gt; map=new HashMap&lt;&gt;();</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + map);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNoSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Set&lt;String&gt; set=new HashSet&lt;&gt;();</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + set);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_39240837/article/details/108006486">Java中的Set、Map、List等数据结构的存取以及基本使用</a></p><p><a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=49">黑马程序员Java数据结构与算法，全网资料最全，154张数据结构图</a></p><p><a href="https://github.com/CarpenterLee/JCFInternals">Java Collections Framework Internals</a></p><p><a href="https://blog.csdn.net/luweibin19/article/details/106215036/">JAVA list、set、map等集合类线程不安全的问题及解决方法</a></p><p><a href="https://blog.csdn.net/weixin_43932465/article/details/103006622">java多线程环境下数据结构的安全问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java踩坑小记</title>
    <link href="/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>迭代器Iterator在遍历时能remove但是不能往集合里添加元素问题。我们都知道如果是像List集合这样的，如果用循环遍历，访问没问题，在这期间如果删除就会报错，这个问题是因为你改变了集合的长度，但是遍历用的原来的长度的原因，</p><p>所以Iterator优秀点就出现了，它的出现让你可以在遍历时删除你想删除的元素，它用while循环遍历，它往下循环也就是while里的判定条件是Iterator.hasNext() 返回的是boolean类型，看这个也明白，它是在你想继续往下遍历时先查询是否存在下一个元素。</p><p>而且集合转Iterator也不麻烦，集合本身就有这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Iterator&lt;泛型&gt; it = 集合.iterator();<br></code></pre></td></tr></table></figure><p>敲黑板 下面要讲两点重要的还容易忘的误区</p><p>如果在遍历时删除元素不要用集合的 remove() 方法，要用迭代器的 iterator.remove() 方法，虽然没有参数，但是它移除的是当前的。 在用迭代器迭代的时候千万不要修改集合和给集合添加元素，这样会报错，因为你迭代时添加元素会破坏迭代器的结构，所以会报错，因为拿ArrayList为例，在遍历到中间的时候，你往集合头部插入元素，集合的结构肯定变吧，那迭代器的数据结构也会跟着变，它就会主动报错，，但是删除就没问题了，因为你用的是迭代器的删除方法，而迭代器没有添加元素的方法</p><p>参考链接：<a href="https://blog.csdn.net/weixin_43113679/article/details/99775014">https://blog.csdn.net/weixin_43113679/article/details/99775014</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shuffle 算法</title>
    <link href="/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>其中一种常见的洗牌算法是Fisher-Yates洗牌算法，我将用它来描述原理，并给出Java实现。</p><p><strong>Fisher-Yates洗牌算法原理：</strong></p><ol><li>从数组中最后一个元素开始，从后往前遍历每个元素。</li><li>对于当前遍历到的元素，随机生成一个不超过当前下标的随机数（假设为randIdx）。</li><li>将当前元素与数组中下标为randIdx的元素交换位置，将当前元素放到一个随机位置。</li><li>继续遍历上一个位置的元素，重复步骤2至步骤3，直到第一个元素被处理。</li></ol><p><strong>Fisher-Yates洗牌算法时间复杂度和空间复杂度：</strong></p><p>时间复杂度：洗牌算法的时间复杂度是O(n)，其中n为数组或集合中的元素数量。因为每个元素都需要进行随机交换，而总的交换次数是n次。</p><p>空间复杂度：洗牌算法的空间复杂度是O(1)，因为算法在原地对数组或集合进行交换，没有使用额外的数据结构。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShuffleAlgorithm</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randIdx</span> <span class="hljs-operator">=</span> random.nextInt(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成[0, i]之间的随机数</span><br>            swap(array, i, randIdx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        shuffle(nums);<br>        System.out.println(<span class="hljs-string">&quot;Shuffled array: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>贪心:找到该点到所有点的最短路径</strong></p><p>俩个集合, 一个(dis)是源点到当前该点的最短路径,一个(visited)是源点到该点是否已经找到最短路径; 初始时设定dis[] &#x3D; INT_MAX, dis[start] &#x3D; 0,后续需要比较是否可以找到比当前dis[i]小的值 每轮循环分别找到当前未被访问的点中到源点最短距离的点,加入visited集合中 每轮循环更新dis集合,根据确定的minpos,找到未被访问的点,且小于dis[minpos]+adj[minpos][i]时更新;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 邻接矩阵-无向图</span><br><span class="hljs-comment">// adj[i][j] == 0 表示 i j 不相邻</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj = &#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>&#125;, <br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 基于邻接矩阵dijkstra求解最短路</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, <span class="hljs-type">int</span>&amp; start, <span class="hljs-type">int</span>&amp; end, vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = adj.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(start &gt;= n || start &lt; <span class="hljs-number">0</span> || end &gt;= n || end &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n, INT_MAX)</span></span>;    <span class="hljs-comment">// 当前点到源点的最短距离</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 访问集合</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;       <span class="hljs-comment">// 当前点最短路径的前一节点</span><br><br>    dis[start] = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 保证初始查找点为源点start</span><br>    pre[start] = start;          <span class="hljs-comment">// 设置源点的prepos为start</span><br><br>    <span class="hljs-keyword">for</span>(;;)<br>    &#123;<br>        <span class="hljs-type">int</span> mindis = INT_MAX;<br>        <span class="hljs-type">int</span> minpos = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 找到本轮查找的初始点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; dis[i] &lt; mindis)<br>            &#123;<br>                mindis = dis[i];<br>                minpos = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不存在邻接路径</span><br>        <span class="hljs-keyword">if</span>(minpos == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        visited[minpos] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果终点在确认集合中，则退出查找,保存路径</span><br>        <span class="hljs-keyword">if</span>(visited[end])<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = end;<br>            path.<span class="hljs-built_in">push_back</span>(end);<br>            <span class="hljs-keyword">while</span>(pre[tmp] != start &amp;&amp; pre[tmp] != <span class="hljs-number">-1</span>)<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(pre[tmp]);<br>                tmp = pre[tmp];<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(start);<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; adj[minpos][j] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j] &gt; dis[minpos] + adj[minpos][j])<br>                &#123;<br>                    dis[j] = dis[minpos] + adj[minpos][j];<br>                    pre[j] = minpos;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dis[end];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printpath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i != path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;      <br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> start, end;<br>    cin &gt;&gt; start &gt;&gt; end;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">int</span> mindis = <span class="hljs-built_in">dijkstra</span>(adj, start, end, path);<br>    cout &lt;&lt; mindis &lt;&lt; endl;<br>    <span class="hljs-built_in">printpath</span>(path);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A* 算法</title>
    <link href="/2023/10/24/A-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/A-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>A*算法是一种常用于图形搜索和路径规划的启发式搜索算法。它通过综合考虑实际代价和估计代价，来寻找从起点到目标节点的最优路径。</p><p>算法步骤：</p><ol><li>创建两个空列表：Open列表和Closed列表。</li><li>将起点添加到Open列表。</li><li>重复以下步骤，直到找到目标节点或Open列表为空： a. 从Open列表中选择估计代价最小的节点，将其移动到Closed列表。 b. 遍历该节点的相邻节点：<ul><li>如果相邻节点已经在Closed列表中，跳过它。</li><li>如果相邻节点不在Open列表中，计算其实际代价（从起点到当前节点的代价）和估计代价（从当前节点到目标节点的估计代价），并将其添加到Open列表。</li><li>如果相邻节点已经在Open列表中，检查经过当前节点到达该相邻节点的路径是否更优，如果更优，则更新其实际代价和父节点。</li></ul></li><li>如果Open列表为空，表示没有找到目标节点，搜索失败；否则，从目标节点开始，沿着父节点指针一直回溯到起点，即可得到最优路径。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> g; <span class="hljs-comment">// Actual cost from start node to this node</span><br>    <span class="hljs-type">int</span> h; <span class="hljs-comment">// Heuristic cost from this node to the goal node</span><br>    <span class="hljs-type">int</span> f; <span class="hljs-comment">// f = g + h</span><br>    Node parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.g = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.h = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.f = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AStarAlgorithm</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] grid; <span class="hljs-comment">// 2D array representing the map/grid</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cols;<br>    <span class="hljs-keyword">private</span> Node startNode;<br>    <span class="hljs-keyword">private</span> Node goalNode;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; openList;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; closedList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AStarAlgorithm</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY, <span class="hljs-type">int</span> goalX, <span class="hljs-type">int</span> goalY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.rows = grid.length;<br>        <span class="hljs-built_in">this</span>.cols = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.startNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(startX, startY);<br>        <span class="hljs-built_in">this</span>.goalNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(goalX, goalY);<br>        <span class="hljs-built_in">this</span>.openList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.closedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">findPath</span><span class="hljs-params">()</span> &#123;<br>        openList.add(startNode);<br><br>        <span class="hljs-keyword">while</span> (!openList.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> findLowestFInOpenList();<br>            openList.remove(current);<br>            closedList.add(current);<br><br>            <span class="hljs-keyword">if</span> (current.x == goalNode.x &amp;&amp; current.y == goalNode.y) &#123;<br>                <span class="hljs-keyword">return</span> reconstructPath(current);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip current node</span><br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborX</span> <span class="hljs-operator">=</span> current.x + i;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborY</span> <span class="hljs-operator">=</span> current.y + j;<br><br>                    <span class="hljs-keyword">if</span> (neighborX &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborX &lt; rows &amp;&amp; neighborY &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborY &lt; cols) &#123;<br>                        <span class="hljs-keyword">if</span> (grid[neighborX][neighborY] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip obstacles</span><br><br>                        <span class="hljs-type">Node</span> <span class="hljs-variable">neighbor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(neighborX, neighborY);<br>                        <span class="hljs-keyword">if</span> (closedList.contains(neighbor)) <span class="hljs-keyword">continue</span>;<br><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">tentativeG</span> <span class="hljs-operator">=</span> current.g + <span class="hljs-number">1</span>; <span class="hljs-comment">// Assuming each move has a cost of 1 (can be modified for different costs)</span><br><br>                        <span class="hljs-keyword">if</span> (!openList.contains(neighbor) || tentativeG &lt; neighbor.g) &#123;<br>                            neighbor.parent = current;<br>                            neighbor.g = tentativeG;<br>                            neighbor.h = calculateHeuristic(neighbor);<br>                            neighbor.f = neighbor.g + neighbor.h;<br><br>                            <span class="hljs-keyword">if</span> (!openList.contains(neighbor)) &#123;<br>                                openList.add(neighbor);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Path not found</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLowestFInOpenList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> openList.stream().min(Comparator.comparingInt(node -&gt; node.f)).orElse(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateHeuristic</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// Here, we can use any heuristic function (e.g., Manhattan distance, Euclidean distance, etc.)</span><br>        <span class="hljs-keyword">return</span> Math.abs(node.x - goalNode.x) + Math.abs(node.y - goalNode.y);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title function_">reconstructPath</span><span class="hljs-params">(Node current)</span> &#123;<br>        List&lt;Node&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            path.add(<span class="hljs-number">0</span>, current);<br>            current = current.parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startY</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalX</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalY</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-type">AStarAlgorithm</span> <span class="hljs-variable">aStar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AStarAlgorithm</span>(grid, startX, startY, goalX, goalY);<br>        List&lt;Node&gt; path = aStar.findPath();<br><br>        <span class="hljs-keyword">if</span> (path != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Node node : path) &#123;<br>                System.out.println(<span class="hljs-string">&quot;(&quot;</span> + node.x + <span class="hljs-string">&quot;, &quot;</span> + node.y + <span class="hljs-string">&quot;)&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Path not found!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>install node.js</p><p>install git</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h2 id="流程搭建"><a href="#流程搭建" class="headerlink" title="流程搭建"></a>流程搭建</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>新建一个文件夹，存放博客文件，如取名为&#x2F;blog</p><p>在&#x2F;blog文件夹下安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-cli -g<br></code></pre></td></tr></table></figure><p>验证hexo是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>初始化文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>安装必备组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm installs<br></code></pre></td></tr></table></figure><p>生成静态网页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><h3 id="github远程部署"><a href="#github远程部署" class="headerlink" title="github远程部署"></a>github远程部署</h3><p>新建一个远程仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/username/u</span>sername.github.io.git<br></code></pre></td></tr></table></figure><p>配置&#x2F;blog下的_config.yaml中</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/username/username.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p>远程部署</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> your-hexo-site</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></code></pre></td></tr></table></figure><p>启用主题</p><p>与所有 Hexo 主题启用的模式一样。 当 克隆&#x2F;下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">theme:</span> <span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>验证主题</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><p>配置主题配置文件</p><h2 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h2><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><h3 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h3><p>新建一个branch并设置为默认分支,比如新分支叫hexo</p><p>克隆github仓库到本地，将原来的博客根目录下的文件拷贝过来（除.deploy_git, node_modules&#x2F;, public&#x2F;），</p><p>确认.gitignore内容</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></td></tr></table></figure><p>push源文件到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;add branch&quot;<br>git push<br></code></pre></td></tr></table></figure><p>在当前文件夹安装hexo，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>hexo -v ## 验证下是否安装成功<br>npm install<br></code></pre></td></tr></table></figure><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li>npm install -g hexo-cli 异常</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ npm install -<span class="hljs-keyword">g</span> hexo-<span class="hljs-keyword">cli</span><br>npm <span class="hljs-keyword">ERR</span>! code EEXIST<br>npm <span class="hljs-keyword">ERR</span>! path C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! EEXIST: <span class="hljs-keyword">file</span> already exists<br>npm <span class="hljs-keyword">ERR</span>! <span class="hljs-keyword">File</span> exists: C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! Remove the existing <span class="hljs-keyword">file</span> and try again, or <span class="hljs-keyword">run</span> npm<br>npm <span class="hljs-keyword">ERR</span>! with --force to overwrite files recklessly.<br><br>npm <span class="hljs-keyword">ERR</span>! A complete <span class="hljs-keyword">log</span> of this <span class="hljs-keyword">run</span> can be found <span class="hljs-keyword">in</span>:<br>npm <span class="hljs-keyword">ERR</span>!     C:\Users\Administrator\AppData\<span class="hljs-keyword">Local</span>\npm-cache\_logs\2023-10-24T05_13_02_159Z-debug-0.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p>这是由于之前可能装过hexo，需要在npm的appdata中删除原有的hexo modules</p><ul><li>hexo主题切换导致乱码</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&#123;% extends <span class="hljs-string">&#x27;_layout.swig&#x27;</span> %&#125; &#123;% <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;_macro/post.swig&#x27;</span> as post_template %&#125;<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..<br></code></pre></td></tr></table></figure><p>hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>重新生成</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean          <br>hexo <span class="hljs-keyword">generate</span>      <br>hexo server<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">github+hexo搭建个人博客</a></p><p><a href="https://www.cnblogs.com/lanhualan/p/14588669.html">hexo主题切换乱码问题解决</a></p><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E5%88%9B%E5%BB%BA%E3%80%8C%E5%85%B3%E4%BA%8E%E9%A1%B5%E3%80%8D">fluid主题配置</a></p><p><a href="https://dora-cmon.github.io/posts/454ba26/">hexo跨平台搭建</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
