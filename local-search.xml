<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TopK理解与实现</title>
    <link href="/2023/10/25/TopK%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/10/25/TopK%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="堆实现Topk"><a href="#堆实现Topk" class="headerlink" title="堆实现Topk"></a>堆实现Topk</h2><p>时间复杂度：O(nlogk)<br>思路：</p><ol><li>通过小顶堆实现TopK（小顶堆的堆顶元素小于左右子树的值，当设定堆空间为K时，每次选择是否更新堆顶元素，若更新则进行相应调整）</li><li>构建堆：构建一个heap,元素个数为K，以完全二叉树的结构去理解数组中元素之间的关系，根节点为i(下标从0开始)，则左儿子下标为2<em>i+1,右儿子为2</em>i+2；</li><li>调整小顶堆：从n&#x2F;2-1的下标开始构建（完全二叉树的最后一个分支），选择左右子节点的最小值，进行交换，为确保最后所有分支都满足小顶堆，所以当每次交换后，以被换掉的下标重新开始调整</li><li>如果当前元素比堆顶元素大，则更新堆顶元素，从堆顶元素的下标开始调整。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">uptodown</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heap, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = pos;<br><span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (j &lt; k)<br>&#123;<br><span class="hljs-keyword">if</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; heap[j] &gt; heap[j + <span class="hljs-number">1</span>])<br>j++;<br><span class="hljs-keyword">if</span> (heap[i] &lt;= heap[j])<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">swap</span>(heap[i], heap[j]);<br>i = j;<br>j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_heap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heap, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> pos = k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-built_in">uptodown</span>(heap, k, i);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-number">5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">52</span>,<span class="hljs-number">78</span>,<span class="hljs-number">59</span>,<span class="hljs-number">46</span>,<span class="hljs-number">49</span>,<span class="hljs-number">65</span>,<span class="hljs-number">42</span>,<span class="hljs-number">15</span>,<span class="hljs-number">34</span>,<span class="hljs-number">28</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">heap</span><span class="hljs-params">(k, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>&#123;<br>heap[i] = nums[i];<br>&#125;<br><span class="hljs-built_in">create_heap</span>(heap, k);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-keyword">if</span> (nums[i] &gt; heap[<span class="hljs-number">0</span>])<br>&#123;<br>heap[<span class="hljs-number">0</span>] = nums[i];<br><span class="hljs-built_in">uptodown</span>(heap, k, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; heap.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; heap[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="快排实现Topk"><a href="#快排实现Topk" class="headerlink" title="快排实现Topk"></a>快排实现Topk</h2><p>时间复杂度：平均O(N)<br>思路：</p><ol><li>利用快排的思想实现，每次可以得到一个元素下标，在这个元素下标左边，所有元素比这个元素小，在这个元素右边，所有元素都比这个元素大</li><li>如果右边的元素个数等于K-1，则加上当前元素，达到K个，可知TOPK的元素为这K个；</li><li>如果右边的元素个数小于K-1, 则在左边范围寻找K-len个元素</li><li>如果右边的元素个数大于K-1, 则在右边范围寻找K个元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pk = nums[low];<br>    <span class="hljs-keyword">while</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= pk)<br>            high--;<br>        nums[low] = nums[high];<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt; pk)<br>            low++;<br>        nums[high] = nums[low];<br>    &#125;<br>    nums[high] = pk;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_topk</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-type">int</span> len = high - pos - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(len == k)<br>            index = pos;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &lt; k)<br>        &#123;<br>            index = <span class="hljs-built_in">quick_topk</span>(nums, low, pos<span class="hljs-number">-1</span>, k-len);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            index = <span class="hljs-built_in">quick_topk</span>(nums, pos+<span class="hljs-number">1</span>, high, k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> k = <span class="hljs-number">5</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123; <span class="hljs-number">12</span>,<span class="hljs-number">52</span>,<span class="hljs-number">1</span>,<span class="hljs-number">59</span>,<span class="hljs-number">46</span>,<span class="hljs-number">49</span>,<span class="hljs-number">65</span>,<span class="hljs-number">58</span>,<span class="hljs-number">15</span>,<span class="hljs-number">34</span>,<span class="hljs-number">28</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">quick_topk</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=nums.<span class="hljs-built_in">size</span>()-k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        cout &lt;&lt; nums[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Prometheus+Grafana搭建性能监控系统</title>
    <link href="/2023/10/25/%E5%9F%BA%E4%BA%8EPrometheus-Grafana%E6%90%AD%E5%BB%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/10/25/%E5%9F%BA%E4%BA%8EPrometheus-Grafana%E6%90%AD%E5%BB%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Prometheus-Grafana搭建性能监测工具"><a href="#基于Prometheus-Grafana搭建性能监测工具" class="headerlink" title="基于Prometheus+Grafana搭建性能监测工具"></a><strong>基于Prometheus+Grafana搭建性能监测工具</strong></h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a><strong>需求</strong></h2><ul><li><p>监测数据类型：JVM数据、玩家在线人数、消息时延等</p></li><li><p>接入Prometheus性能监测工具，暴露服务器性能监测数据</p></li><li><ul><li>模式：pull&#x2F;push</li></ul></li><li><p>接入Grafana可视化数据</p></li><li><p>Prometheus框架图</p></li></ul><p><img src="/../image/develop/promethus.png" alt="img"></p><h2 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h2><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>Java客户端配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- The client --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Hotspot JVM metrics--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_hotspot&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Exposition HTTPServer--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_httpserver&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- Pushgateway exposition--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;<br>    &lt;artifactId&gt;simpleclient_pushgateway&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- JMX Collector--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.prometheus.jmx&lt;/groupId&gt;<br>    &lt;artifactId&gt;collector&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-variable">$&#123;prometheus.jmx.version&#125;</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在本文的背景下，需要配置俩个文件：<br><strong>1.jmx 的yaml文件，主要用于管理JMX Exporter的数据，即需要暴露的JVM参数；</strong><br><a href="https://github.com/jetbrains-infra/prometheus-jmx-exporter/blob/master/config.yml.template">jmx 的yaml文件</a><br>其中hostPort,username,password可以选择先屏蔽掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#hostPort: $&#123;JMX_HOSTPORT&#125;</span><br><span class="hljs-comment">#username:</span><br><span class="hljs-comment">#password:</span><br></code></pre></td></tr></table></figure><p><strong>2.prometheus服务器的运行配置文件,注意替换配置文件中的ip和port</strong><br>● ip直接设置为本机IP, windows下ipconfig可以查询，Mac下ipconfig<br>● 在pull模式下，配置的port1为暴露的Http端口<br>● 在push模式下，配置的port2为push-gateway运行的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">global:<br>  scrape_interval:     15s<br>  evaluation_interval: 15s<br> <br>scrape_configs:<br><span class="hljs-comment"># pull mode</span><br>  - job_name: game-pull<br>    static_configs:<br>      - targets: [<span class="hljs-string">&#x27;ip:port1&#x27;</span>]<br>        labels:<br>          instance: app-pull<br><span class="hljs-comment"># push mode</span><br>  - job_name: game-push<br>    static_configs:<br>      - targets: [<span class="hljs-string">&#x27;ip:port2&#x27;</span>]<br>        labels:<br>          instance: app-push<br><br></code></pre></td></tr></table></figure><h3 id="部署-Prometheus"><a href="#部署-Prometheus" class="headerlink" title="部署 Prometheus"></a>部署 Prometheus</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name prometheus -d -p 127.0.0.1:9090:9090 prom/prometheus<br><span class="hljs-comment">#指定prometheus配置文件运行</span><br>docker run -d -p 9090:9090 -v E://project//hotel//hotel-script//prometheus.yml:/etc/prometheus/prometheus.yml  prom/prometheus<br></code></pre></td></tr></table></figure><h3 id="部署-Prometheus-PushGateWay"><a href="#部署-Prometheus-PushGateWay" class="headerlink" title="部署 Prometheus-PushGateWay"></a>部署 Prometheus-PushGateWay</h3><p><a href="https://github.com/Prometheus/pushgateway">Prometheus-PushGateWay</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull prom/pushgateway<br>docker run -d -p 9091:9091 prom/pushgateway<br></code></pre></td></tr></table></figure><p>部署 Grafana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 3000:3000 --name=grafana  grafana/grafana<br></code></pre></td></tr></table></figure><p>启动后，访问：<a href="http://localhost:3000，默认用户名密码">http://localhost:3000，默认用户名密码</a> admin&#x2F;admin。</p><h3 id="添加-Prometheus-数据源"><a href="#添加-Prometheus-数据源" class="headerlink" title="添加 Prometheus 数据源"></a>添加 Prometheus 数据源</h3><p>Settings-&gt;Data sources -&gt; Add data source -&gt; Prometheus </p><p>● 在HTTP URL中填写本机IP+Prometheus服务器运行的port.<br>● HTTP Method选择Get方法</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>1.Error reading Prometheus: An error occurred within the plugin</strong><br>将添加数据源的ip设置为本机ip，当设置为localhost时由于容器环境运行的grafana，所以localhost在容器内部可能有自己的定义。</p><p><strong>2.prometheus有数据 grafana无数据</strong><br>grafana可以通过PromeSQL语句查询对应的参数</p><p><a href="https://www.modb.pro/db/412613">Prometheus | Grafana导入模板后发现没有数据排查步骤 - 墨天轮</a><br><a href="https://blog.csdn.net/weixin_52837796/article/details/120768817">prometheus+grafana监控jvm，grafana上没有数据_吃葡萄不吐西瓜皮~的博客-CSDN博客_grafana没有监控数据</a><br><img src="/../image/develop/grafana_interface.png" alt="在这里插入图片描述"></p><p><strong>3 Prometheus Histogram</strong><br>prometheus的histogram是一个累计直方图，正常理解直方图的桶内时对应范围（a&lt;x&lt;b）的数据，prometheus的直方图的桶是累计的值，即当前这个桶的数据包含前一个桶，方便函数筛选，用户最后自己想要啥数据，自己用函数筛选；使用计时相关的api单位默认就是秒，自定义的数据类型就是自定义的数据类型对应的单位。<br>rate(histogram_showcase_metric_bucket[1m]) 查看每个 bucket 的每秒变化率来了解这些 bucket 是如何随时间变化；histogram_quantile() 可以计算出哪个 bucket 标签包含给定的分位数（例如第 95 个百分位数）。<br><img src="/../image/develop/prometheus_bucket.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">histogram_quantile(0.95,rate(requests_latency_seconds_bucket[1m]))<br></code></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1495303">一文搞懂 Prometheus 的直方图 - 腾讯云开发者社区-腾讯云</a><br><a href="https://juejin.cn/post/7152837166190739486">深入理解和使用 Prometheus 的 Histogram 指标类型 - 掘金</a><br><a href="https://blog.csdn.net/qq_34556414/article/details/123151789">PromQL 直方图 跟踪请求的延迟或响应大小 99%的请求是在多少延迟下完成的？_富士康质检员张全蛋的博客-CSDN博客_promql 直方图</a></p><p><strong>4.这俩行代码不在一个线程好像没法用？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">new PerfCustomCollector().register();<br>HTTPServer server = new HTTPServer(1234);<br></code></pre></td></tr></table></figure><p><strong>5. windows install curl</strong><br>假设您是从<a href="https://curl.haxx.se/download.html%E8%8E%B7%E5%BE%97%E7%9A%84%EF%BC%8C%E5%8F%AA%E9%9C%80%E5%B0%86%E5%85%B6%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%88%B0%E6%82%A8%E6%83%B3%E8%A6%81%E7%9A%84%E4%BB%BB%E4%BD%95%E4%BD%8D%E7%BD%AE%E3%80%82%E6%97%A0%E9%9C%80%E5%AE%89%E8%A3%85%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E6%89%93%E7%AE%97%E4%BD%BF%E7%94%A8">https://curl.haxx.se/download.html获得的，只需将其解压缩到您想要的任何位置。无需安装。如果您打算使用</a> SSL，则需要下载 OpenSSL DLL，可从 curl 的网站获得。<br>下载卷曲压缩包<br>提取内容（如果您下载了正确的版本，您应该找到 curl.exe）<br>将 curl.exe 放在您保存软件的文件夹中（例如 D:\software\curl\curl.exe）<br>从命令行运行 curl<br>a) 右击“我的电脑”图标<br>b) 选择属性<br>c) 点击“高级系统设置”链接<br>d) 转到选项卡 [高级] - “环境变量”按钮<br>e) 在系统变量下选择“路径”和“编辑”按钮<br>f) 添加一个分号，后跟放置 curl.exe 的路径（例如；D:\software\curl）<br>现在您可以通过键入以下命令从命令行运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl www.google.com<br></code></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.cn/post/6844904062157062151">https://juejin.cn/post/6844904062157062151</a></p><p><a href="https://cloud.tencent.com/developer/article/1495303">https://cloud.tencent.com/developer/article/1495303</a></p><p><a href="https://juejin.cn/post/7152837166190739486">https://juejin.cn/post/7152837166190739486</a></p><p><a href="https://blog.csdn.net/qq_34556414/article/details/123151789">https://blog.csdn.net/qq_34556414/article/details/123151789</a></p>]]></content>
    
    
    <categories>
      
      <category>运维部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Operating System Three Pieces</title>
    <link href="/2023/10/24/Operating-System-Three-Pieces/"/>
    <url>/2023/10/24/Operating-System-Three-Pieces/</url>
    
    <content type="html"><![CDATA[<h2 id="第-9-章-调度：比例份额"><a href="#第-9-章-调度：比例份额" class="headerlink" title="第 9 章 调度：比例份额"></a>第 9 章 调度：比例份额</h2><p><strong>关键问题：如何按比例分配 CPU</strong></p><p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</p><p>比例份额调度程序有一个非常优秀的现代例子，由 Waldspurger 和 Weihl 发现，名为彩 票调度（lottery scheduling） [WW94]。</p><h4 id="彩票调度（lottery-scheduling）"><a href="#彩票调度（lottery-scheduling）" class="headerlink" title="彩票调度（lottery scheduling）"></a>彩票调度（lottery scheduling）</h4><h5 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h5><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><p>彩票调度最精彩的地方在于利用了随机性（randomness）。当你需要做出决定时，采用随机的方式 常常是既可靠又简单的选择。</p><p>随机方法相对于传统的决策方式，至少有 3 点优势</p><p>1.随机方法常常可以避免奇怪的边角情况，较传统的算法可能在处理这些情况时遇到麻烦。例如 LRU 替换策略（稍后会在虚拟内存的章节详 细介绍）。虽然 LRU 通常是很好的替换算法，但在有重复序列的负载时表现非常差。但随机方法就没有这种最差情况；</p><p>2.随机方法很轻量，几乎不需要记录任何状态。在传统的公平份额调度算法中，记录每个进程已经获得了多少的 CPU 时间，需要对每个进程计时，这必须在每次运行结束后更新。而采用随机方式后每个进程只需要非常少的状态（即每个进程拥有的彩票号码）；</p><p>3.随机方法很快。只要能很快地产生随机数，做出决策就很快。因此，随机方式在对运行速度 要求高的场景非常适用。当然，越是需要快的计算速度，随机就会越倾向于伪随机。</p><h5 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h5><p>彩票调度还提供了一些机制，以不同且有效的方式来调度彩票。</p><p><strong>彩票货币</strong>（ticket currency）。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币， 将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p><p><strong>彩票转让</strong>（ticket transfer）。通过转让，一个进程可以临时将自己 的彩票交给另一个进程。这种机制在客户端&#x2F;服务端交互的场景中尤其有用，在这种场景中， 客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行， 客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服 务端执行结束后会将这部分彩票归还给客户端。</p><p><strong>彩票通胀</strong>（ticket inflation）。利用通胀，一个进程可以临时提升或 降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么 意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进 程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 CPU 时间，就可以 增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>实现简单，只需要一个不错的随机数生成器来选 择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p><h5 id="如何分配彩票"><a href="#如何分配彩票" class="headerlink" title="如何分配彩票"></a>如何分配彩票</h5><p>系统的运行严重依赖于彩票的分配。假设用户自己知道如何分配，因此可以 给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。然而这种方案似乎什 么也没有解决——还是没有给出具体的分配策略。</p><h5 id="为什么不是确定的"><a href="#为什么不是确定的" class="headerlink" title="为什么不是确定的"></a>为什么不是确定的</h5><p>究竟为什么要利用随机性？从上面的内容可以看出，虽然随机方式 可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作 运行时间很短的情况下。由于这个原因，Waldspurger 提出了步长调度（stride scheduling）， 一个确定性的公平分配算法[W95]。</p><p>待补充</p><h2 id="第-10-章-多处理器调度（高级）"><a href="#第-10-章-多处理器调度（高级）" class="headerlink" title="第 10 章 多处理器调度（高级）"></a>第 10 章 多处理器调度（高级）</h2><p><strong>关键问题：如何在多处理器上调度工作</strong></p><h4 id="背景：多处理器架构"><a href="#背景：多处理器架构" class="headerlink" title="背景：多处理器架构"></a>背景：多处理器架构</h4><p><strong>在单 CPU 系统中</strong>，存在多级的硬件缓存（hardware cache），一般来说会让处理器更快地执行程序。缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。通过将频繁访问的数据放在缓存中， 系统似乎拥有又大又快的内存。</p><h2 id="第-13-章-抽象：地址空间"><a href="#第-13-章-抽象：地址空间" class="headerlink" title="第 13 章 抽象：地址空间"></a>第 13 章 抽象：地址空间</h2><p><strong>关键问题：如何虚拟化内存</strong></p><p>虚拟内存（VM）系统的一个主要目标是透明（transparency），另一个目标是效率（efficiency），第三个目标是保护（protection）</p><h2 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a>第 15 章 机制：地址转换</h2><p>实现 CPU 虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct Execution，LDE）。</p><p>LDE思想：让程序运行的大部分指令直接访问硬件，只在 一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间， 正确的地点，做正确的事”。</p><p><strong>关键问题：如何高效、灵活地虚拟化内存</strong></p><p>利用了一种通用技术，有时被称为基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）。</p><p>利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此， 在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际 的位置。仅仅依靠硬件不足以实现虚拟内存，只是提供了底层机制来提高效率。</p><p>操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。因此它必须管 理内存（manage memory），记录被占用和空闲的内存位置，并明智而谨慎地介入，保持对 内存使用的控制。</p><h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>先假设用户的地址空间必须连续地放在物理内存中。</p><h3 id="动态（基于硬件）重定位"><a href="#动态（基于硬件）重定位" class="headerlink" title="动态（基于硬件）重定位"></a>动态（基于硬件）重定位</h3><p>一个简单的思想，称为基址加界限 机制（base and bound），有时又称为动态重定位（dynamic relocation）：每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">physical <span class="hljs-built_in">address</span> = virtual <span class="hljs-built_in">address</span> + <span class="hljs-built_in">base</span> <br></code></pre></td></tr></table></figure><p>进程中使用的内存引用都是虚拟地址（virtual address），硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址（physical address），再发给内存系统。</p><p>Example:</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-number">128</span>: movl <span class="hljs-number">0</span>x0(<span class="hljs-built_in">%ebx</span>), <span class="hljs-built_in">%eax</span> <br></code></pre></td></tr></table></figure><p>程序计数器（PC）首先被设置为 128。当硬件需要获取这条指令时，它先将这个值加上基 址寄存器中的 32KB(32768)，得到实际的物理地址 32896，然后硬件从这个物理地址获取指令。 接下来，处理器开始执行该指令。这时，进程发起从虚拟地址 15KB 的加载，处理器同样将虚 拟地址加上基址寄存器内容（32KB），得到最终的物理地址 47KB，从而获得需要的数据。</p><p> 界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。界限寄存器确保了进程产生的所有地址都在进程的地址“界限”中，提供了访问保护。</p><p>在上面的例子中，界限寄存器被置为 16KB。如果进 程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。</p><p>通常有两种使用方式。在一种方式中（像上面那样），它记 录地址空间的大小，硬件在将虚拟地址与基址寄存器内容求和前，就检查这个界限。另一种方 式是界限寄存器中记录地址空间结束的物理地址，硬件在转化虚拟地址到物理地址之后才去检 查这个界限。</p><h3 id="操作系统的问题"><a href="#操作系统的问题" class="headerlink" title="操作系统的问题"></a>操作系统的问题</h3><p>支持动态重定位，硬件添加了新的功能，使得操作系统有了一些必须处理的新问题。</p><p>第一，在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。</p><p>第二，在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些 工作，回收它的所有内存，给其他进程或者操作系统使用。在进程终止时，操作系统会将 这些内存放回到空闲列表，并根据需要清除相关的数据结构。</p><p>第三，在上下文切换时，操作系统也必须执行一些额外的操作。每个 CPU 毕竟只有一 个基址寄存器和一个界限寄存器，但对于每个运行的程序，它们的值都不同，因为每个程序被加载到内存中不同的物理地址。因此，在切换进程时，操作系统必须保存和恢复基础和界限寄存器。</p><p>第四，操作系统必须提供异常处理程序（exception handler），或要一些调用的函数，像上面提到的那样。操作系统在启动时加载这些处理程序（通过特权命令）。</p><h3 id="带来的挑战"><a href="#带来的挑战" class="headerlink" title="带来的挑战"></a>带来的挑战</h3><p>在我们当前的方式 中，即使有足够的物理内存容纳更多进程，但我们目前要求将地址空间放在固定大小的槽块 中，因此会出现内部碎片。内部碎片（internal fragmentation）， 指的是已经分配的内存单元内部有未使用的空间（即碎片），造成了浪费。以便更好地利用物理内存，避免 内部碎片。第一次尝试是将基址加界限的概念稍稍泛化，得到分段（segmentation）的概念。</p><h2 id="第-16-章-分段"><a href="#第-16-章-分段" class="headerlink" title="第 16 章 分段"></a>第 16 章 分段</h2><p>我们一直假设将所有进程的地址空间完整地加载到内存中。利用基址和 界限寄存器，操作系统很容易将不同进程重定位到不同的物理内存区域。但是，对于这些 内存区域，你可能已经注意到一件有趣的事：栈和堆之间，有一大块“空闲”空间。</p><p><strong>关键问题：怎样支持大地址空间</strong></p><h3 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&#x2F;界限"></a>分段：泛化的基址&#x2F;界限</h3><p>想法很简单，在 MMU 中引入不止 一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是 地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈 和堆。</p><p><strong>分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</strong></p><h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>分段的基本原理：系统运行时，地址空间中的不同段被重定位到物理内存中。与我们之前介绍的整个地址空间只有一个基址&#x2F;界限寄存器对的方式相比， 大量节省了物理内存。具体来说，栈和堆之间没有使用的区域就不需要再分配物理内存， 让我们能将更多地址空间放进物理内存。</p><h4 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h4><p>第一个是老问题：操作系统在上下文切换时应该做什么？你可能已经猜到了：各个段寄存器中的 内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进 程运行前，确保这些寄存器被正确地赋值。</p><p>第二个问题更重要，即管理物理内存的空闲空间。新的地址空间被创建时，操作系统 需要在物理内存中为它的段找到空间。之前，我们假设所有的地址空间大小相同，物理内 存可以被认为是一些槽块，进程可以放进去。现在，每个进程都有一些段，每个段的大小也可能不同。物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为外部碎片（external fragmentation）[R69]，</p><p>一种解决方案是紧凑（compact）物理内存，重新安排原有的段。另一种更简单的做法是利用空闲列表管理算法，试图保留大的内存块用于分配。</p><p>相关的算法包括传统的最优匹配（best-fit，从空闲链表中找最接近需要分配空 间的空闲块返回）、最坏匹配（worst-fit）、首次匹配（first-fit）以及像伙伴算法（buddy algorithm） [K68]这样更复杂的算法。</p><p>但遗憾的是，无论算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>分段解决了一些问题，帮助我们实现了更高效的虚拟内存。不只是动态重定位，通过 避免地址空间的逻辑段之间的大量潜在的内存浪费，分段能更好地支持稀疏地址空间。它 还很快，因为分段要求的算法很容易，很适合硬件完成，地址转换的开销极小。分段还有 一个附加的好处：代码共享。如果代码放在独立的段中，这样的段就可能被多个运行的程 序共享。</p><h2 id="第-17-章-空闲空间管理"><a href="#第-17-章-空闲空间管理" class="headerlink" title="第 17 章 空闲空间管理"></a>第 17 章 空闲空间管理</h2><p>如果需要管理的空间被划分为固定大小的单元，只需要维护这 些大小固定的单元的列表；</p><p> 如果要管理的空闲空间由大小不同的单元构成，出现在用户级的内存分配库（如 malloc()和 free()），或者操作系统用分段（segmentation） 的方式实现虚拟内存。</p><p>在这两种情况下，出现了外部碎片（external fragmentation）的问题： 空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够 大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</p><p><strong>关键问题：如何管理空闲空间</strong></p><p>要满足变长的分配请求，应该如何管理空闲空间？什么策略可以让碎片最小化？不同方法的时间和 空间开销如何？</p><h3 id="假设-1"><a href="#假设-1" class="headerlink" title="假设"></a>假设</h3><p>假定基本的接口就像 malloc()和 free()提供的：函数返回一个指针（没有具体的类型， 在 C 语言的术语中是 void 类型），指向这样大小（或较大一点）的一块空间。对应的函数 void free(void *ptr)函数接受一个指针，释放对应的内存块。请注意该接口的隐含意义，在释 放空间时，用户不需告知库这块空间的大小。因此，在只传入一个指针的情况下，库必须能够弄清楚这块内存的大小。</p><p>该库管理的空间由于历史原因被称为堆，在堆上管理空闲空间的数据结构通常称为空 闲列表（free list）。该结构包含了管理内存区域中所有空闲块的引用。</p><p>当然，该数据结构不 一定真的是列表，而只是某种可以追踪空闲空间的数据结构。</p><h2 id="第-18-章-分页：介绍"><a href="#第-18-章-分页：介绍" class="headerlink" title="第 18 章 分页：介绍"></a>第 18 章 分页：介绍</h2><h2 id="第-19-章-分页：快速地址转换（TLB）"><a href="#第-19-章-分页：快速地址转换（TLB）" class="headerlink" title="第 19 章 分页：快速地址转换（TLB）"></a>第 19 章 分页：快速地址转换（TLB）</h2><h2 id="第-20-章-分页：较小的表"><a href="#第-20-章-分页：较小的表" class="headerlink" title="第 20 章 分页：较小的表"></a>第 20 章 分页：较小的表</h2><h2 id="第-21-章-超越物理内存：机制"><a href="#第-21-章-超越物理内存：机制" class="headerlink" title="第 21 章 超越物理内存：机制"></a>第 21 章 超越物理内存：机制</h2><h2 id="第-22-章-超越物理内存：策略"><a href="#第-22-章-超越物理内存：策略" class="headerlink" title="第 22 章 超越物理内存：策略"></a>第 22 章 超越物理内存：策略</h2><h2 id="第-23-章-VAX-VMS-虚拟内存系统"><a href="#第-23-章-VAX-VMS-虚拟内存系统" class="headerlink" title="第 23 章 VAX&#x2F;VMS 虚拟内存系统"></a>第 23 章 VAX&#x2F;VMS 虚拟内存系统</h2><h2 id="内存管理总结"><a href="#内存管理总结" class="headerlink" title="内存管理总结"></a>内存管理总结</h2><h3 id="独占式内存管理"><a href="#独占式内存管理" class="headerlink" title="独占式内存管理"></a>独占式内存管理</h3><p>在多任务并发运行时，每次任务切换都会涉及内存和磁盘之间的数据拷贝，效率低下；</p><p>最直观的解决方法是将程序的数据都常驻在内存中（假设内存足够），避免数据拷贝。但程序之间的内存地址空间是没有隔离的。引入虚拟化管理。</p><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>OS为每个程序都虚拟化出一段内存空间，并映射到一段物理内存上。对程序而言，只看得到自己的虚拟地址空间。</p><h3 id="程序内存管理"><a href="#程序内存管理" class="headerlink" title="程序内存管理"></a>程序内存管理</h3><p>虚拟内存空间分为3个区域，<strong>Code</strong>区域存储的是程序代码的机器指令；<strong>Heap</strong>区域存储程序运行过程中动态申请的内存；<strong>Stack</strong>区域则是存储函数入参、局部变量、返回值等。Heap和Stack会在程序运行过程中不断增长，分别放置在虚拟内存空间的上方和下方，并往相反方向增长。</p><p>虚拟地址空间到物理地址空间的映射，需要一个转换。位于CPU芯片内的MMU（内存管理单元）负责。</p><p>MMU需要<strong>base</strong>和<strong>bound</strong>两个寄存器。其中<strong>base</strong>寄存器用来存储程序在物理内存上的<strong>基地址</strong>；<strong>bound</strong>寄存器（有时候也叫<strong>limit</strong>寄存器）则保存虚拟地址空间的Size，主要用来避免越界访问</p><blockquote><p><strong>物理地址 &#x3D; 虚拟地址 + 基地址</strong></p></blockquote><p>但Heap，Stack区域之间有很大一部分空闲内存是“已申请，未使用”的空闲状态。但再也无法分配给其他程序使用，导致内存利用率低下的问题。为解决这个问题，引入段式内存管理。</p><h3 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h3><p><strong>段（Segment）是逻辑上的概念，本质上是一块连续的、有一定大小限制的内存区域</strong>，前文中，我们一共提到过3个段：Code、Heap和Stack。</p><p>段式内存管理以段为单位进行管理，它允许OS将每个段灵活地放置在物理内存的空闲位置上，因此也避免了“已申请，未使用”的内存区域出现：</p><h4 id="内存共享和保护"><a href="#内存共享和保护" class="headerlink" title="内存共享和保护"></a>内存共享和保护</h4><p>段式内存管理还可以很方便地<strong>支持内存共享</strong>，从而达到节省内存的目的。比如，如果存在多个程序都是同一个可执行文件运行起来的，那么这些程序是可以共享Code段的。为了实现这个功能，我们可以在虚拟地址上设置保护位，当保护位为只读时，表示该段可以共享。另外，如果程序修改了只读的段，则转换地址失败，因此也可以达到<strong>内存保护</strong>的目的。</p><h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>段式内存管理的最明显的缺点就是<strong>容易产生内存碎片</strong>，这是因为在系统上运行的程序的各个段的大小往往都不是固定的，而且段的分布也不是连续的。当系统的内存碎片很多时，内存的利用率也会急剧下降，对外表现就是<strong>虽然系统看起来还有很多内存，却无法再运行起一个程序</strong>。</p><p>碎片整理的代价极大，一方面需要进行多次内存拷贝；另一方面，在拷贝过程中，正在运行的程序必须停止，这对于一些以人机交互任务为主的应用程序，将会极大影响用户体验。</p><h3 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h3><p>页式内存管理的思路，是将虚拟内存和物理内存都划分为多个<strong>固定大小的区域</strong>，这些区域我们称之为<strong>页</strong>（<strong>Page</strong>）。页是内存的最小分配单位，一个应用程序的虚拟页可以存放在任意一个空闲的物理页中。</p><blockquote><p>物理内存中的页，我们通常称之为页帧（Page Frame）</p></blockquote><p><strong>因为页的大小是固定的，而且作为最小的分配单位，这样就可以解决段式内存管理中内存碎片的问题了</strong>。但页内仍然有可能存在内存碎片。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程浅学</title>
    <link href="/2023/10/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B5%85%E5%AD%A6/"/>
    <url>/2023/10/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B5%85%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程编程由浅入深"><a href="#多线程编程由浅入深" class="headerlink" title="多线程编程由浅入深"></a>多线程编程由浅入深</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>程序(program)<strong>：</strong>为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指一段静态的代码，静态对象。</p><p><strong>进程(process)<strong>：程序的一次执行过程，或是</strong>正在运行的一个程序</strong>。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p><p>（1）<strong>进程为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域</p><p><strong>线程(thread)<strong>，进程可进一步细化为线程，是</strong>一个程序内部的一条执行路径</strong>。</p><p>（1）若一个进程同一时间并行执行多个线程，就是支持多线程的<br>（2）<strong>线程是调度和执行的单位</strong>，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小<br>（3）一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间—》它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p><p><strong>并行</strong>：多个CPU同时执行多个任务。比如：多个人同时做不同的事。是真正的同时。</p><p><strong>并发</strong>：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p><h2 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h2><h3 id="方式1-继承Thread类"><a href="#方式1-继承Thread类" class="headerlink" title="方式1:继承Thread类"></a>方式1:继承Thread类</h3><p>（1）创建一个继承于Thread类的子类</p><p>（2）重写Thread类的run（）–》将此线程执行的操作声明在run（）中</p><p>（3）创建THread类的子类的对象</p><p>（4）通过此对象调用start（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class Thread extends Object implements Runnable</span><br><span class="hljs-comment"> * Thread 类也是 Runnable 接口的子类，但在Thread类中并没有完全实现 Runnable 接口中的 run() 方法</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <span class="hljs-comment">// 继承Thread类，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> String name ;       <span class="hljs-comment">// 表示线程的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;      <span class="hljs-comment">// 通过构造方法配置name属性</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行，i = &quot;</span> + i) ;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo2</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程A &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程B &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        mt1.start() ;   <span class="hljs-comment">// 调用线程主体</span><br>        mt2.start() ;   <span class="hljs-comment">// 调用线程主体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方式2-实现Runnable接口"><a href="#方式2-实现Runnable接口" class="headerlink" title="方式2:实现Runnable接口"></a>方式2:实现Runnable接口</h3><p>（1）创建一个实现了Runnable接口得类</p><p>（2）实现类去实现Runnable中的抽象方法:run()</p><p>（3）创建实现类的对象</p><p>（4）将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><p>（5）通过Thread类的对象调用start()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现 Runnable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> String name ;       <span class="hljs-comment">// 表示线程的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name ;      <span class="hljs-comment">// 通过构造方法配置name属性</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.println(name + <span class="hljs-string">&quot;运行，i = &quot;</span> + i) ;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程A &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;线程B &quot;</span>) ;    <span class="hljs-comment">// 实例化对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt2) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h3><ul><li>开发中：优先选择：实现Runnable接口的方式</li><li>原因：</li><li><ol><li>实现的方式没有类的单继承性的局限性</li></ol></li><li><ol start="2"><li>实现的方式更适合来处理多个线程有共享数据的情况。</li></ol></li><li>联系：public class Thread implements Runnable—Thread 类也是 Runnable 接口的子类，但在Thread类中并没有完全实现 Runnable 接口中的 run() 方法</li><li>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</li></ul><h2 id="测试Thread类的常用方法"><a href="#测试Thread类的常用方法" class="headerlink" title="测试Thread类的常用方法"></a>测试Thread类的常用方法</h2><ul><li>1.start():启动当前线程，执行当前线程的run()</li><li>2.run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</li><li>3.currentThread(): 静态方法，返回当前代码执行的线程</li><li>4.getName():获取当前线程的名字</li><li>5.setName():设置当前线程的名字</li><li>6.yield():释放当前CPU的执行权</li><li>7.join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才</li><li>结束阻塞状态。</li><li>8.stop():已过时。当执行此方法时，强制结束当前线程。</li><li>9.sleep(long millitime)：让当前线程“睡眠”指定时间的millitime毫秒)。在指定的millitime毫秒时间内，</li><li>当前线程是阻塞状态的。</li><li>10.isAlive()：返回boolean，判断线程是否还活着</li></ul><h2 id="多线程的调度"><a href="#多线程的调度" class="headerlink" title="多线程的调度"></a>多线程的调度</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>时间片</p><p>抢占式：高优先级的线程抢占CPU</p><h3 id="JAVA调度方法"><a href="#JAVA调度方法" class="headerlink" title="JAVA调度方法"></a>JAVA调度方法</h3><p>同优先级线程组成先进先出队列，先到先服务，使用时间片策略</p><p>对高优先级，使用优先调度的抢占式策略</p><p>MAX_PRIORITY:10:</p><p>MIN_PRIORITY:1</p><p>NORM_PRIORITY:5</p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>setPriority()</p><p>getPriority()</p><p><strong>说明</strong>：高优先级的线程要抢占低优先级线程CPU的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级的线程执行完才能执行低优先级的线程</p><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="/../image/concurrent/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A21.png"></p><h3 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h3><p>创建后尚未启动。</p><h3 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h3><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p>一旦调用start（），线程即进入runnable状态</p><h3 id="阻塞（Blocked）"><a href="#阻塞（Blocked）" class="headerlink" title="阻塞（Blocked）"></a>阻塞（Blocked）</h3><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h3 id="等待（Waiting）"><a href="#等待（Waiting）" class="headerlink" title="等待（Waiting）"></a>等待（Waiting）</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>-</td></tr></tbody></table><h3 id="计时等待（Timed-Waiting）"><a href="#计时等待（Timed-Waiting）" class="headerlink" title="计时等待（Timed Waiting）"></a>计时等待（Timed Waiting）</h3><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 &#x2F; 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>-</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>-</td></tr></tbody></table><h3 id="终止（Terminated）"><a href="#终止（Terminated）" class="headerlink" title="终止（Terminated）"></a>终止（Terminated）</h3><p>（1）可以是线程结束任务之后自己结束，</p><p>（2）或者产生了异常而结束。</p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>使用多线程的好处和坏处？</p><h5 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h5><p>（1）提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</p><p>（2）提高计算机系统CPU的利用率</p><p>（3）改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p><p>（4）可以分别设置各个任务的优先级以优化性能。</p><h5 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h5><p>（1）等候使用共享资源时造成程序的运行速度变慢。这些共享资源主要是独占性的资源 ,如打印机等。</p><p>（2）对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担 超过一定程度时,多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。</p><p>（3）线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。</p><p>（4）对公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个 线程存放的数据,从而使前一个线程的参数被修改;另外 ,当公用变量的读写操作是非原子性时,在不同的机 器上,中断时间的不确定性,会导致数据在一个线程内的操作产生错误,从而产生莫名其妙的错误,而这种错 误是程序员无法预知的。</p></li><li><p>多线程的使用场景</p><p>（1）程序需要同时执行两个或多个任务。</p><p>（2）程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。</p><p>（3）需要一些后台运行的程序时。</p></li><li><p>什么是线程并发？</p><p>一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</p></li><li><p>各种锁的使用场景？</p></li><li><p>常用的高并发队列？</p></li><li><p>锁和队列的区别？</p></li></ol><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.multithread;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> wenhoulai &lt;wenhoulai@kuaishou.com&gt;</span><br><span class="hljs-comment"> * Created on 2021-07-09</span><br><span class="hljs-comment"> * Java中线程实现的方式:</span><br><span class="hljs-comment"> * (1)一种是继承 Thread 类;</span><br><span class="hljs-comment"> * (2)另一种就是实现 Runnable 接口。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//实现 Runnable 接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;              <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//synchronized</span><br>            <span class="hljs-keyword">synchronized</span> (MyThread.class) &#123;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; :run, num = &quot;</span> + num);<br>                    num--;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;     <span class="hljs-comment">// 实例化对象</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br><br>        t1.setName(<span class="hljs-string">&quot;线程A&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;线程B&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;线程C&quot;</span>);<br><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t3.start() ;    <span class="hljs-comment">// 启动多线程</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123; <span class="hljs-comment">// 实现Runnable接口，作为线程的实现类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;              <span class="hljs-comment">// 覆写run()方法，作为线程 的操作主体</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            show();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; :run, num = &quot;</span> + num);<br>            num--;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>() ;     <span class="hljs-comment">// 实例化对象</span><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mt1) ;       <span class="hljs-comment">// 实例化Thread类对象</span><br><br>        t1.setName(<span class="hljs-string">&quot;线程A&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;线程B&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;线程C&quot;</span>);<br><br>        t1.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t2.start() ;    <span class="hljs-comment">// 启动多线程</span><br>        t3.start() ;    <span class="hljs-comment">// 启动多线程</span><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-keyword">return</span> s1 + s2 + s3;<br>&#125;<br></code></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    sb.append(s3);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁，<strong>对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作</strong>。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，<strong>ConcurrentHashMap中的分段锁称为Segment</strong>，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即**内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)**。</p><p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是<strong>先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁</strong>，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<strong>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p><h2 id="锁分类-按性质分类"><a href="#锁分类-按性质分类" class="headerlink" title="锁分类-按性质分类"></a>锁分类-按性质分类</h2><h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h3><p><strong>公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</strong>。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，<strong>通过构造函数指定该锁是否是公平锁，默认是非公平锁。</strong>非公平锁的优点在于吞吐量比公平锁大。对于<strong>Synchronized而言，也是一种非公平锁</strong>。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<strong>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式</strong>。悲观的认为，不加锁的并发操作一定会出问题。<strong>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</strong>从上面的描述我们可以看出，<strong>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景</strong>，不加锁会带来大量的性能提升。<strong>悲观锁在Java中的使用，就是利用各种锁</strong>。<strong>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</strong></p><h3 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h3><p><strong>独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有</strong>。<strong>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁</strong>。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<strong>对于Synchronized而言，当然是独享锁。</strong></p><h3 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h3><p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。互斥锁在Java中的具体实现就是<strong>ReentrantLock</strong>，<strong>读写锁在Java中的具体实现就是ReentrantReadWriteLock</strong></p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，<strong>其名字是Reentrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。</strong>可重入锁的一个好处是可一定程度避免死锁。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/wxd0108/p/5479442.html">Java中的多线程你只要看这一篇就够了</a></p><p><a href="https://blog.csdn.net/PorkBird/article/details/113695725">十：多线程</a></p><p><a href="https://blog.csdn.net/qq_35212671/article/details/52969068">多线程的优缺点</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划浅学</title>
    <link href="/2023/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%85%E5%AD%A6/"/>
    <url>/2023/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B5%85%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>现在，你点进来可能是准备弄清楚啥是动态规划，，，好学的孩子呀，请问你想了解的是金规划还是银规划呀？</p><p>很抱歉，本文没有准备将动态规划给讲的透彻，但是如果能让你对动态规划有一些新的体会，那么，这扇门就可以关上了。。。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a><strong>引例</strong></h2><p>每当听到动态规划这个词的时候，总有一种抽象，排斥的想法，我们准备先不管TM的动态规划是个啥，家在哪，在哪工作？玩个游戏先，这个游戏叫<strong>爬楼梯</strong></p><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>邻居家的小孩总是爱爬楼梯，有一天你去邻居家做客，看见小朋友又在爬楼梯。你，伫立良久…</p><p>这时，阿姨给你洗了个水果，招呼你快坐，你拉着阿姨，深情地看着她，又指了指小朋友，问道：假如你家有$n$ 阶楼梯，才能到达二楼。每次小朋友可以爬 $1 $或 $2$ 个台阶。小朋友有多少种不同的方法可以爬到楼顶呢？</p><p>阿姨：…</p><p>你能帮阿姨解决这个问题吗？</p><p><strong>分析</strong></p><p>（1）位于一个阶梯时，小朋友都只有俩种选择，下一次爬一个或俩个台阶</p><p>（2）爬到终点即结束</p><p>（3）凡事不懂，画个图先</p><p>假如阿姨家有$20$阶楼梯，爬到第$20$层有$F(20)$种方法</p><p><img src="/../image/ds/climbstairs.png" alt="climbstairs"></p><h4 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>（1）递归遍历所有情况</p><p>（2）终止条件为完成了一次完整的爬行过程，计数为1次</p><p>（3）叠加所有情况的次数，得到总次数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">climbStairs(int n)&#123;<br>// 自顶向下<br>// 每次爬1阶或2阶，爬n阶楼梯，总共有多少种方法<br>// 输入：楼梯数n<br>// 输出：每次爬1阶或2阶，爬n阶楼梯，总共有多少种方法<br>// 递归终止条件,n==0时算一次有效爬行方法<br>  if(n &lt; 0) return 0;<br>  if(n==0) return 1;<br>  int allSteps = 0;<br>  allSteps += climbStairs(steps, n - 1) + climbStairs(steps, n - 2);<br>  return allSteps;<br>&#125;<br></code></pre></td></tr></table></figure><p>在递归的过程中，发现，每次递归总会递归到部分重复的子问题，并且重复的子问题的计算方式依然相同，那么这些重复的计算是否还有必要？可否，每次记录后保存下来，下次直接用？确认这个子问题的结果的状态一旦计算好之后，与后续的状态无关，可以作为直接用的量。</p><p><img src="/../image/ds/climbStairs2.png" alt="climbStairs2"></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairsDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jumps, <span class="hljs-type">int</span> n)</span> &#123;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>阿姨长舒一口气，“打完收工…”，</p><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>过了几年，你又被邀请去邻居家做客，注意，你不姓王，这个小朋友恰巧又在家，蹦蹦跳跳，真可爱，阿姨热情地看了看你，开始陷入回忆，那还是几年前了，</p><p>你开心的和小朋友玩了掐来，蹦蹦跳跳，真好玩，你问小朋友，一共有5阶台阶，每阶台阶有跳跃的阶数限制，你最初位于第一个阶梯。有这么一个非负整数数组 $nums$ ，数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。请问你最少跳几次？</p><p>阿姨闻声而来：….</p><p>请问你能帮小朋友解决这个问题吗？</p><p>输入: $nums &#x3D; [2,3,1,1,4]$<br>输出: $2$<br>解释: 跳到最后一个位置的最小跳跃数是 $2$。<br>从下标为$ 0 $跳到下标为$ 1$ 的位置，跳 $1$ 步，然后跳 $3$ 步到达数组的最后一个位置。</p><p>我们需要求到达第$5$个台阶的最小步数，令为$F(4)$</p><p><img src="/../image/ds/jumpGames.png" alt="jumpGames"></p><h4 id="暴力求解-1"><a href="#暴力求解-1" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>（1）递归遍历每个位置所有可能跳跃的情况</p><p>（2）终止条件：跳完收工</p><p>（3）求最少次数，那么<strong>到达当前台阶的最少次数</strong>一定是由<strong>跳到当前台阶的之前的那个台阶的最少次数+1</strong>，比如跳到$F(4)$的最少步数一定是由能跳到$F(4)$的台阶$F(1)$和$F(3)$俩者的最少步数决定，所以记个临时变量，求每一阶台阶的最少次数，算到最后，求最少次数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs txt">jumpGame(int[] nums, int start)&#123;<br>// 自底向上<br>// 使用最少的跳跃次数到达数组的最后一个位置<br>// 输入：nums：非负整数数组，数组中的每个元素代表你在该位置可以跳跃的最大长度；start:表示每次跳跃的起点，有效位从0开始<br>// 输出：到达最后一个位置的最少次数<br>// 递归终止条件,跳跃起点到达最后一个位置<br>  if(start &gt;= nums.length - 1) return 0;<br>  minSteps = Integer.MAX_VALUE;<br>  for (int i = 1; i &lt;= jumps[start]; i++) &#123;<br>   // 当前起跳的起点<br>    cur = start + i;<br>    steps = jumpGame(nums, cur) + 1;<br>    if (steps == -1) &#123;<br>      continue;<br>    &#125;<br>    minSteps = min(minSteps, steps);<br>  &#125;<br>  if (minSteps != Integer.MAX_VALUE) &#123;<br>    return minSteps;<br>  &#125;<br>return -1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可以优化吗？"><a href="#可以优化吗？" class="headerlink" title="可以优化吗？"></a>可以优化吗？</h4><p>分析：同样存在大量重复计算；是否可以避免重复运算？</p><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jumpGamesDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] jumps)</span> &#123;<br><span class="hljs-comment">// 记录每一个位置到达终点的最小步数</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[jumps.length];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jumps.length; i++) &#123;<br>dp[i] = Integer.MAX_VALUE;<br>&#125;<br><br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; jumps.length; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= jumps[i]; j++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxPos</span> <span class="hljs-operator">=</span> i + j;<br><span class="hljs-keyword">if</span> (maxPos &gt;= jumps.length) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dp[maxPos] = Math.min(dp[maxPos], dp[i] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (dp[jumps.length - <span class="hljs-number">1</span>] == Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[jumps.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>小朋友跳了俩步，闯关成功，与此同时，阿姨也收工了，长呼一口气…</p><h4 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h4><p>相较于暴力解法，动态规划通过记忆数组记录重复运算的数据状态。</p><p>那TM的是么是动态规划？</p><p>是阿姨的功夫还是小朋友的才智，注意你不姓王。。。</p><p><strong>wikipedia大哥是这么说的</strong></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a href="https://en.wikipedia.org/wiki/Dynamic_programming">定义</a></h2><p><strong>Dynamic programming</strong> is both a <a href="https://en.wikipedia.org/wiki/Mathematical_optimization">mathematical optimization</a> method and a computer programming method. The method was developed by <a href="https://en.wikipedia.org/wiki/Richard_Bellman">Richard Bellman</a> in the 1950s and has found applications in numerous fields, from <a href="https://en.wikipedia.org/wiki/Aerospace_engineering">aerospace engineering</a> to <a href="https://en.wikipedia.org/wiki/Economics">economics</a>.</p><p>In both contexts <strong>it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a <a href="https://en.wikipedia.org/wiki/Recursion">recursive</a> manner</strong>. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively. Likewise, in computer science, if a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have optimal substructure.</p><p><a href="https://www.techiedelight.com/introduction-dynamic-programming/"><strong>你的邻居大哥是这么解释的：</strong></a></p><p><strong>Dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map, etc.).</strong> Each subproblem solution is indexed in some way, typically based on its input parameters’ values, to facilitate its lookup. So, the next time the same subproblem occurs, instead of recomputing its solution, one looks up the previously computed solution, thereby saving computation time. This technique of storing solutions to subproblems instead of recomputing them is called <code>memoization</code>.</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h2><p><strong>动态规划方法，是对一种具有重叠子问题的问题进行求解的技术《算法设计与分析基础》</strong>。将给定问题拆解为子问题，递归的去找到子问题的最优解来最优的解决问题，这也被称为最优子结构。每次将子问题的结果保存起来，可以称为记忆化，同时这也是动态规划的核心。</p><h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p><strong>如果给定问题可以拆解成多个子问题，且所有子问题都需要用同一种方式求解，那么它们就属于重叠子问题。</strong></p><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>**如果给定问题的最优解可以通过使用其子问题的最优解来获得，则给定问题具有最优子结构性质。 **</p><h4 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h4><p><strong>如果给定某一阶段的状态，这一阶段以后过程的发展，不受这阶段以前各段状态的影响，就称为无后效性，即：未来与过去无关。</strong></p><p>这几个特点保证了，通过数组形式记忆化记录下来各个子问题的状态结果可以复用，并且原问题可以由子问题的记忆结果计算得到。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>那么问题就来了，阿姨问了，动态规划和分治有啥区别吗？还有贪心呢？</p><p><strong>是时候表现自己了：</strong></p><p><strong>分治方法将问题划分为互不相交的子问题</strong>，递归的求解子问题，再将它们的解组合起来，求出原问题的解。</p><p>先举一个典型的分治思想的例子</p><p><strong><a href="http://t.zoukankan.com/l199616j-p-10604351.html">归并排序</a></strong></p><p>归并排序就是递归得将原始数组递归对半分隔，直到不能再分（只剩下一个元素）后，开始从最小的数组向上归并排序。</p><p><img src="/../image/ds/mergeSort.gif" alt="mergeSort"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 归并排序中的思路<br>MergeSort(arr[], l,  r)<br>If r &gt; l<br>     1. 找到数组中的中间点，把数组分为两部分<br>             middle m = (l+r)/2<br>     2. 对数组的左部分调用MergeSort 函数  <br>             Call mergeSort(arr, l, m)<br>     3. 对数组的右部分调用MergeSort 函数 <br>             Call mergeSort(arr, m+1, r)<br>     4. 合并2,3中的两部分<br>             Call merge(arr, l, m, r)<br></code></pre></td></tr></table></figure><p>与之相反，<strong>动态规划应用于子问题重叠的情况</strong>，即不同的子问题具有公共的子子问题（子问题的解是递归进行的，将其划分为更小的子子问题），在这种情况下，分治算法会做很多不必要的工作，会反复的求解哪些公共子问题，而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算，避免了这种不必要的计算工作。《算法导论》</p><p>我们在求解最优化问题过程中，但动态规划也有缺点，每个步骤都面临很多选择，很多选择可能是没有必要的，<strong>贪心算法，在每一步都做出当前最佳选择，总是找到局部最优解，寄希望这样的选择可以导致全局最优。</strong></p><p>比如刚才小朋友玩的跳跃游戏,我们使用了数组去记录跳到每个台阶的最少步数，但实际上我们更关心跳到终点位置的最少步数，所以我们可以每次去记录每个位置能跳到的最远位置，如果到达终点了，那么游戏结束。</p><p><img src="/../image/ds/jump.png" alt="jump"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jumpGamesGa</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxPosition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-comment">// 贪心：每次找能跳的最远的位置</span><br>maxPosition = Math.max(maxPosition, nums[i] + i);<br>     <span class="hljs-comment">// 由于求最少步数，所以只有当前位置到达上一轮能找到的跳的最远位置才更新步数</span><br><span class="hljs-keyword">if</span> (i == end) &#123; <span class="hljs-comment">//遇到边界，就更新边界，并且步数加一</span><br>end = maxPosition;<br>steps++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> steps;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结来说，动态规划和分治都是将大问题划分为小问题，小问题间独立是分治，小问题间有状态关系，并且需要用到之前状态是动态规划，不需要的是贪心法。</p><p><strong>情景小对话</strong></p><p>你：我已经知道了动态规划的精华了，是时候去拳打敬老院，脚踢幼儿园，新的一代小区霸主即将诞生</p><p>我：搞不赢的</p><p>你：搞得赢的</p><p>我：搞不赢的</p><p>你：我劝你</p><p><img src="/../image/ds/win.gif" alt="win"></p><h2 id="三个基本例子"><a href="#三个基本例子" class="headerlink" title="三个基本例子"></a>三个基本例子</h2><p>那么动态规划，到底难在哪里呢？私以为难在子问题的多样化和抽象化，</p><p>下文我们把每个子问题的计算结果称为状态，原问题与子问题的计算关系，称为状态与状态的关系。</p><p>（1）但对于可被记录子问题的状态数组来说，无非是用一维和N维来表示。</p><p>（2）对于当前状态可选择的选项来说，找出对其直接影响的状态</p><p>（3）对于可以使用动态规划问题，画图往往能清晰明了</p><h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><p>最近你在小区楼下开了个小卖店，今天阿姨领着小朋友来买棒棒糖，棒棒糖9块钱，阿姨掏出20块钱，恶狠狠的盯着你骂道：你TM棒棒糖金子做的呀？给我找最少的纸币，我只要1，2，5的纸币，其他的我不要。</p><p>我：你可以扫码嘛？</p><p>阿姨：扫码？扫码，扫码，。。。扫尼玛</p><p>打完收工…</p><p>但是生意还是要做的。。。接着找钱</p><p><strong>分析：</strong></p><p>（1）不管零钱多少，均需要拆解成对应面值的硬币，即可被找零的面值硬币固定</p><p>（2）每次被找零后，数值会减小，只有当零钱为0了才不需要被找零，除非你是个大善人，</p><p><img src="/../image/ds/coinChange.png" alt="coinChange"></p><p>考虑著名的找零问题的一般情形，需要找零金额为$n$,最少要用多少面值为$d_1&lt;d_2&lt;…&lt;d_m$的硬币。假设有$m$种面值为$d_1&lt;d_2&lt;…&lt;d_m$的硬币，$d_1&#x3D;1$，且每种面值的硬币数量无限可得。</p><h4 id="暴力求解-2"><a href="#暴力求解-2" class="headerlink" title="暴力求解"></a>暴力求解</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">coinChange(int[] coins, int amount)&#123;<br><span class="hljs-comment">// 自顶向下</span><br><span class="hljs-comment">// 使用最少的跳跃次数到达数组的最后一个位置</span><br><span class="hljs-comment">// 输入：coins：非负整数数组，可以被用来找零的零钱价值；amount:表示当前需要找零的金额</span><br><span class="hljs-comment">// 输出：找零需要的最少硬币数</span><br><span class="hljs-comment">// 递归终止条件,需要找零的金额为0，则结束，小于0，表示找不开，也结束找零方案</span><br>  <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 记录需要被找零的最少硬币数</span><br>  minChangeNum = Integer.MAX_VALUE;<br>  <span class="hljs-comment">// 在这里开始做选择</span><br>  <span class="hljs-keyword">for</span> (int coin : coins) &#123;<br>    changeNum = coinChange(coins, amount - coin);<br>    <span class="hljs-keyword">if</span> (changeNum == -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>minChangeNum = Math.min(minChangeNum, changeNum + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (minChangeNum != Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> minChangeNum;<br>&#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推关系</strong></p><p>$$\begin{cases}<br>F(n)&#x3D;min\left{ F(n-d_j)\right}+1&amp; \text{n&gt;0}\<br>F(0)&#x3D;0&amp; \text{n&#x3D;0}<br>\end{cases}$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ChangeMaking(D[<span class="hljs-number">1.</span>.m],n)<br><span class="hljs-comment">//应用动态规划算法求解找零问题，找出使硬币加起来等于n时所需的最少的硬币数目</span><br><span class="hljs-comment">//输入：正整数n，以及用于表示的币值的递增整数数组D[1..m]，D[1]=1</span><br><span class="hljs-comment">//输出：总金额等于n的硬币的最少的数目</span><br>F[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= m; j++)&#123;<br>  tmp = Math.min(F[i-D[j]],tmp)<br>  &#125;<br>F[i] = tmp+<span class="hljs-number">1</span>;<br>&#125;Í<br><span class="hljs-keyword">return</span> F[n];<br></code></pre></td></tr></table></figure><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doCoinChangeDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; i++) &#123;<br>dp[i] = Integer.MAX_VALUE;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br><span class="hljs-keyword">if</span> ((i - coin) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>dp[i] = Math.min(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (dp[n] == Integer.MAX_VALUE) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="币值最大化问题"><a href="#币值最大化问题" class="headerlink" title="币值最大化问题"></a>币值最大化问题</h3><p>小区最近来来一个小偷，你们小区只有一个入口，所以只能先从那家偷，但小区治安好，每俩家之间有一个警报器，如果相邻的俩家同时被偷了，那么警报器就会报警，小偷从小数学比较好，勘查地形后，又和邻居家的阿姨闲聊，套出了咱们小区每家每户室内的金币数额，回到家想着我该怎么偷才能在这和小区偷到最大化的价值的东西呢？</p><p><strong>分析</strong></p><p>（1）相邻金币不可同时获得</p><p>（2）要想币值最大化，相邻硬币必定要获得一个</p><p>考虑更一般的问题，给定一排$n$个硬币，其面值均为正整数，$c_1,c_2,..c_n$，这些整数并不一定俩俩不同，请问如何选择硬币，是的其在原始位置互不相邻的条件下，所选硬币的总金额最大。<strong>为方便形象化理解，这里<a href="https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">参考</a>了的解释和图形。</strong></p><p><img src="/../image/ds/robbery1.jpg" alt="robbery1"></p><p><img src="/../../../Java%E5%AD%A6%E4%B9%A0/%E6%96%87%E6%A1%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/pic/robbery2.jpg" alt="robbery2"></p><h4 id="暴力求解-3"><a href="#暴力求解-3" class="headerlink" title="暴力求解"></a>暴力求解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自底向上</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RobberySolution</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxRobberyMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values)</span> &#123;<br><span class="hljs-keyword">return</span> robberyMoney(values, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] values, <span class="hljs-type">int</span> start)</span> &#123;<br><span class="hljs-keyword">if</span> (start &gt;= values.length) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 在这里开始做选择</span><br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Math.max(values[start] + robberyMoney(values, start + <span class="hljs-number">2</span>), robberyMoney(values, start + <span class="hljs-number">1</span>));<br>maxValue += value;<br><span class="hljs-keyword">return</span> maxValue;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/ds/robbery4.jpg" alt="robbery4"></p><p><strong>递推关系</strong></p><p>$F(n)&#x3D;max \left{ F(n-2)+c_n, F(n-1) \right}$</p><p>$F(0) &#x3D; 0, F(1) &#x3D; c_1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">CoinRow(C[<span class="hljs-number">1.</span>.n])<br><span class="hljs-comment">//自底向上：求最大金额</span><br><span class="hljs-comment">//在满足所选硬币不相邻的条件下，从一排硬币中选择最大金额的硬币</span><br><span class="hljs-comment">//输入：数组C[1..n]保存n个硬币的面值</span><br><span class="hljs-comment">//输出：可选硬币的最大金额</span><br>F[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>F[<span class="hljs-number">1</span>] = C[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>F[i] = Math.max(C[i]+F[i-<span class="hljs-number">2</span>], F[i-<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">return</span> F[n]<br></code></pre></td></tr></table></figure><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoneyDp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>dp[i] = Integer.MIN_VALUE;<br>&#125;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>&#125;<br>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = Math.max(dp[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>dp[i] = Math.max(nums[i] + dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-keyword">return</span> Math.max(dp[n - <span class="hljs-number">1</span>], dp[n - <span class="hljs-number">2</span>]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../image/ds/robbery5.gif" alt="robbery5"></p><h4 id="空间优化版本"><a href="#空间优化版本" class="headerlink" title="空间优化版本"></a>空间优化版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">robberyMoneyDp2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">pprev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 每次循环，计算“偷到当前房子为止的最大金额”</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br><span class="hljs-comment">// 循环开始时，prev 表示 dp[k-1]，pprev 表示 dp[k-2]</span><br><span class="hljs-comment">// dp[k] = max&#123; dp[k-1], dp[k-2] + i &#125;</span><br><span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> Math.max(prev, pprev + i);<br>pprev = prev;<br>prev = curr;<br><span class="hljs-comment">// 循环结束时，prev 表示 dp[k]，pprev 表示 dp[k-1]</span><br>&#125;<br><br><span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="硬币收集问题"><a href="#硬币收集问题" class="headerlink" title="硬币收集问题"></a>硬币收集问题</h3><p>疫情防控期间，你们楼被要求隔离，在家无聊的很，你邀请邻居家的小朋友来家里面玩游戏，这个游戏呢能赚钱，你在$n\times m$格木板种放有一些硬币，每格的硬币数目最多为一个，小朋友在木板左上方需要收集尽可能多的硬币可能多的硬币并把它们带到右下方的单元格。每一步，小朋友可以从当前的位置向右移动一格或向下移动一格。当小朋友遇到一个有硬币的单元格时，就会将这枚硬币收集起来。设计一个算法找出机器人能找到的最大硬币数。</p><h4 id="暴力求解-4"><a href="#暴力求解-4" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>怎么解？你来想想？</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m], <span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span> &gt;= m &amp;&amp; <span class="hljs-built_in">col</span> == n)&#123;<br><span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">return</span> <span class="hljs-built_in">max</span>(RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m],<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>,<span class="hljs-built_in">col</span>),RobotCoinCollection(C[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..m],<span class="hljs-built_in">row</span>,<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>)) + C[<span class="hljs-built_in">row</span>, <span class="hljs-built_in">col</span>];<br></code></pre></td></tr></table></figure><h4 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h4><p>怎么做？你来想想？</p><p><strong>递推关系</strong></p><p>$$\begin{cases}<br>F(i,j)&#x3D;max\left{ F(i-1,j),F(i,j-1)\right}+c_{ij}&amp; \text{1&lt;&#x3D;i&lt;&#x3D;n,1&lt;&#x3D;j&lt;&#x3D;m}\<br>F(0,j)&#x3D;0,1&lt;&#x3D;j&lt;&#x3D;m,F(i,0)&#x3D;0&amp;\text{1&lt;&#x3D;i&lt;&#x3D;m}<br>\end{cases}$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">RobotCoinCollection(C[<span class="hljs-number">1.</span>.n,<span class="hljs-number">1.</span>.m])<br><span class="hljs-comment">//利用动态规划算法计算机器人在n*m木板上所能收集的最大硬币数</span><br><span class="hljs-comment">//机器人从(1,1)出发，每次向右或向下移动，从左上方移动到右下方</span><br><span class="hljs-comment">//输入：矩阵C[1..n,1..m],矩阵元素为1或0分别表示单元格中有一枚硬币或没有</span><br><span class="hljs-comment">//输出：机器人在单元格（n,m）中收集到的最大硬币数</span><br>F[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]=C[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>; j &lt;= m; j++)&#123;<br>F[<span class="hljs-number">1</span>,j] = F[<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>]+C[i,j];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>F[i,<span class="hljs-number">1</span>] = F[i-<span class="hljs-number">1</span>]+C[i,<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>; j &lt;= m; j++)&#123;<br>F[i,j] = max&#123;F[i-<span class="hljs-number">1</span>,j], F[i,j-<span class="hljs-number">1</span>]&#125;+C[i,j]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> F[n,m]<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 $0$ 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TXT">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。<br></code></pre></td></tr></table></figure><p><img src="/../image/ds/lcs.png" alt="lcs"></p><h4 id="暴力求解-5"><a href="#暴力求解-5" class="headerlink" title="暴力求解"></a>暴力求解</h4><p>假设$ m&lt;n$， 对于text1，我们可以暴力找出$2^m$次方个子序列，然后依次在text2中匹配，算法的时间复杂度会达到指数级$O(n*2^m)$。显然，暴力求解不太适用于此类问题。</p><h4 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> text1.charAt(i - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> text2.charAt(j - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><p>思考：每次计算新的一行的时候, 用到的都是上一行或者本行之前算过的数据, 所以可以优化到一维数组. 如下图:</p><p><img src="/../image/ds/lcs1.png" alt="lcs1"></p><p>比如计算$dp[3][2]$的时候, 用到的可能有他的左上角, 正上方, 和左侧数据. 左侧数据是在同一行, 上方数据还未被覆盖,还是上一行的老数据, 所以都可以直接用, 这里唯一注意就是左上方的数据, 因为在计算前一列的时候会被覆盖, 需要在被覆盖之前保存下旧值,因此二维的状态数组可以被优化为一维数组。</p><p><strong>二维DP优化一维DP</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence_1</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text1.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text2.length();<br><br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>dp[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">upLeft</span> <span class="hljs-operator">=</span> dp[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> text1.charAt(i - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> dp[j];<br><span class="hljs-type">int</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> text2.charAt(j - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>dp[j] = upLeft + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dp[j] = Math.max(dp[j - <span class="hljs-number">1</span>], dp[j]);<br>&#125;<br>upLeft = tmp;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题和记忆功能"><a href="#背包问题和记忆功能" class="headerlink" title="背包问题和记忆功能"></a>背包问题和记忆功能</h2><p>动态规划法建议，与其对交叠的子问题一次又一次地求解，还不如对每个较小的子问题只解一次并把结果记录在表中，这样从表中就可以得出原始问题的解。</p><p>记忆功能技术试图把自顶向下和自底向上的优势结合起来，对具有重叠子问题的问题求解。它用自顶向下的方式，<strong>对给定问题的必要子问题只作一次求解，并把结果记录在表中。</strong></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>给定$n$个重量为$w_1,w_n$,价值为$v_1,..v_n$的物品和一个承重量为$W$的背包，求这些物品中最有价值的一个子集，并且要能够装到背包中。</p><p>让我们来考虑一个由前$i$个物品$(1&lt;&#x3D;i&lt;&#x3D;n)$定义的实例，物品重量为$w_1,w_i$,价值为$v_1,..v_i$的物品</p><p>$F(i,j)$为该实例的最优解的物品的总价值，即，能够放进承重量为$j$的背包中的前$i$个物品中最有价值子集的总价值</p><p><img src="/../image/ds/beibao.png" alt="beibao"></p><p>（1）根据定义，在不包括第$i$个物品的子集中，最优子集的价值是$F(i-1,j)$</p><p>（2）在包括第$i$个物品的子集中（因此，$j-w_i&gt;&#x3D;0$）,最优子集是由该物品和前$i-1$个物品中能够放进承重量为$j-w_i$的背包的最优子集组成，这种最优子集的总价值等于$v_i+F(i-1,j-w_i)$</p><p>因此<br>$$<br>F(i,j)&#x3D;\begin{cases}max\left{ F(i-1,j),F(i-1,j-w_i)\right}, j-w_i&gt;&#x3D;0 \<br>F(i-1,j), j-w_i&lt;0<br>\end{cases}<br>$$<br>当$j&gt;&#x3D;0$时，$F(0,j) &#x3D; 0$</p><p>当$i&gt;&#x3D;0$时，$F(i,0) &#x3D; 0$</p><p>我们需要求的是$F(n,W)$</p><h3 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h3><p>动态规划涉及问题的解，满足一个用交叠子问题表示的递推关系，直接自顶向下对这样一个递推式求解导致一个算法要不止一次地解公共子问题，因此，效率非常低，一般来说时指数级，甚至更差；另一方面，经典的动态规划方法时自底向上工作的：它用所有较小子问题的解填充表格，但是每个子问题的解只解一次。</p><p>这种方法无法令人满意的一面是，在求解给定问题时，有些较小的子问题的解常常不是必需的。</p><p>由于这个缺点没有在自顶向下法中表现出来，所以自然而然的希望把自顶向下和自底向上的优势结合起来；</p><p>目标是得到这么一种方法，它只对必要的子问题求解，并且只解一次，这种方法存在，以<strong>记忆化功能</strong>为基础</p><p>该方法用自顶向下的方式对给定问题求解，但还需要维护一个类似自底向上动态规划使用的表格，一开始的时候，用“nu l l”初始化表中所有单元格，用来表示未被计算过，之后一旦需要计算一个新值，先检查是否被计算过，不为null则直接取值，否则递归调用进行计算，然后把返回的结构记录在表中。</p><p><img src="/../image/ds/beibao1.png" alt="beibao1"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">MFKnapsack(i,j)<br>//对背包问题实现记忆功能方法<br>//输入：一个非负整数i表示先考虑的物品数量，一个非负整数j表示背包的承重量<br>//输出：前i个物品的最优可行子集的价值<br>//注意：我们把输入数组Weights[1..n],Values[1..n]和表格F[0..n,0,,W]作为全局变量<br>//除了行0和列0用0初始化外，F的所有单元格都用-1初始化<br>if F[i,j] &lt; 0<br>if j &lt; Weights[i]<br>value = MFKnapsack(i-1,j)<br>else<br>  value = max(MFKnapsack(i-1,j),Values[i]+MFKnapsack(i-1,j-Weights[i]))<br>  F[i,j] = value<br>return F[i,j]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计基础与分析</title>
    <link href="/2023/10/24/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2023/10/24/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>一系列解决问题的明确指令，对于符合一定规范的输入，能够在有限的时间内获得要求的输出。</p><p>例子：最大公约数：俩个不全为0 的非负整数$m$和$n$的最大公约数记为$gcd(m,n)$​,代表能够整除（即余数为0）$m$ 和$n$的最大正整数。</p><p><strong>欧几里得算法</strong></p><p>$gcd(m,n)&#x3D;gcd(n, m \ mod \ n)(m \ mod \ n 表示m除以n 之后的余数)$​​​</p><p>$until\ m \ mod\ n &#x3D; 0$​​ 其中 $gcd(m, 0) &#x3D; m$</p><p><strong>证明</strong>：$m$​ , $n$​, 其中 $m &gt; n$​​</p><p>则 $m &#x3D; n*k+r \ , \ r &#x3D; m \ mod \ n, k是整数$​​​​​</p><p>假设存在$u$​​.使得$m &#x3D; s<em>u, n &#x3D; t</em>u$​​ , $u$​​ 为$m$​​,$n$​​的约数</p><p>则$r &#x3D; s<em>u - k</em>(t<em>u) &#x3D; (s-k</em>t)*u$​，</p><p> <strong>$m$​ 和 $n$​ 的约数也整除它们的余数$r$​​​</strong></p><p>所以$m$​ 和 $n$​  的任一约数同时也是$n$​和$r$​​ 的约数</p><p>反之，$n$和$r$ 的任一约数也是$m$ 和 $n$​​​  的约数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Euclid(m,n)</span><br><span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>  r = m / n;<br>  m = n;<br>  n = r;<br>&#125;<br><span class="hljs-keyword">return</span> m;<br></code></pre></td></tr></table></figure><p><strong>连续值检测算法</strong></p><p>选取俩者的最小值，向下连续检测数值</p><p>局限：当$m$, $n$​中输入为0时，结果是错误的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">t = min(m, n);<br><span class="hljs-keyword">while</span>(t &gt; <span class="hljs-number">0</span>）&#123;<br> <span class="hljs-keyword">if</span>(m % t == <span class="hljs-number">0</span> &amp;&amp; n % t == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> t;<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>    t--;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>质因数相乘法</strong></p><p>找出俩者公共的质因数，相乘得到结果</p><p>总结：对比三种计算最大公约数的方法，连续值检测法未能清晰规定算法输入的值域，当输入为0时，计算结果出错；质因数相乘法，对于如果计算质因数未能明确给定计算步骤。算法，应当清晰定义输入输出的值域，清晰定义计算的步骤。</p><p>例子：用来阐述一个不大于给定整数$n$的连续质数序列</p><p><strong>埃拉托色尼筛选法</strong></p><ol><li>初始化 $2$ ​~$n$​​ 的连续整数序列作为候选质数</li><li>第一次循环，消去$2$​的倍数（不包括2）</li><li>第二次循环，消去$3$的倍数（不包括3）</li><li>第三次循环，消去$5$的倍数（不包括5），4之前已经被消去了</li><li>…$until \ n$​</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Sievea(n)</span><br><span class="hljs-comment"> * 连续质数序列产生算法</span><br><span class="hljs-comment"> * Input:正整数n&gt;1</span><br><span class="hljs-comment"> * Output:包含所有小于等于n的质数的数组L</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">Sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span>[] A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt;= n; ++p)&#123;<br>A[p] = p;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt;= Math.sqrt(n); ++p)&#123;<br><span class="hljs-keyword">if</span>(A[p] != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> p * p;<br><span class="hljs-keyword">while</span>(j &lt;= n)&#123;<br>A[j] = <span class="hljs-number">0</span>;<br>j += p;<br>&#125;<br>&#125;<br>&#125;<br>List&lt;Integer&gt; L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; p &lt; n+<span class="hljs-number">1</span>; ++p)&#123;<br><span class="hljs-keyword">if</span>(A[p] != <span class="hljs-number">0</span>)&#123;<br>L.add(A[p]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们正在消去p的倍数，第一个值得考虑的是$p*p$ ，因其他更小的倍数$2p, \cdots ,(p-1)<em>p$已经在之前的步骤中从序列中消去了，所以$p</em>p &lt;&#x3D; n$， 因此$p &lt;&#x3D; sqrt(n)$​​</p><h2 id="算法问题求解基础"><a href="#算法问题求解基础" class="headerlink" title="算法问题求解基础"></a>算法问题求解基础</h2><p>算法是问题程序化解决方案</p><ol><li><p>理解问题：输入输出范围、特殊情况考虑（边界条件等）</p></li><li><p>确定：</p><p>（1）计算方法（了解设备性能，并行&#x2F;串行）</p><p>（2）精确或近似解法</p><p>（3）算法设计技术</p></li><li><p>设计算法：确定合适的数据结构，伪代码描述，流程图</p></li><li><p>正确性证明</p></li><li><p>分析算法：简单（易读，易懂），一般（问题的一般性，接受输入的一般性），时间、空间</p></li><li><p>根据算法写代码</p></li></ol><h1 id="算法效率分析基础"><a href="#算法效率分析基础" class="headerlink" title="算法效率分析基础"></a>算法效率分析基础</h1><h3 id="效率分析框架"><a href="#效率分析框架" class="headerlink" title="效率分析框架"></a>效率分析框架</h3><ol><li>算法的时间效率和空间效率都用输入规模的函数进行度量</li><li>算法基本操作的执行次数来度量算法的时间效率；通过计算算法消耗的额外存储单元的数量来度量空间效率</li><li>输入规模相同的情况下，部分算法的效率会有显著差异，需要区分最差效率，平均效率，最优效率</li><li>当算法的输入规模趋向于无限大时，它的运行时间（消耗的额外空间）函数的增长次数</li></ol><h3 id="渐近符号和基本效率类型"><a href="#渐近符号和基本效率类型" class="headerlink" title="渐近符号和基本效率类型"></a>渐近符号和基本效率类型</h3><p>效率分析框架主要关心一个算法的基本操作次数的增长次数，并把它作为算法效率的主要指标，主要用三种渐进符号表示</p><ol><li>$O(g(n))$:增长次数小于等于$g(n)$​(及其常数倍，$n$​趋向于无穷大)的函数集合</li><li>$\Omega(n)$:代表增长次数大于等于$g(n)$(及其常数倍，$n$趋向于无穷大)的函数集合</li><li>$\Theta(n)$：增长次数等于$g(n)$(及其常数倍，$n$趋向于无穷大)的函数集合</li></ol><p>利用极限比较增长次数</p><p>基本的效率类型</p><table><thead><tr><th>类型</th><th>名称</th><th align="left">注释</th></tr></thead><tbody><tr><td>$1$</td><td>常量</td><td align="left">为数很少的效率最高的算法，很难举出几个合适的例子，因为典型情况下，当输入的规模变得无穷大时，算法的运行时间也会趋向于无穷大</td></tr><tr><td>$log \ n$​</td><td>对数</td><td align="left">一般来说，算法的每一次循环都消去问题规模的一个常数因子，注意，一个对数算法不可能关注它的输入的每一个部分（哪怕是输入的一个固定部分）：对任何能做到这一点的算法最起码拥有线性运行时间</td></tr><tr><td>$n$</td><td>线性</td><td align="left">扫描规模为$n$的列表（顺序查找）的算法属于这个类型</td></tr><tr><td>$n \ log \ n$​</td><td>线性对数</td><td align="left">许多分治算法，包括合并排序和快速排序的平均效率，都属于这个类型</td></tr><tr><td>$n^2$</td><td>平方</td><td align="left">一般来说，这是包含两重嵌套循环的算法的典型效率。线性代数中一些著名的算法属于这一类型</td></tr><tr><td>$n^3$</td><td>立方</td><td align="left">一般来说，这是包含三重嵌套循环的算法的典型效率。线性代数中一些著名的算法属于这一类型</td></tr><tr><td>$2^n$</td><td>指数</td><td align="left">求$n$个元素集合的所有子集是这种类型的典型例子，“指数”这个术语常常被用在一个更广的层面上，不仅包括这种类型，还包括那些增长速度更快的类型</td></tr><tr><td>$n!$</td><td>阶乘</td><td align="left">求$n$个元素集合的完全排列的算法是这种类型的典型例子</td></tr></tbody></table><h3 id="非递归算法的数学分析"><a href="#非递归算法的数学分析" class="headerlink" title="非递归算法的数学分析"></a>非递归算法的数学分析</h3><p>例1：从$n$​个元素的列表中查找元素最大值的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">MaxElement(A[<span class="hljs-number">0.</span>..n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 求给定数组中的最大元素的值</span><br><span class="hljs-comment">// 输入：实数数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：A中最大元素的值</span><br>maxVal = A[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>  <span class="hljs-keyword">if</span>(A[i] &gt; maxVal)&#123;<br>    maxVal = A[i];<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxVal;<br></code></pre></td></tr></table></figure><h4 id="分析非递归算法时间效率的通用方案"><a href="#分析非递归算法时间效率的通用方案" class="headerlink" title="分析非递归算法时间效率的通用方案"></a>分析非递归算法时间效率的通用方案</h4><ol><li>决定用哪个（哪些）参数表示输入规模</li><li>找出算法的基本操作（作为一个规律，总是位于算法的最内层循环）</li><li>检查基本操作的执行次数是否之依赖于输入规模，如果还依赖于一些其他的特性，则最差效率，平均效率以及最优效率（如有必要）需要分析研究。</li><li>建立一个算法的基本操作执行次数的求和表达式</li><li>利用求和运算的标准共识和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数</li></ol><p>例2: 元素唯一性问题，验证给定数组的$n$个元素是否全部唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">UniqueElements(A[<span class="hljs-number">0</span>,,n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">//验证给定数组中的元素是否全部唯一</span><br><span class="hljs-comment">//输入：数组A[0,,n-1]</span><br><span class="hljs-comment">//输出：如果A中的元素全部唯一，返回true</span><br><span class="hljs-comment">//     否则，返回false</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n-<span class="hljs-number">1</span>; j++)&#123;<br>    <span class="hljs-keyword">if</span>(A[i] == A[j])&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>例3:矩阵乘积计算问题 $C&#x3D;AB$​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MatrixMultiplication(A[0..n-1,0..n-1],B[0..n-1,0..n-1])</span><br><span class="hljs-comment">// 用基于定义的算法计算俩个n阶矩阵的乘积</span><br><span class="hljs-comment">// 输入：两个n阶矩阵A，B</span><br><span class="hljs-comment">// 输出：矩阵C=ABx</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>C[i,j]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; k++)&#123;<br>C[i,j] = C[i,j]+A[i,k]+B[k,j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> C;<br></code></pre></td></tr></table></figure><p>例4: 十进制正整数在二进制表示中的数字个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Binary(n)</span><br><span class="hljs-comment">// 输入：十进制正整数n</span><br><span class="hljs-comment">// 输出：n在二进制表示中的二进制数字个数</span><br>count = <span class="hljs-number">1</span>；<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">1</span>)&#123;<br>count += <span class="hljs-number">1</span>;<br>n = Math.floor(n/<span class="hljs-number">2</span>);<span class="hljs-comment">//向下取整</span><br>&#125;<br><span class="hljs-keyword">return</span> count;<br></code></pre></td></tr></table></figure><h3 id="递归算法的数学分析"><a href="#递归算法的数学分析" class="headerlink" title="递归算法的数学分析"></a>递归算法的数学分析</h3><p>例1:计算 $n!$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// F(n) = n!</span><br><span class="hljs-comment">// 递归计算n!</span><br><span class="hljs-comment">// 输入：非负整数n</span><br><span class="hljs-comment">// 输出：n!的值</span><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">return</span> F(n-<span class="hljs-number">1</span>)*n;<br>&#125;<br></code></pre></td></tr></table></figure><p>当$n &gt; 0$, $F(n)&#x3D;F(n-1)+1$</p><p>$M(n)$表示乘法的执行次数，则$M(n) &#x3D; M(n-1)+1$</p><p>$M(0) &#x3D; 0$</p><p>$M(n)&#x3D;M(n-1)+1&#x3D;…&#x3D;M(n-i)+i&#x3D;…&#x3D;M(n-n)+n&#x3D;n$</p><h4 id="分析递归算法时间效率的通用方案"><a href="#分析递归算法时间效率的通用方案" class="headerlink" title="分析递归算法时间效率的通用方案"></a>分析递归算法时间效率的通用方案</h4><ol><li>决定用哪个（哪些）参数作为输入规模的度量标准</li><li>找出算法的基本操作</li><li>检查一下，对于相同规模的不同输入，基本操作的执行次数是否可能不同。如果有这个可能，则必须对最差效率，平均效率以及最优效率做单独研究</li><li>对于算法基本操作的执行次数，建立一个递推关系以及相应的初始条件</li><li>解这个递推式，或者至少确定它的解的增长次数</li></ol><p>例2: 汉诺塔游戏</p><p>$M(n)&#x3D;M(n-1)+1+M(n-1)&#x3D;2M(n-1)+1$</p><p>$M(1)&#x3D;1$</p><p>$M(n)&#x3D;2[2M(n-2)+1]+1&#x3D;2^2M(n-2)+1$​</p><p>…</p><p>$M(n)&#x3D;2^{n-1}M(n-(n-1))+2^{n-1}+1$</p><p>$M(n)&#x3D;2^n-1$</p><h3 id="计算斐波那契数列讨论"><a href="#计算斐波那契数列讨论" class="headerlink" title="计算斐波那契数列讨论"></a>计算斐波那契数列讨论</h3><p>$F(n)&#x3D;F(n-1)+F(n-2)$</p><p>$F(0)&#x3D;0,F(1)&#x3D;1$</p><h3 id="算法的经验分析"><a href="#算法的经验分析" class="headerlink" title="算法的经验分析"></a>算法的经验分析</h3><h4 id="对算法效率做经验分析的通用方案"><a href="#对算法效率做经验分析的通用方案" class="headerlink" title="对算法效率做经验分析的通用方案"></a>对算法效率做经验分析的通用方案</h4><ol><li>了解实验的目的</li><li>决定用来度量效率的度量标准M和度量单位（用操作次数还是直接用时间）</li><li>决定输入样本的特性（它的范围和大小等）</li><li>为实验准备算法（或若干算法）的程序实现</li><li>生成输入样本</li><li>对输入样本运行算法（或若干算法），并记录观察到的实验数据</li><li>分析获得的实验数据</li></ol><h1 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h1><h2 id="选择排序和冒泡排序"><a href="#选择排序和冒泡排序" class="headerlink" title="选择排序和冒泡排序"></a>选择排序和冒泡排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择出当前元素应该放置的元素（升序排列，找出当前轮次的最小元素），依次循环</p><p>$\Theta(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">SelectionSort(A[<span class="hljs-number">0</span>],,A[n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法用选择排序对给定的数组排序</span><br><span class="hljs-comment">// 输入：一个可排序的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：升序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; ++i)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">minPos</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br><span class="hljs-keyword">if</span>(A[minPos] &gt; A[j])&#123;<br>minPos = j;<br>&#125;<br>swap(A[i], A[minPos]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>比较相邻元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">BubbleSort(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法用冒泡排序对数组A[0.n-1]进行排序</span><br><span class="hljs-comment">// 输入：一个可排序数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; ++i)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n-<span class="hljs-number">1</span>-i; ++j)&#123;<br><span class="hljs-keyword">if</span>(A[j] &gt; A[j+<span class="hljs-number">1</span>])&#123;<br>swap(A[j], A[j+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="顺序查找和蛮力字符串匹配"><a href="#顺序查找和蛮力字符串匹配" class="headerlink" title="顺序查找和蛮力字符串匹配"></a>顺序查找和蛮力字符串匹配</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">SequentialSearch(A[<span class="hljs-number">0.</span>.n],K)<br><span class="hljs-comment">// 顺序查找的算法实现。它用了查找键来作限位器</span><br><span class="hljs-comment">// 输入：一个n个元素的数组A和一个查找键K</span><br><span class="hljs-comment">// 输出：第一个值等于K的元素的位置，如果找不到这样的元素，返回-1</span><br>A[n] = K；<br>i = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">while</span>(A[i] != K)&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">if</span>(i &lt; n)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果查找序列是有序的话，可以查找到或者大于查找键后直接返回</p><h3 id="蛮力字符串匹配"><a href="#蛮力字符串匹配" class="headerlink" title="蛮力字符串匹配"></a>蛮力字符串匹配</h3><p>给定一个$n$​个字符串组成的串[称为文本(text)],一个$m(m&lt;&#x3D;n)$个字符的串[称为模式(pattern)]，从文本中寻找匹配模式的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">BrureForeStringMatch(T[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>],P[<span class="hljs-number">0.</span>.m-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 该算法实现了蛮力字符串匹配</span><br><span class="hljs-comment">// 输入：一个n个字符的数组T[0..n-1],代表一段文本</span><br><span class="hljs-comment">// 一个m个字符的数组P[0..m-1],代表一个模式</span><br><span class="hljs-comment">// 输出：如果查找成功，返回文本的第一个匹配子串中第一个字符的位置，否则返回-1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-m+<span class="hljs-number">1</span>; )&#123;<br>j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; P[j] = T[i+j])&#123;<br>j++;<br><span class="hljs-keyword">if</span>(j == m)&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>最坏情况 $O(nm)$​​</p><h2 id="最近对和凸包问题的蛮力算法"><a href="#最近对和凸包问题的蛮力算法" class="headerlink" title="最近对和凸包问题的蛮力算法"></a>最近对和凸包问题的蛮力算法</h2><h3 id="最近对问题"><a href="#最近对问题" class="headerlink" title="最近对问题"></a>最近对问题</h3><p>最近点对问题要求在一个包含$n$个点的集合中，找出距离最近的俩个点。</p><p>一个重要的应用是统计学中的聚类分析。对于$n$个数据点的集合，层次聚类分析希望基于某种相似度度量标准将数据点构成的簇按照层次关系组织起来。</p><p>（1）对于<strong>数值型数据</strong>，相似度度量标准的通常采用<strong>欧几里得距离</strong>；</p><p>（2）对于<strong>文本和其他非数值型数据</strong>，通常采用诸如<strong>汉明距离</strong>这样的相似度度量标准。</p><p>$d(p_i,p_j)&#x3D;\sqrt {(x_i-x_j)^2+(y_i-y_j)^2}$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">BruteForceClosestPoints(p)<br><span class="hljs-comment">// 使用蛮力法求平面中距离最近的俩点</span><br><span class="hljs-comment">// 输入：一个n（n&gt;=2)个点的列表p,p1=(x1,y1)...pn=(xn,yn)</span><br><span class="hljs-comment">// 输出：俩个最近点的距离</span><br>$d = \infin$<br><span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)</span>&#123;<br><span class="hljs-keyword">for</span>(j = i+<span class="hljs-number">1</span>; j &lt; n+<span class="hljs-number">1</span>; ++j)&#123;<br>d = min(d, sqrt((xi-xj)^<span class="hljs-number">2</span>+(yi-yj)^<span class="hljs-number">2</span>));<span class="hljs-comment">//sqrt是平方根函数</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d;<br></code></pre></td></tr></table></figure><p>基本操作是计算平方根，其实可以转而比较平方本身，而避免平方根计算，算法的基本操作转为求平方，加快内层循环的速度。</p><h3 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h3><p>凸集合：对于平面上的一个点集合（有限的&#x2F;无限的），如果以集合中的任意俩点$p$,$q$为端点的线段都属于该集合，我们说这个集合是凸的。</p><p>凸包概念：对于平面上$n$个点的集合，它的凸包就是包含所有这些点（或者在内部，或者在边界上）的最小的凸多边形。</p><p>凸包：一个点集合$S$的凸包是包含$S$的最小凸集合，（“最小”意指$S$ 的凸包一定是所有包含$S$ 的凸集合的子集）。</p><p>定理：任意包含$n&gt;2$个点（不共线的点）的集合S的凸包是以S中的某些点为顶点的凸多边形（如果所有的点都位于一条直线上），多边形退化为一条线段，但它的俩个端点仍然包含在S中。</p><p>凸集合中的<strong>极点</strong>：对于任何以集合中的点为端点的线段来说，它不是这种线段的中点。</p><p>单纯形法用于解决现行规划问题，找到极点也就解出了凸包问题。</p><p>对于一个$n$个点集合中的俩个点$p_i,p_j$​​​,当且仅当该集合中的其他点都位于穿过这俩点的直线的同一边时，他们的连线是该集合凸包边界的一部分。<strong>对每一对点都做一遍检验之后，满足条件的线段构成了凸包的边界。</strong></p><p>在坐标平面上穿过俩个点$(x_1,y_1),(x_2,y_2)$的直线有下列方程定义：</p><p>$ax+by&#x3D;c$​</p><p>其中</p><p>$a&#x3D;y_2-y_1$</p><p>$b &#x3D; x_1-x_2$</p><p>$c&#x3D;x_1y_2-y_1x_2$</p><p>这样直线可以将平面划分为俩个半平面，其中一个半平面的点都满足$ax+by&gt;c$</p><p>另一个半平面中的点$ax+by&lt;c$（直线上的点满足$ax+by&#x3D;c$）。</p><p>为检验某些点事都位于直线的同一边，只需把每个点带入$ax+by-c$,检验这个表达式的符号是否相同。</p><h2 id="穷举查找"><a href="#穷举查找" class="headerlink" title="穷举查找"></a>穷举查找</h2><h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>(Traveling salesman problem, TSP), 要求找出一条$n$ 个给定城市间的最短路径，使我们在回到出发的城市之前，对每个城市都只访问一次。</p><p>该问题可以表述为求一个图的最短哈密顿回路。</p><p>哈密顿回路：一个对图的每一个顶点都只穿越一次的回路。</p><p>可以假设，所有的回路都开始和结束于相同的特定顶点。可以通过生成$n-1$个中间城市的组合来得到所有的旅行线路，计算这些线路的长度，然后求得最短的线路。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>给定$n$个重量为$w_1,w_2,…w_n$，价值为$v_1,v_2,…v_n$的物品和一个承重为$W$的背包，求这些物品中一个最有价值的子集，并且能够装到背包中。</p><p>穷举查找需要考虑给定的$n$个物品集合的所有子集，为了找出可行的子集（也就是说，总重量不超过背包承重能力的子集），要计算出每个子集的总重量，然后找出它们中间价值最大的子集。</p><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><p>有$n$个任务需要分配给$n$个人执行，一个任务对应一个人（每个任务只分配给一个人，每个人只分配一个任务），对于每一对$i,j&#x3D;1,2,…,n$来说，将第$j$个任务分配给第$i$个人的成本是$C[i,j]$。该问题是要找出总成本最小的分配方案。</p><p>一般情况下，需要考虑的排列数量是$n!$，对于该问题有一个效率高效得多的算法是<strong>匈牙利算法</strong>。</p><h2 id="深度优先查找和广度优先查找"><a href="#深度优先查找和广度优先查找" class="headerlink" title="深度优先查找和广度优先查找"></a>深度优先查找和广度优先查找</h2><h3 id="深度优先查找"><a href="#深度优先查找" class="headerlink" title="深度优先查找"></a>深度优先查找</h3><p>可以从任意顶点开始访问图的顶点，然后把该顶点标记为已访问。在每次迭代的时候，该算法紧接着处理与当前顶点邻接的未访问顶点。（如果有若干个这样的顶点，可以任意选择一个顶点，选择哪一个邻接的未访问的候选顶点主要是由表示图的数据结构决定的）。过程持续直到遇到一个终点，该顶点的所有邻接点都已被访问过，在后退到起始顶点。如果未访问的顶点仍然存在，该算法必须从其中一顶点开始，重复上述过程。</p><p>用栈跟踪深度优先查找的操作是比较方便的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">DFS(G)<br><span class="hljs-comment">//  实现给定图的深度优先查找遍历</span><br><span class="hljs-comment">// 输入：图G=（V，E）</span><br><span class="hljs-comment">// 输出：图G的顶点，按照DFS遍历第一次访问到的先后次序，用连续的整数标记将V</span><br><span class="hljs-comment">//      中的每个顶点标记为0，表示“未访问”</span><br>count = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">for</span>(Vertex v: V)&#123;<br><span class="hljs-keyword">if</span>(v.markedCount == <span class="hljs-number">0</span>)&#123;<br>    dfs(v);<br>  &#125;<br>&#125;<br>dfs(v);<br><span class="hljs-comment">// 递归访问所有和v相接的未被访问的顶点，然后按照全局变量count的值</span><br><span class="hljs-comment">// 根据遇到他们的先后顺序，给他们赋值相应的数字</span><br>count++;<br><span class="hljs-comment">// 标记v访问</span><br>v.markedCount = count;<br><span class="hljs-keyword">for</span>(Vertex w : V)&#123;<br>  <span class="hljs-comment">// w是v的邻接点并且未被访问过</span><br>  <span class="hljs-keyword">if</span>(w.adjacent(v) &amp;&amp; w.markedCount == <span class="hljs-number">0</span>)&#123;<br>dfs(w);    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DFS产生俩种节点的排列顺序，第一次访问顶点（入栈）的次序和顶点称为终点（出栈）的次序。</p><p>DFS在访问所有和厨师顶点有路径相连的顶点后结束，可以用于检查一个图的连通性以及连通分量，利用图的DFS森林形式的表示法可以检查图中是否包含回路。</p><h3 id="广度优先查找"><a href="#广度优先查找" class="headerlink" title="广度优先查找"></a>广度优先查找</h3><p>首先访问所有和初始顶点邻接的点，然后是离它俩条边的所有未访问顶点，以此类推，直到所有与初始顶点同在一个连通分量中的顶点都被访问过了为止。如果仍然存在未被访问的顶点，该算法必须从图中的其他连通分量重的任意顶点重新开始。</p><p>使用队列来跟踪广度优先查找操作时比较方便的。</p><p>该队列从遍历的初始顶点开始，将该顶点标记为已访问，在每次迭代的时候，该算法找出所有和队头顶点邻接的未访问顶点，将它们标记为已访问，再把他们入队，然后将队头顶点从队列中移去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">BFS(G)<br><span class="hljs-comment">// 实现给定图的广度优先遍历</span><br><span class="hljs-comment">// 输入：图G=（V，E）</span><br><span class="hljs-comment">// 输出：图G的顶点，按照BFS遍历访问到的先后次序，用连续的整数标记</span><br><span class="hljs-comment">//      将V中的每个顶点标记为0，表示还“未访问”</span><br>count = <span class="hljs-number">0</span>；<br><span class="hljs-keyword">for</span>(Vertex v: V)&#123;<br>  <span class="hljs-keyword">if</span>(v.markerdCount == <span class="hljs-number">0</span>)&#123;<br>    bfs(v);<br>  &#125;<br>&#125;<br>bfs(v);<br><span class="hljs-comment">//访问所有和v连接的未访问顶点，然后按照全局变量count的值</span><br><span class="hljs-comment">//根据访问他们的先后次序，给它们赋上相应的数字</span><br>count++;<br>v.markedCount = count;<br><span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>  <span class="hljs-keyword">for</span>(Vertex w : V)&#123;<br>    <span class="hljs-keyword">if</span>(w.adjacent(v) &amp;&amp; w.markedCount == <span class="hljs-number">0</span>)&#123;<br>      count++;<br>      w.markedCount = count;<br>      queue.push(w);<br>    &#125;<br>  &#125;<br>  queue.pop(w);<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS 只产生顶点的一种排序，因为队列时先进先出的结构，所以顶点入队和出队次序一致。</p><p>BFS检查图的连通性和无环性，可以求俩个顶点间边的数量最少的路径。</p><h1 id="减治法"><a href="#减治法" class="headerlink" title="减治法"></a>减治法</h1><p>利用来一个问题给定实例的解和同样问题较小实例的解之间的某种关系，一旦建立了这种关系，我们既可以从顶向下也可以由底向上来运用该关系。</p><p><strong>3种主要变化形式</strong></p><ul><li>减去一个常量</li><li>减去一个常量因子</li><li>减去的规模是可变的</li></ul><p>减一技术：规模为$n$​的问题—&gt;规模为$n-1$​的问题—&gt;子问题的解—&gt;原问题的解</p><p>减半技术：规模为$n$​的问题—&gt;规模为$n&#x2F;2$​​的问题—&gt;子问题的解—&gt;原问题的解</p><p>减可变规模：计算最大公约数的欧几里得算法$gcd(m,n)&#x3D;gcd(n,m\ mode\  n)$​</p><h2 id="减一技术"><a href="#减一技术" class="headerlink" title="减一技术"></a>减一技术</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>数组$A[0..n-1]$</p><p>遵循减一的思路，假设数组$A[0…n-2]$​​已经有序，$A[0]\le … \le A[n-2]$​​​</p><p>则对于$A[n-1]$,我们需要做的就是在这些有序的元素中为$A[n-1]$找到合适的位置，插入进去。</p><p>一般来说，可以从左至右扫描该有序数组的子数组，直到遇到一个小于等于$A[n-1]$的元素，然后把$A[n-1]$​插在这个元素的后面，这种被称为<strong>直接插入排序</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">InsertionSort(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// 用插入排序对给定数组排序</span><br><span class="hljs-comment">// 输入：n个可排序数组构成的一个数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列的数组A[0..n-1]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>val = A[i]<br>j = i-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; val)&#123;<br>A[j+<span class="hljs-number">1</span>] = A[j];<br>j--;<br>&#125;<br>A[j+<span class="hljs-number">1</span>] = val;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>有向图：一个对所有边都指定方向的图</p><p>邻接矩阵和邻接链表是俩种表示有向图的主要手段。</p><p>当采用这这俩种方式表示时，无向图和有向图只有俩个显著的差异：</p><p>（1）有向图的邻接矩阵并不一定表现出对称性</p><p>（2）有向图的一条边在图的邻接链表中只有一个相应的节点（不是俩个）</p><p>有向图的遍历，深度优先和广度优先查找是主要的遍历算法</p><p>在对图的边引入方向后，讨论一个问题，</p><p>例如：</p><p>一个必修课集合${}$${C_1,C_2,C_3,C_4,C_5}$​学生必须在某个阶段修完这几门课程，可以按照任何次序学习这些课程，只要满足下列条件：</p><p>（1） $C_1$​和$C_2$​没有任何先决条件</p><p>（2）修完$C_1$​，$C_2$​才能修$C_3$​</p><p>（3）修完$C_3$​才能修$C_4$​</p><p>（4）修完$C_3$​和$C_4$​才能修$C_5$​​</p><p>（5）每个学习只能修一门课程</p><p>是否可以按照这种次序列出它的顶点，使得对于图中每一条边来说，边的起始顶点总是排在边的结束顶点之前（是不是能够求出该图节点的这样一个序列？）这个问题称为<strong>拓扑排序</strong></p><p>如果有向图具有一个有向的回路，该问题无解，为使得拓扑排序成为可能，充要条件是问题中的图必须是一个无环有向图。</p><p>有俩种高效的算法是既可以验证是否是无环有向图，又可以在是的情况下输出拓扑排序的一个顶点序列。</p><p><strong>第一种：深度优先查找的一个简单应用（DFS）</strong>：执行一次DFS遍历，并记住顶点变成死端（即推出遍历栈）的顺序。</p><p>将该次序反过来就得到拓扑排序的一个解，当然，在遍历的时候不能遇到回边。</p><p>如果遇到一条回边，该图就不是无环有向图，并且对它的顶点的拓扑排序是不可能的。</p><p>当一个顶点$v$退出DFS栈时，在比$v$更早退出栈的顶点中，不可能存在顶点$u$拥有一条从$u$到$v$的边（否则，$(u,v)$会成为一条回边），所以，在退栈的队列中，任何这样的顶点$u$都会排在$v$的后面，并且在逆序队列中会排在$v$的前面。</p><p><strong>第二种：基于减一技术的一个直接实现（源删除算法）：</strong>不断地做这样一件事，在余下的有向图中求出一个源（source），它是一个没有输入边的顶点，然后把它和从它出发的边都删除，（如果有多个这样的源，可以任意选择一个。如果这样的源不存在，算法停止，因为该问题无解）顶点被删除的次序就是拓扑排序问题的一个解。</p><p>拓扑排序在计算机科学中有很多应用，包括程序编译中的指令调度，电子表格单元格的公式求值顺序以及解决链接器中的符号依赖问题。</p><h3 id="生成组合对象的算法"><a href="#生成组合对象的算法" class="headerlink" title="生成组合对象的算法"></a>生成组合对象的算法</h3><p>组合对象中最重要的类型就是排列，组合，给定集合的子集。离散数学有一个分支名为组合数学，专门研究组合对象。我们这里感兴趣的主要是如何生成它们。</p><h4 id="生成排列"><a href="#生成排列" class="headerlink" title="生成排列"></a>生成排列</h4><p>假如需要对元素进行排列的集合是从$1$到$n$的简单整数集合，解释为$n$个元素${a_1，..a_n}$​的元素下标。</p><p>对于生成${1,…n}$的所有$n!$个排列的问题：</p><p>减一技术：将问题规模减一，转化成$(n-1)!$​​个排列，把$n$插入$n-1$个元素的每一种排列中的$n$个可能位置中去，来得到较大规模问题的一个解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Johnson <span class="hljs-title function_">Trotter</span><span class="hljs-params">(n)</span><br><span class="hljs-comment">// 实现用来生成排列的Johnson Trotter算法</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出： &#123;1,...,n&#125;的所有排列的列表</span><br>将第一个排列初始化为<span class="hljs-number">12.</span>.n<br><span class="hljs-title function_">while</span><span class="hljs-params">(存在一个移动元素)</span>&#123;<br>   求最大的移动元素k<br>   把k和它箭头指向的相邻元素互换<br>   调转所有大雨k的元素的方向<br>   将新排列添加到列表中<br>&#125;<br></code></pre></td></tr></table></figure><p>对于$n&#x3D;3$，字典序：</p><p>$123, 132，213，231，312，321$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">LexicograhicPermute(n)<br><span class="hljs-comment">// 以字典序产生排列</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出：在字典序下&#123;1,..,n&#125;所有排列的列表</span><br>init(第一个排列为<span class="hljs-number">12.</span>.n)<br><span class="hljs-keyword">while</span>(最后一个排列有俩个连续升序的元素)&#123;<br>  找出使得a_i&lt;a_i+<span class="hljs-number">1</span>的最大的i（a_i+<span class="hljs-number">1</span>&gt;a_i+<span class="hljs-number">2</span>&gt;..&gt;a_n）<br> <br>  找到使得a_i&lt;a_j的最大索引j(j&gt;=i+<span class="hljs-number">1</span>)因为a_i &lt; a_i+<span class="hljs-number">1</span><br>  <span class="hljs-comment">// 交换a_i，a_j</span><br>  swap(a_i,a_j);<br>  <span class="hljs-comment">// 将a_i+1到a_n反序</span><br>  reverse(a,i+<span class="hljs-number">1</span>,n);<br>  <span class="hljs-comment">// 将这个新排列添加到列表中</span><br>  resultList.add(a);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成子集"><a href="#生成子集" class="headerlink" title="生成子集"></a>生成子集</h4><p>幂集：一个集合的所有子集的集合称为它的幂集。</p><p>是否存在一种生成位串的最小变化算法，使得每一个位串和它直接前趋之间仅仅相差一位（就子集来说，我们希望每一个子集和它的直接前趋之间的区别，要么是增加一个元素，要么是删除一个元素，但俩者不能同时发生）</p><p>》〉》〉》 二进制反射格雷码（binary reflected Gray code）</p><p>例如$n&#x3D;3$,</p><p>$000 \ 001 \ 011\ 010\ 110\ 111\ 101\ 100$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">BRGC(n)<br><span class="hljs-comment">// 递归生成n位的二进制反射格雷码</span><br><span class="hljs-comment">// 输入：一个正整数n</span><br><span class="hljs-comment">// 输出：所有长度为n的格雷码位串列表</span><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>  表L包含位串<span class="hljs-number">0</span>和位串<span class="hljs-number">1</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">// 生成长度为n-1的位串列表L1</span><br> L1 = BRGC(n-<span class="hljs-number">1</span>)<br>  <span class="hljs-comment">// 把表L1倒序后复制给L2</span><br>  copy(reverse(L1), L2)<br>  <span class="hljs-comment">// 把0加到表L1中的每个位串前面</span><br>  L1.addFront(<span class="hljs-number">0</span>)<br>  <span class="hljs-comment">// 把1加到表L2中的每个位串前面</span><br>  L2.addFront(<span class="hljs-number">1</span>)<br>  <span class="hljs-comment">// 把表L2添加到表L1后面得到表L</span><br>  L = L1.addTail(L2)<br>&#125;<br><span class="hljs-keyword">return</span> L;<br></code></pre></td></tr></table></figure><h2 id="减常因子算法"><a href="#减常因子算法" class="headerlink" title="减常因子算法"></a>减常因子算法</h2><p>减常因子算法常常具有对数时间效率，非常高效，因此实例并不多。</p><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>对于有序数组来说，折半查找是一种性能卓越的算法，它通过逼阿胶查找键K和数组中间元素$A[m]$来完成查找工作，如果它们相等，算法结束。否则，如果$K&lt;A[m]$​，就对数组的前半部分执行该操作，如果$K&gt;A[m]$,则对数组的后半部分执行该操作。</p><p>折半查找是基于递归的思想，也可以非递归算法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">BinarySearch(A[<span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>],K)<br><span class="hljs-comment">// 实现非递归的折半查找</span><br><span class="hljs-comment">// 输入：一个升序数组A[0..n-1]和一个查找键K</span><br><span class="hljs-comment">// 输出：一个数组元素的下标，该元素等于K；如果没有这样一个元素，返回-1</span><br>l = <span class="hljs-number">0</span>, r = n-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span><br>  <span class="hljs-keyword">if</span>(K == A[m]) <span class="hljs-keyword">return</span> m;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &lt; A[m]) r = m-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(K &gt; A[m]) l = m+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>$C_{avg} \ &#x3D; \log_2n$​​</p><h3 id="假币问题"><a href="#假币问题" class="headerlink" title="假币问题"></a>假币问题</h3><p>在$n$枚外观相同的硬币中，有一枚假币。</p><p>在一架天平上，可以比较任意俩组硬币，可以通过观察天平向右倾还是向左倾还是水平，判断俩组硬币重量是否相同，或者哪一组更重，要求设计一个高效的算法来检测出这枚假币。</p><p>假设假币相对真币较轻</p><p>最自然的思路是将$n$枚硬币分为俩摊，每堆有$n&#x2F;2$枚硬币</p><p>（1）如果$n$​​为奇数，就留下一枚额外的硬币，然后把俩堆硬币放在天平上，如果俩堆硬币重量相同，那么放在旁边的即为假币；否则循环比较较轻的一堆硬币</p><p>（2）如果$n$​为偶数，则循环比较较轻的一堆硬币</p><p>$W(n)&#x3D;W(n&#x2F;2)+1,当n&gt;1，W(1)&#x3D;0$</p><p>$W(n)&#x3D;log_2n$</p><p>这并不是最高效的解法，如果把硬币分为三堆呢？每堆$n&#x2F;3$枚硬币，将会更好</p><p>$W(n)&#x3D;log_3n$</p><h3 id="俄式乘法"><a href="#俄式乘法" class="headerlink" title="俄式乘法"></a>俄式乘法</h3><p>假设$n$和$m$​是俩个真整数，需要计算它们的乘积。</p><p>同时，我们用$n$​的值作为实例规模的度量标准，这样，</p><p>（1）如果$n$​是偶数，一个规模为原来一半的实例必须要对$n&#x2F;2$​进行处理，对于该问题较大的实例的解和较小实例的解的关系，有一个显而易见的公式：</p><p>$n<em>m&#x3D;n</em>2m&#x2F;2$​</p><p>（2）如果$n$是奇数，只需要对该公式做轻微调整：</p><p>$n<em>m&#x3D;(n-1)&#x2F;2</em>2m+m$</p><p>通过应用这个公式，并以$1*m&#x3D;m$作为算法停止的条件。</p><p>既可以采用递归也可以采用迭代计算，该算法只包括折半，加倍，相加这几个操作，硬件实现速度也很快，使用移位即可完成折半和加倍操作</p><h3 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h3><p>$n$个人围成一个圈，并将他们从$1$到$n$​​编上号码。从编号为$1$的那个人那里开始这个残酷的计数，每次消去第二个人直到只留下最后一个幸存者。</p><p>要求算出幸存者的号码$J(n)$​</p><p>（1）如果$n$为偶数，$n&#x3D;2k$，对整个圆圈处理第一遍之后，生成了同样问题的规模减半的实例。唯一差别是位置的编号。</p><p>例如一个初始位置为$3$​的人在第$2$​轮会处于$2$​号位置上，初始位置$5$​的人会处在$3$​号位置上，以此类推，</p><p>$J(2k)&#x3D;2J(k)-1$​​</p><p>（2）如果$n$​为奇数，$n&#x3D;2k+1$​。第一轮消去所有偶数位置上的人，如果把紧接着消去的位置 $1$​上的人也加进来，留下一个规模为$k$​的实例。这里，为了得到与新的位置编号相对应的初始位置编号，我们必须把新的位置编号乘$2$​再加上$1$​,因此对于奇数$n$​,</p><p>$J(2k+1)&#x3D;2J(k)+1$</p><p>由于这个游戏可以看成一个环形，位置的变化是一种环形内位置的移位过程，我们可以对$n$本身做一次向左的循环移位来得到$J(n)$，</p><p>$J(6)&#x3D;J(110_2)&#x3D;101_2&#x3D;5$</p><p>$J(7)&#x3D;J(111_2)&#x3D;111_2&#x3D;7$​</p><h2 id="减可变规模算法"><a href="#减可变规模算法" class="headerlink" title="减可变规模算法"></a>减可变规模算法</h2><p>在减治法的第三个主要变化形式中，算法在每次迭代时，规模减小的模式和另一次迭代时不同的，计算最大公约数的欧几里得算法提供了这类算法的一个非常好的例子。</p><h3 id="计算中值和选择问题"><a href="#计算中值和选择问题" class="headerlink" title="计算中值和选择问题"></a>计算中值和选择问题</h3><p><strong>选择问题</strong>是求一个$n$个数列表的第$k$个最小元素的问题。</p><p>这个数字被称为<strong>第$k$​个顺序统计量</strong></p><p>对于$k&#x3D;1,k&#x3D;n$，可以扫描元素列表，获取最小或最大元素。</p><p>该问题的一个有意思的情况是在$k&#x3D;n&#x2F;2$​​时，要求找出这样一个元素，列表中的一半元素哒，又比一半元素小。这个元素称为<strong>中值</strong>。</p><p>（1）一种方法是先将列表排序，选出第$k$个元素。算法的运行时间取决于排序算法的效率，选用类似合并排序的算法，效率是$O(nlog_n)$​</p><p>当然，整个列表的排序可能没有必要，毕竟我们只是找出第$k$小的元素</p><p>（2）划分的思路。将一个给定列表根据某个值$p$（例如列表的第一个元素）进行划分，对列表元素进行重新整理，使左边部分包含所有小于等于$p$的元素，紧接着是中轴本身，右边是所有大于或等于$p$的元素</p><p>又俩种主要的划分算法，$Lomuto划分$，$Hoare算法$​</p><p>$|所有小于等于p的元素|$      $|p|$     $|所有大于或等于p的元素|$​</p><p>这里讨论$Lomuto划分$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LomutoPartition(A[l,,r])</span><br><span class="hljs-comment">// 采用Lomuto算法，用第一个元素作为中轴子对数组进行划分</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]的一个子数组A[l..r],它由左右俩边的索引l和r(l&lt;=r)定义</span><br><span class="hljs-comment">// 输出：A[l..r]的划分和中轴的新位置</span><br>p = A[l]<br>s = l<br><span class="hljs-title function_">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i = l+<span class="hljs-number">1</span>; i &lt;= r; i++)</span>&#123;<br><span class="hljs-keyword">if</span>(A[i] &lt; p)&#123;<br>s = s+<span class="hljs-number">1</span>;<br>    swap(A[s],A[i]);<br>&#125;<br>&#125;<br>swap(A[l],A[s]);<br><span class="hljs-keyword">return</span> s;<br></code></pre></td></tr></table></figure><p>如何利用划分列表来寻找第$k$最小元素呢？</p><p><strong>快速选择</strong>：假设列表时以数组实现的，其元素索引从$0$开始，而$s$是划分的分割位置，也就是划分后中轴所在元素的索引。</p><p>（1）如果$s&#x3D;k-1$，中轴$p$即为第$k$小的元素</p><p>（2）如果$s&gt;k-1$​，第$k$​小元素就是被划分数组左边部分的第$k$​​小元素</p><p>（3）如果$s&lt;k-1$​,第$k$​小元素就是被划分数组右边部分的第$(k-s)$​​​小元素　</p><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Quickselect(A[l..r],k)</span><br><span class="hljs-comment">// 用基于划分的递归算法解决选择问题</span><br><span class="hljs-comment">// 输入：可排序的数组A[0..n-1]的子数组A[l..r]和整数k(1&lt;=k&lt;=r-l+1)</span><br><span class="hljs-comment">// 输出：A[0..n-1]中第k小元素的值</span><br>s = LomutoPartition(A[l,,r]) <span class="hljs-comment">// 或者另一个划分算法</span><br><span class="hljs-keyword">if</span> s == l+k-<span class="hljs-number">1</span> <span class="hljs-keyword">return</span> A[s]<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; l+k-<span class="hljs-number">1</span> Quickslect(A[l,,s-<span class="hljs-number">1</span>], k)<br><span class="hljs-keyword">else</span> Quickselect(A[s+<span class="hljs-number">1</span>,,r], l+k-<span class="hljs-number">1</span>-s)<br></code></pre></td></tr></table></figure><p>非递归</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>如果是求取第$k$大元素，类似</p><p><strong>效率分析</strong>：$O(n^2)$</p><h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>作为减可变规模算法的下一个例子，我们考虑一个查找有序数组的算法，<strong>插值查找</strong></p><p>不同于折半查找总是查找键和给定有序数组的中间元素进行比较（也因此把问题规模消减了一半），插值查找为了找到用来和查找键进行比较的数组，考虑了查找键的值。</p><h3 id="二叉树的查找和插入"><a href="#二叉树的查找和插入" class="headerlink" title="二叉树的查找和插入"></a>二叉树的查找和插入</h3><p>二叉查找树：这种二叉查找树的节点包含了可排序项集合中的元素，每个节点一个元素，并使得对于每个节点来说，所有左子树的元素都小于子数根节点的元素，所有右子树的元素都大于子树根节点的元素。</p><p>当在这样一棵树中查找给定值$v$的元素时，可以递归采用下面的方法。</p><p>（1）如果这棵树为空，则查找失败；</p><p>（2）如果这棵树不为空，把$v$和根节点$K$​作比较，</p><ul><li>如果等于$K$，查找结束​</li><li>如果比$K$​​小，继续在左子树中查找</li><li>如果比$K$​​​大。继续在右子树中查找</li></ul><p>一棵查找树的规模的最佳度量标准就是树的高度，树的高度的减少通常都不相同，这给我们一个很好的减可变规模算法的例子。</p><p>查找效率最差是当二叉查找树只有一边时，效率为$\Theta(n)$​,平均查找效率为$\Theta(logn)$​</p><h3 id="拈游戏"><a href="#拈游戏" class="headerlink" title="拈游戏"></a>拈游戏</h3><p>一般来说，该游戏中会有若干堆棋子，但我们先来考单堆棋子的版本。</p><p>现在只有一堆$n$个棋子。</p><p>俩个玩家轮流从堆中拿走最少一个，最多$m$​个棋子。每次拿走的棋子数都可以不同，但能够拿走的上下限数量不变。如果每个玩家都做出了选择，哪个玩家能够胜利拿到最后那个棋子？是先走的还是后走的？</p><p>当且仅当$n \mod\ (m+1) \neq 0$​​​，胜局</p><p>因此，胜利的策略是每次拿走$n \mod\ (m+1)$​个棋子，如果背离这个策略，则会把胜局留给对手</p><p>一般来说，拈游戏包含$I&gt;1$堆棋子，每堆的棋子数分别$n_1,n_2,…n_I$​。每次走的时候，玩家可以从任意一堆棋子中拿走任意允许数量的棋子，甚至可以把一堆都拿光。游戏的目的同样是成为最后一个还能走的玩家。</p><p>这种形式的拈游戏的解出人意料，竟然基于堆中棋子数的二进制表示。$b_1,b_2,..b_I$​分别表示各堆棋子数的二进制表示。计算它们的二进制数位和，也称为拈和，即对每一位分别求和并忽略进位。</p><p>可以证实，当且仅当二进制数位和中包含至少一个$1$​时，该实例是一个胜局，只包含$0$​时是一个败局。</p><p>例如：$n_1&#x3D;3,n_2&#x3D;4,n_3&#x3D;5$​,数位和（拈和）:011+100+101&#x3D;010。该实例对于先走的玩家来说是一个胜局，要找到该局的一个胜手，玩家需要改变三个位串在中的一个，使得新的二进制数位和仅包含$0$​。因此，先手玩家从第一堆中拿走$2$​个棋子。</p><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>分治法是按照一下方案工作的：</p><ol><li>将一个问题划分为同一类型的若干子问题，子问题最好规模相同。</li><li>对这些子问题求解（一般使用递归方法，但在问题规模足够小时，有时也会利用另一个算法）</li><li>有必要的话，合并这些子问题的解，已得到原始问题的答案。</li></ol><p>分治法对于并行计算时非常理想的，因为各个子问题都可以由各自的CPU同时计算。</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>合并排序</strong>是成功应用分治技术的一个完美例子。</p><p>对一个需要排序的数组$A[0..n-1]$ ，合并排序把它一分为二：$A[0..\lfloor n&#x2F;2\rfloor-1]$和$A[\lfloor n&#x2F;2\rfloor..n-1]$。并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MergeSort(A[0..n-1])</span><br><span class="hljs-comment">// 递归调用mergersort来对数组A[0..n-1]排序</span><br><span class="hljs-comment">// 输入：一个可排序的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出：非降序排列数组A[0..n-1]</span><br><span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>copy A[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>] to B[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>]<br>copy A[[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1.</span>.n-<span class="hljs-number">1</span>] to C[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>]<br>MergeSort(B[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>])<br>MergeSort(C[<span class="hljs-number">0.</span>.[n/<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>])<br><span class="hljs-comment">// Merge()见下文</span><br>Merge(B,C,A)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对俩个有序数组的合并</strong>，可以通过下面的算法完成。</p><p>初始状态下，俩个指针（数组下标）分别指向俩个带合并数组的第一个元素。</p><p>然后比较这俩个元素的大小，将较小的元素添加到一个新创建的数组中。</p><p>接着，被复制数组的指针后移，指向较小元素的后继元素。</p><p>上述操作，一直持续到两个数组中的一个被处理完为止。</p><p>最后，在未处理完的数组中，剩下的元素被复制到新数组的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Merge(B[0..p-1],C[0..q-1],A[0..p+q-1)</span><br><span class="hljs-comment">// 将俩个有序数组合并为一个有序数组</span><br><span class="hljs-comment">// 输入：俩个有序数组B[0..p-1],C[0..q-1]</span><br><span class="hljs-comment">// 输出：A[0..p+q-1]中已经有序存放了B和C中的元素</span><br>i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; p &amp;&amp; j &lt; q)&#123;<br><span class="hljs-keyword">if</span>(B[i] &lt;= C[j])&#123;<br>A[k] = B[i];<br>i++;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>A[k] = C[j];<br>j++;<br>&#125;<br>k++;<br>&#125;<br><span class="hljs-keyword">if</span>(i == p)&#123;<br>copy C[j..q-<span class="hljs-number">1</span>] to A[k..p+q-<span class="hljs-number">1</span>]<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>copy B[i..p-<span class="hljs-number">1</span>] to A[k..p+q-<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>合并排序算法的效率，简单起见，假设$n$是$2$的乘方</p><p>键值比较次数$C(n)$的递归关系式为：</p><p>当$n&gt;1$,$C(n)&#x3D;2C(n&#x2F;2)+C_{merge}(n),C(1)&#x3D;0$</p><p>$C_{merge}(n)$即合并阶段进行键值比较的次数。每做一步都需要进行一次比较，比较之后，俩个数组中尚需处理的元素总个数减$1$。在最坏情况下，无论那个数组都不会为空，除非另一个数组只剩下最后一个元素（举例来说，最小的元素轮流来自于不同的数组）。因此，对于最坏情况来说，$C_{merge}(n)&#x3D;n-1$,有以下递推式：当$n&gt;1$,$C_{worst}(n)&#x3D;2C_{worst}(n&#x2F;2)+(n-1),C_{worst}(1)&#x3D;0$</p><p>$C_{worst}(n)&#x3D;nlog_2n-n+1$,效率属于$\Theta(nlogn)$。</p><p>合并排序的显著优点在于其稳定性，主要缺点是该算法需要线性的额外空间。主要有俩类变化形式。</p><p>首先，算法可以自底向上合并数组的一个个元素对，然后再合并这些有序对，以此类推，这就避免了使用堆栈处理递归调用时的时间和空间开销。</p><p>其次，可以吧数组划分为待排序的多个部分，再对它们递归排序，最后将其合并在一起。这个方案尤其适合在对存放在二级存储空间的文件进行排序。也被称为多路合并排序。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是另一种基于分治技术的重要排序算法。不像合并排序是按照元素在数组中的位置对他们进行划分，快速排序按照元素的值对它们进行划分。</p><p>建立了一个划分之后，$A[s]$已经位于它在有序数组中的最终位置，接下来我们可以继续对$A[s]$前和$A[s]$后的子数组分别进行排序。</p><p><strong>快排与合并排序的不同之处在于</strong>：在合并排序算法中，将问题划分成俩个子问题是很快的，算法的主要工作在于合并子问题的解，而在快速排序中，算法的主要工作在于划分阶段，而不需要再去合并子问题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Quicksort(A[l..r])</span><br><span class="hljs-comment">// 用Quicksort对子数组排序</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]中的子数组A[l..r],由左右下表l和r定义</span><br><span class="hljs-comment">// 输出：非降序排列的子数组A[l..r]</span><br><span class="hljs-keyword">if</span> (l &lt; r)&#123;<br>  <span class="hljs-comment">// s是分裂位置</span><br>s = Partition(A[l..r])<br>QuickSort(A[l..s-<span class="hljs-number">1</span>])<br>QuickSort(A[s+<span class="hljs-number">1.</span>.r])<br>&#125;<br></code></pre></td></tr></table></figure><p>作为一种划分算法，我们当然可以使用之前讨论的Lomuto划分，也可以使用Hoare划分。Hoare是英国杰出的计算机科学家，快速排序算法的发明者。</p><p>与以前一样，我们要选择一个中轴，接下来会根据该元素的值来划分子数组，选择中轴有许多不同的策略，这个选择与算法的效率有关，暂定我们选择子数组中的第一个元素，即$p&#x3D;A[l]$。</p><p>分别从子数组的俩端进行扫描，并且将扫描到的元素与中轴比较，从左到右的扫描（用指针$i$表示）从第二个元素开始，因为我们希望小于中轴的元素位于子数组的左半部分，扫描会忽略小于中轴的元素，直到遇到第一个大于等于中轴的元素才停止。从右至左的扫描（下面用指针$j$表示）从最后一个元素开始。因为我们希望大于中轴的元素位于子数组的右半部分，扫描会忽略大于中轴的元素，直到遇到第一个小于等于中轴的元素才会停止。</p><p>俩次扫描全部停止以后取决于扫描的指针是否相交：会发生$3$种不同的情况。</p><p>（1）扫描指针$i$和$j$不相交，即$i&lt;j$，$swap(A[i],A[j])，i++,j–$，</p><p>（2）扫描指针$i$和$j$相交，即$i&#x3D;&#x3D;j$，被指向元素的值一定等于$p$</p><p>（3）$i&gt;&#x3D;j$，$swap(A[i],A[j])$。</p><p><strong>为啥当遇到与中轴元素相等的元素时值得停止扫描？</strong></p><p>因为当遇到有很多相同元素的数组时，这个方法可以将数组分得更加平均，从而使得算法运行得更快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HoarePartition(A[l..r])</span><br><span class="hljs-comment">// 以第一个元素为中轴，对子数组进行划分</span><br><span class="hljs-comment">// 输入：数组A[0..n-1]中的子数组A[l..r]，由左右下标l和r定义</span><br><span class="hljs-comment">// 输出：A[l..r]的一个划分，分裂点的位置作为函数的返回值</span><br>p = A[l]<br>i = l;j = r+<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span>(i &lt; j)&#123;<br><span class="hljs-keyword">while</span>(A[i] &lt; p)&#123;<br>i++;<br>&#125;<br><span class="hljs-keyword">while</span>(A[j] &gt; p)&#123;<br>j--;<br>&#125;<br>swap(A[i],A[j]);<br>&#125;<br><span class="hljs-comment">// 当i&gt;=j撤销后最后一次交换</span><br>swap(A[i],A[j]);<br>swap(A[l],A[j]);<br><span class="hljs-keyword">return</span> j;<br></code></pre></td></tr></table></figure><p>快速排序时不稳定的，同时还需要一个堆栈来存储那些还没有被排序的子数组的参数。尽管可以通过总是先对较短子数组排序的方法来使堆栈的大小降低到$O(logn)$，但是还是比堆排序$O(1)$的空间效率差。</p><h2 id="二叉树遍历及其相关特性"><a href="#二叉树遍历及其相关特性" class="headerlink" title="二叉树遍历及其相关特性"></a>二叉树遍历及其相关特性</h2><p>如何把分治技术应用到二叉树中。二叉树定义为若干节点的一个有限集合，它要么为空，要没由一个根和俩棵树称为$T_L$和$T_R$的不相交二叉树构成。这俩棵二叉树分别为根的左右子树。</p><p>定义本身把二叉树划分为同样类型的俩个更小的组成部分-左子树和右子树。</p><p>作为一个例子，考虑计算二叉树高度的递归算法。</p><p><strong>树的高度</strong>：从叶子到根之间的最长路径长度。</p><p>二叉树的高度计算：它是根的左右子树最大高度加$1$（加$1$代表根所在的那一层），如果把空树的高度定义为$-1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Height(T)</span><br><span class="hljs-comment">// 递归计算二叉树的高度</span><br><span class="hljs-comment">// 输入：一棵二叉树T</span><br><span class="hljs-comment">// 输出：T的高度</span><br><span class="hljs-keyword">if</span> T == <span class="hljs-literal">null</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> max(Height(T_L), Height(T_R))+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>给定的二叉树的节点数$n(T)$来度量问题实例的规模。为计算俩数中的较大值，算法执行比较次数等于算法执行的加法操作次数$A(n(T))$.对于$A(n(T))$,有如下递推关系：</p><p>当$n(T)&gt;0$,$A(n(T))&#x3D;A(n(T_{left}))+A(n(T_{right}))+1$</p><p>$A(0)&#x3D;0$</p><p>在了解这个递推关系之前，先指出，加法运算并不是该算法中最频繁执行的操作，那是哪个操作呢？检查树是否为空，这才是二叉树算法中的典型操作。</p><p>对于非空完全为叉树来说，$n$和$x$分别代表父母节点和叶子极点的数量</p><p>回到$Height$算法中，检查树是否为空的比较操作次数为：</p><p>$C(n)&#x3D;n+x&#x3D;2n+1$</p><p>而加法操作的次数为：$A(n)&#x3D;n$</p><p><strong>二叉树的三种经典遍历算法</strong></p><p>前序遍历：根在访问左右子树之前就被访问</p><p>中序遍历：根在访问左子树后，但在访问右子树之前被访问</p><p>后序遍历：根在访问左右子树之后被访问</p><h2 id="大整数乘法和Strassen矩阵乘法"><a href="#大整数乘法和Strassen矩阵乘法" class="headerlink" title="大整数乘法和Strassen矩阵乘法"></a>大整数乘法和Strassen矩阵乘法</h2><p>俩个数的乘法和俩个方阵的乘法，俩个算法都巧妙的运用分治技术获得更好的渐进效率。</p><h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>如果我们使用经典的笔算算法来对俩个$n$位整数相乘，第一个数中的$n$个数字都要分别被第二个数中的$n$个数字相乘，这样$n^2$次位乘。虽然看上去设计一个乘法次数小于$n^2$的算法是不可能的，但事实证明并非如此。</p><p>举例：$23 \times 14$</p><p>$23&#x3D;2\times10^1+3\times10^0$</p><p>$14&#x3D;1\times10^1+4\times10^0$</p><p>$23\times14&#x3D;(2\times10^1+3\times10^0)\times(1\times10^1+4\times10^0)$</p><p>$23\times14&#x3D;(2\times1)\times10^2+(2\times4+3\times1)+(3\times4)\times10^0&#x3D;322$</p><p>但这和笔算算法一样，都是用来$4$次位乘，由于$2\times1$和$3\times4$是无论如何都需要计算的。可以复用它们的乘积</p><p>$2\times4+3\times1&#x3D;(2+3)\times(1+4)-(2\times1)-(3\times4)$</p><p> <strong>计算俩个$n$位整数$a$和$b$的积$c$</strong></p><p>其中$n$是一个正的偶数。我们从中间把数字一分为二，</p><p>把$a$的前半部分记为$a_1$,后半部分记为$a_0$;同理$b$记为$b_1$和$b_0$</p><p>$a&#x3D;a_110^{n&#x2F;2}+a_0$</p><p>$b&#x3D;b_110^{n&#x2F;2}+b_0$</p><p>$c&#x3D;a\times b&#x3D;(a_110^{n&#x2F;2}+a_0)\times (b_110^{n&#x2F;2}+b_0)&#x3D;(a_1\times b_1)10^n+(a_1b_0+a_0\times b_1)10^{n&#x2F;2}+(a_0\times b_0)&#x3D;c_210^n+c_110^{n&#x2F;2}+c_0$</p><p>其中$c_2&#x3D;a_1 \times b_1,c_0&#x3D;a_0\times b_0, c_1&#x3D;(a_1+a_0)\times (b_1+b_0)-(c_2+c_0)$</p><p>$c_2$是它们前半部分的积，$c_0$是它们后半部分的积，$c_1$是$a$俩部分和与$b$俩部分和的积减去$c_2$与$c_0$的和。</p><p>如果$n&#x2F;2$也是偶数，即可以应用相同的方法计算$c_2$和$c_0$和$c_1$。</p><p>因此，如果$n$是$2$的乘方，我们就得到了一个计算俩个$n$位数积的递归算法。当$n&#x3D;&#x3D;1$时停止。</p><p>该算法会做多少次位乘呢？</p><p>因为$n$位数的乘法需要对$n&#x2F;2$位数做三次乘法运算，乘法次数$M(n)$递归式如下：</p><p>当$n&gt;1$时，$M(n)&#x3D;3M(n&#x2F;2),M(1)&#x3D;1$</p><p>当$n&#x3D;2^k$时，可以反向替换法对它求解：</p><p>$M(2^k)&#x3D;3M(2^{k-1})&#x3D;3^iM(2^{k-i})&#x3D;3^kM(2^{k-k})&#x3D;3^k$</p><p>因为$k&#x3D;log_2n$，$M(n)&#x3D;3^{log_2n}&#x3D;n^{log_23}\approx n^{1.585}$,</p><p>$a^{log_bc}&#x3D;c^{log_ba}$</p><p>该算法需要的加法和减法的次数呢？</p><p>用$A(n)$代表使用上述算法对俩个$n$位十进制数相乘所需要的加减法运算次数。</p><p>除了需要对$n&#x2F;2$位数之间进行三次相乘操作，即$3A(n&#x2F;2)$次乘法运算，上面的公式还需要$5$次加运算和$1$次减运算。因此有递推式：</p><p>当$n&gt;1$时，$A(n)&#x3D;3A(n&#x2F;2)+cn,A(1)&#x3D;1$</p><p>应用本章开头介绍的主定理，得到$A(n)\in \Theta (n^{log_23})$</p><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><p>$\left[<br>\begin{matrix}<br>   c_{00}&amp;c_{01}\c_{10}&amp;c_{11}<br>  \end{matrix}<br>  \right] &#x3D; \left[<br>\begin{matrix}<br>   a_{00}&amp;a_{01}\a_{10}&amp;a_{11}<br>  \end{matrix}<br>  \right] \times \left[\begin{matrix}<br>   b_{00}&amp;b_{01}\b_{10}&amp;b_{11}<br>  \end{matrix}<br>  \right] &#x3D; \left[<br>\begin{matrix}<br>   m_1+m_4-m_5+m_7 &amp; m_3+m_5\m_2+m_4 &amp; m_1+m_3-m_2+m_6<br>  \end{matrix}<br>  \right] $</p><p>其中：</p><p>$m_1 &#x3D; (a_{00}+a_{11})\times(b_{00}+b_{11})$</p><p>$m_2 &#x3D; (a_{10}+a_{11})\times b_{00}$</p><p>$m_3 &#x3D; a_{00}\times(b_{01}-b_{11})$</p><p>$m_4 &#x3D; a_{11}\times(b_{10}-b_{00})$</p><p>$m_5 &#x3D; (a_{00}+a_{01})\times b_{11}$</p><p>$m_6 &#x3D; (a_{10}-a_{00}) \times (b_{00}+ b_{11})$</p><p>$m_7 &#x3D; (a_{01}-a_{11}) \times (b_{10}+ b_{11})$</p><h2 id="分治法解最近对问题和凸包问题"><a href="#分治法解最近对问题和凸包问题" class="headerlink" title="分治法解最近对问题和凸包问题"></a>分治法解最近对问题和凸包问题</h2><h3 id="最近对问题-1"><a href="#最近对问题-1" class="headerlink" title="最近对问题"></a>最近对问题</h3><p>令$P$为笛卡尔平面上$n&gt;1$个点构成的集合，假设集合中的每个点都不一样，且是按照其$x$轴坐标升序排列的。</p><p>$Q$为$P$中集合的点，但是按照其$y$轴坐标升序排列的。</p><p>求最近点对之间的欧几里得距离</p><h4 id="蛮力法-1"><a href="#蛮力法-1" class="headerlink" title="蛮力法"></a>蛮力法</h4><p>当$2&lt;&#x3D;n&lt;&#x3D;3$时，枚举俩个点对，得到最小距离的点对，时间复杂度为$O(n^2)$</p><h4 id="分治求解法"><a href="#分治求解法" class="headerlink" title="分治求解法"></a>分治求解法</h4><p>当$n&gt;3$时，可以利用点集在$x$轴方向上的中位数$m$，在该处作一条垂线，将点集分成大小为$\lceil n&#x2F;2 \rceil 和 \lfloor n&#x2F;2 \rfloor$的俩个子集$P_l$和$P_r$。通过递归求解子问题$P_l$, $P_r$来得到最近点对问题的解。其中$d_l$和$d_r$分别表示在$P_l$和$P_r$中最近对的问题，并定义$d&#x3D;min(d_l,d_r)$</p><h3 id="凸包问题-1"><a href="#凸包问题-1" class="headerlink" title="凸包问题"></a>凸包问题</h3><h1 id="变治法"><a href="#变治法" class="headerlink" title="变治法"></a>变治法</h1><p>本章讨论一组设计方法，基于变换的思想，称为变治法，因为这些方法都是分成俩个阶段工作的。在“变”的阶段，出于这样或者那样的原因，把问题的实例变得更容易求解，然后在第二阶段“治”的阶段，对于实例进行求解。</p><p>主要$3$种类型：</p><p><strong>实例化简</strong>：变换同样问题为一个更简单或更方便的实例</p><p><strong>改变表现</strong>：变换同样实例的不同表现</p><p><strong>问题化简</strong>：变换为另一个问题的实例，这种问题的算法时已知的</p><h2 id="预排序"><a href="#预排序" class="headerlink" title="预排序"></a>预排序</h2><p>对于排序算法有这样一个事实，如果列表时有序的，许多关于列表的问题的更容易求解。为简单起见，假设所有列表都是用数组来实现的。</p><p><strong>检查数组中的元素唯一性</strong></p><p>蛮力法对数组中的元素对进行比较，直到找到俩个相等的元素，或者所有的元素对都已比较完毕，它的最差效率为$\Theta (n^2)$。</p><p>换一种做法，可以预先对数组进行排序，然后只检查它的连续元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PresortElementUniqueness(A[0..n-1]</span><br><span class="hljs-comment">//先对数组排序来解元素唯一性问题</span><br><span class="hljs-comment">//输入：n个可排序元素构成一个数组A[0..n-1]</span><br><span class="hljs-comment">//输出：如果A没有相等元素，返回true,否则返回false</span><br>对数组A排序<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++)&#123;<br><span class="hljs-keyword">if</span>(A[i]==A[i+<span class="hljs-number">1</span>])&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>$T(n)&#x3D;T_{sort}(n)+T_{scan}(n)\in\Theta(nlogn)+\Theta(n)&#x3D;\Theta(nlogn)$</p><p><strong>模式计算</strong></p><p>在给定的数字列表中最经常出现的一个数值称为<strong>模式</strong>。</p><p>如果用蛮力法对计算模式将会对列表进行扫描，并计算它的所有不同值出现的频率。为实现这个思路，可以在另一个列表中存储已经遇到的值和它们出现的频率。不难发现，该算法的最差输入是一个没有相等元素的列表，对于这样一个列表，它的第$i$个元素和目前唯一数值的辅助列表中$i-1$个元素比较，然后再加入到辅助列表中，并把出现频率设为$1$。因此，在创建频率列表时，该算法的最差比较次数为：</p><p>$C(n)&#x3D;\sum_{i&#x3D;1}^n&#x3D;0+1+..+(n-1)&#x3D;\frac {(n-1)n}2\in\Theta(n^2)$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// PresortMode(A[0..n-1])</span><br><span class="hljs-comment">// 先对数组排序来计算它的模式</span><br><span class="hljs-comment">// 输入： 可排序元素构成的数组A[0..n-1]</span><br><span class="hljs-comment">// 输出： 该数组的模式</span><br>i = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前一轮从为止i开始</span><br>modeFrequency = <span class="hljs-number">0</span>;<span class="hljs-comment">//目前为止求出的最高频率</span><br><span class="hljs-keyword">while</span>(i &lt;= n-<span class="hljs-number">1</span>)&#123;<br>runLength = <span class="hljs-number">1</span>;<br>runValue = A[i];<br><span class="hljs-keyword">while</span>(runLength + i &lt;= n-<span class="hljs-number">1</span> &amp;&amp; A[i+runLength]==runValue)&#123;<br>runLength = runLength + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(runLength &gt; modeFrequency)&#123;<br>modeFrequency = runLength;<br>modeValue = runValue;<br>&#125;<br>i += runLength; <br>&#125;<br><span class="hljs-keyword">return</span> modeValue;<br></code></pre></td></tr></table></figure><p><strong>查找问题</strong></p><p>考虑$n$个可排序项构成一个给定数组中查找某个给定值$v$的问题。这里的蛮力接发是顺序查找，最坏情况下需要进行$n$此比较。如果该数组是预先排好序的，我们就可以应用折半查找，最坏情况下只需进行$\lfloor log_2n \rfloor +1$</p><p>假设使用最搞笑的$nlogn排序$，这个查找算法再最差情况下的总运行时间是</p><p>$T(n)&#x3D;T_{sort}(n)+T_{select}(n)&#x3D;\Theta(nlogn)+\Theta(logn)&#x3D;\Theta(nlogn)$</p><p>然而这比顺序查找还要差，对于平均效率来说，也是同样的情况，当然如果需要再同一个列表中查找多次，在排序上花费时间应该是值得的。</p><p>那么如果使得预排序有意义，至少需要进行多少次查找？</p><h2 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h2><p>由俩个线性方程构成的二元联立方程组<br>$$<br>{方程组}\begin{cases}a_{11}x+a_{12}y&#x3D;b_1 \a_{21}x+a_{22}y&#x3D;b_2 \end{cases}<br>$$</p><p>求解的方法是无论用哪个方程，先把一个变量表示为另一个变量的函数，再把这个结果代入另一个方程中，得到一个线性方程，然后用它的解来求出另一个变量的值。</p><p>当需要解一个包含$n$个方程的$n$元联立方程组：<br>$$<br>\begin{equation}<br>\begin{cases}<br>a_{11}x_{1}+a_{12}x_{2}+…+a_{1n}x_{n}&#x3D;b_1\<br>a_{21}x_{1}+a_{22}x_{2}+…+a_{2n}x_{n}&#x3D;b_2\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \vdots\<br>a_{n1}x_{1}+a_{n2}x_{2}+…+a_{nn}x_{n}&#x3D;b_n\<br>\end{cases}<br>\end{equation}<br>$$<br>其中$n$是一个大数，对于俩个联立方程的解法推广到这种方程组上求解显得笨重，高斯消元法：思路是将$n$个线性方程构成的$n$元联立方程组变换为一个等价的方程组（即解和原来的方程组一样），该方程组有着一个上三角的系数矩阵，这种矩阵的主对角线下方元素全部为$0$.</p><p>用矩阵的符号可以表示为$$Ax&#x3D;b \Rightarrow A’x&#x3D;b’$$</p><p>其中</p><p>$$A &#x3D; \left[\begin{array}{}      a_{11}&amp;a_{21}&amp; … &amp;a_{n1}\  a_{21}&amp;a_{22}&amp; … &amp;a_{n2} \  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \  a_{n1}&amp;a_{n2}&amp; … &amp;a_{nn}    \end{array} \right] $$</p><p>$$A’&#x3D;\left[    \begin{array}{}      a’<em>{11}&amp;a’</em>{21}&amp; … &amp;a’<em>{n1}\  0&amp;a’</em>{22}&amp; … &amp;a’<em>{n2} \  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \  0&amp;0&amp; … &amp;a’</em>{nn}    \end{array} \right]$$</p><p><strong>前向消去算法</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">ForwardElimination<span class="hljs-params">(A[1..n,1..n],b[1..n])</span><br><span class="hljs-string">//</span>对一个方程组的系数矩阵A应用高斯消去法<br><span class="hljs-string">//</span>用该方程组右边的值构成的向量b来扩展该矩阵<br><span class="hljs-string">//</span>输入：矩阵A[1.<span class="hljs-string">.n</span>,1.<span class="hljs-string">.n</span>]和列向量b[1.<span class="hljs-string">.n</span>]<br><span class="hljs-string">//</span>输出：一个代替A的上三角形等价矩阵图，相应的右边的值位于第<span class="hljs-params">(n+1)</span>列中<br>for<span class="hljs-params">(int <span class="hljs-attr">i</span> = 1; i &lt; n; ++i)</span>&#123;<br>A[i,n+1] = b[i]<br>&#125;<br>for<span class="hljs-params">(int <span class="hljs-attr">i</span> = 1; i &lt; n-1; ++i)</span>&#123;<br>for<span class="hljs-params">(int <span class="hljs-attr">j</span> = i+1; j &lt; n; ++j)</span>&#123;<br>for<span class="hljs-params">(int <span class="hljs-attr">k</span> = n+1; k &gt; i; k--)</span>&#123;<br>A[j,k] = A[j,k] - A[i,k]*A[j,i]<span class="hljs-string">/A</span>&#123;i,i]<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的俩个事实</p><ol><li>并不总是正确的，如果A[i,i]&#x3D;0，不能作除数；在该算法的第$i$次迭代中不能把$i$作为基点。同时，$A[i,i]$可能非常小，那么$A[j,i]&#x2F;A[i,i]$很大，以至于$A[j,k]$的新值会因为舍入误差而歪曲，这个误差是在俩个数量级相差非常大的时候相减时发生的。</li><li>最内层的循环效率十分低</li></ol><p>为了避免问题1，可以每次都去找第$i$列系数的绝对值最大的行，然后把它作为第$i$次迭代的基点。这种修改称为<strong>部分选主元法</strong>，它能保证比例因子的绝对值永远不会大于1.</p><p><strong>优化后的算法</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">BetterForwardElimination</span><span class="hljs-params">(A[<span class="hljs-number">1</span>..n,<span class="hljs-number">1</span>..n],b[<span class="hljs-number">1</span>..n])</span></span><br><span class="hljs-comment">// 用部分选主元法实现高斯消去法</span><br><span class="hljs-comment">// 输入：矩阵A[1..n,1..n]和列向量b[1..n]</span><br><span class="hljs-comment">// 输出：一个代替A的上三角形等价矩阵图，相应的右边的值位于第(n+1)列中</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">1</span>; i &lt; n; ++i)</span></span>&#123;<br>A<span class="hljs-selector-attr">[i,n+1]</span> = <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[i]</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架</title>
    <link href="/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/10/24/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p> java中的集合包括三大类，它们是Set、List和Map。它们都处于java.util包中，Set、List和Map都是接口。 本文参考源码为 jdk1.7u79。开始之前，先简单描述下类之间的关系，方便后续看类图。</p><table><thead><tr><th>集合架构</th><th>特性</th></tr></thead><tbody><tr><td>Collection</td><td>接口存储一组不唯一，无序的对象</td></tr><tr><td>List</td><td>接口存储一组不唯一，有序（索引顺序）的对象</td></tr><tr><td>Set</td><td>接口存储一组唯一，无序的对象</td></tr><tr><td>Map</td><td>接口存储一组键值对象，提供key到value的映射Key 唯一 无序；value  不唯一 无序</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">继承关系    —▷    实线 + 空心三角形    鸟 —▷ 动物；鸟继承动物<br>实现接口    •••▷    虚线 + 空心三角形    大雁 •••▷ 飞翔；大雁实现了飞翔接口<br>实现接口    —○    棒棒糖表示法    唐老鸭 —○ 讲人话；唐老鸭实现讲人话接口<br>关联关系    —&gt;    实线剪头    企鹅 —&gt; 气候；企鹅需要‘知道’气候的变化<br>依赖关系    •••&gt;    虚线剪头    动物 •••&gt; 氧气；动物依赖于氧气<br>聚合关系    ◇—&gt;    空心菱形 + 实线剪头    大雁 ◇—&gt; 翅膀；部分和整体的关系<br>合成关系    ◆—&gt;    实心菱形 + 实线剪头    大雁 ◆—&gt; 雁群；<span class="hljs-selector-tag">A</span>包含<span class="hljs-selector-tag">B</span>，但<span class="hljs-selector-tag">B</span>不是<span class="hljs-selector-tag">A</span>的一部分<br></code></pre></td></tr></table></figure><h2 id="接口继承树"><a href="#接口继承树" class="headerlink" title="接口继承树"></a>接口继承树</h2><p>&#x2F;&#x2F; Todo: 待补充</p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h2><p>List：有序  不唯一（可重复）</p><p>ArrayList：在内存中分配连续的空间，实现了长度可变的数组</p><ul><li><p>优点：遍历元素和随机访问元素的效率比较高</p></li><li><p>缺点：添加和删除需大量移动元素效率低，按照内容查询效率低</p></li></ul><p>LinkedList：采用双向链表存储方式。</p><ul><li><p>缺点：遍历和随机访问元素效率低下</p></li><li><p>优点：插入、删除元素效率比较高（但是前提也是必须先低效率查询才可。如果插入删除发生在头尾可以减少查询次数）</p></li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h4><p>底层实现：一个长度可以动态增长的Object数组 </p><p>扩容： 容量不足时进行扩容，默认扩容50%。如果扩容50%还不足容纳新增元素，就扩容为能容纳新增元素的最小数量。</p><p>遍历： ArrayList中提供了一个内部类Itr，实现了Iterator接口，实现对集合元素的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestArrayList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个集合对象</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList();</span><br>        <span class="hljs-comment">//实例1</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">//泛型</span><br>        <span class="hljs-comment">//List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-number">80</span>);<span class="hljs-comment">//末尾添加</span><br>        list.add(<span class="hljs-number">90</span>);<span class="hljs-comment">//自动填装 int ---- Integer</span><br>        list.add(<span class="hljs-number">80</span>);<br><br>        list.add(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<span class="hljs-comment">//指定索引添加，底层发生大量元素后移，并且可能扩容</span><br><br>        <span class="hljs-comment">//元素的数量--list.size()</span><br>        System.out.println(list.size());<br>        <span class="hljs-comment">//获取指定索引的元素--list.get(1)</span><br>        System.out.println(list.get(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//遍历元素</span><br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br>        System.out.println(list.toString());<br>        <span class="hljs-comment">//方法1：for循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) list.get(i);<br>            System.out.println(i + <span class="hljs-string">&quot;---&gt;&quot;</span>+ elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法2：for-each循环</span><br>        <span class="hljs-keyword">for</span>(Object elem:list)&#123;<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法3：Iterator</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)it.next();<br>            System.out.println(elem);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;==================&quot;</span>);<br><br>        <span class="hljs-comment">//方法4：lambda表达式—+流式编程（JDK1。8）</span><br>        <span class="hljs-comment">//list.forEach((i)-&gt;System.out.println(i));</span><br>        list.forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在代码实例1，可知添加元素时可以加入任何类型—&gt;不安全；获取元素时需要强制类型转换—&gt;繁琐；为了实现安全和简单，通过使用泛型gerneic。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="对比ArrayList"><a href="#对比ArrayList" class="headerlink" title="对比ArrayList"></a>对比ArrayList</h4><p>问题1：将ArrayList替换成LinkedList之后，不变的是什么？</p><p>（1）运算结果没有变</p><p>（2）执行的功能代码没有变</p><p>问题2：将ArrayList替换成LinkedList之后，变化的是什么？</p><p>（1）底层的结构变了</p><p>​ArrayList：数组 LinkedList：双向链表</p><p>具体的执行过程变化了 list.add(2,99)</p><p>​ArrayList：大量的后移元素 </p><p>LinkedList：不需要大量的移动元素，修改节点的指向即可</p><p>问题3：到底是使用ArrayList还是LinkedList</p><p>（1）根据使用场合而定</p><p>（2）大量的根据索引查询的操作，大量的遍历操作（按照索引0–n-1逐个查询一般），建议使用ArrayList</p><p>（3）如果存在较多的添加、删除操作，建议使用LinkedList</p><p>问题4：LinkedList增加了哪些方法</p><p>（1）增加了对添加、删除、获取首尾元素的方法</p><p>（2）addFirst()、addLast()、removeFirst()、removeLast()、getFirst()、getLast()、</p><h4 id="源码理解-1"><a href="#源码理解-1" class="headerlink" title="源码理解"></a>源码理解</h4><ol><li>底层实现：双向链表</li><li>LinkedList实现了Deque接口，所以除了可以作为线性表来使用外，还可以当做队列和栈来使用</li><li>链表节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLinkedList1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//LinkedList&lt;Integer&gt; list = new LinkedList();</span><br>        <span class="hljs-comment">//ArrayList list = new ArrayList(100);</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        list.add(<span class="hljs-number">80</span>);<br>        list.add(<span class="hljs-number">70</span>);<br>        list.add(<span class="hljs-number">90</span>);<br>        list.remove(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//list.addAll()</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>);<br>        System.out.println(list.size());<br>        System.out.println(list.isEmpty());<br>        System.out.println(list.indexOf(<span class="hljs-number">780</span>));<br>        System.out.println(list.contains(<span class="hljs-number">80</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>);<br>        System.out.println(elem);<br>        System.out.println(list);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> list.iterator();<br><br>        <span class="hljs-comment">//list.addFirst(60);</span><br>        list.add(<span class="hljs-number">0</span>,<span class="hljs-number">60</span>);<br>        <span class="hljs-comment">//list.addLast(50);</span><br>        list.add(<span class="hljs-number">50</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map：存储的键值对映射关系，根据key可以找到value</p><p>HashMap: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：key无序</p></li></ul><p>LinkedHashMap: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>key有序（添加顺序）</li></ul><p>TreeMap: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：key有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashMap快</p></li></ul><h3 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h3><p><strong>引入哈希表</strong></p><ol><li><p>在无序数组中按照内容查找，效率低下，时间复杂度是O（n） </p></li><li><p>在有序数组中按照内容查找，可以使用折半查找，时间复杂度O（log2n）</p></li><li><p>在二叉平衡树中按照内容查找，时间复杂度O（log2n）</p></li></ol><p>在数组中按照索引查找，不进行比较和计数，直接计算得到，效率最高，时间复杂度O（1）</p><ol start="4"><li>哈希表：按照内容查找，能否也不进行比较，而是通过计算得到地址，实现类似数组按照索引查询的高效率呢O（1）</li></ol><p><strong>哈希表的结构和特点</strong></p><p>hashtable 也叫散列表；特点：快  很快  神奇的快</p><p>结构：结构有多种。最流行、最容易理解：顺序表+链表</p><p>主结构：顺序表，每个顺序表的节点在单独引出一个链表</p><p><strong>哈希表是如何添加数据的</strong></p><ol><li><p>计算哈希码(调用hashCode(),结果是一个int值，整数的哈希码取自身即可)</p></li><li><p>计算在哈希表中的存储位置  y&#x3D;k(x)&#x3D;x%11</p></li></ol><p> x:哈希码  k(x) 函数y：在哈希表中的存储位置</p><ol start="3"><li>存入哈希表</li></ol><p>（1）情况1：一次添加成功</p><p>（2）情况2：多次添加成功（出现了冲突，调用equals()和对应链表的元素进行比较，比较到最后，结果都是false，创建新节点，存储数据，并加入链表末尾）</p><p>（3） 情况3：不添加（出现了冲突，调用equals()和对应链表的元素进行比较， 经过一次或者多次比较后，结果是true，表明重复，不添加）</p><p>结论1：哈希表添加数据快（3步即可，不考虑冲突）</p><p>结论2：唯一、无序</p><p><strong>哈希表是如何查询数据的</strong></p><p>  和添加数据的过程是相同的</p><p>（1）情况1：一次找到  23  86  76</p><p>（2）情况2：多次找到  67  56  78</p><p>（3）情况3：找不到  100 200</p><p> 结论1：哈希表查询数据快       </p><p><strong>hashCode和equals到底有什么神奇的作用</strong></p><p>hashCode():计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置</p><p>equals()：添加时出现了冲突，需要通过equals进行比较，判断是否相同；查询时也需要使用equals进行比较，判断是否相同  </p><p><strong>各种类型数据的哈希码应该如何获取 hashCode()</strong></p><p>int  取自身 看Integer的源码</p><ol><li><p>double  3.14 3.15  3.145  6.567  9.87  取整不可以  看Double的源码</p></li><li><p>String java  oracle  java  将各个字符的编码值相加不可以</p></li></ol><p>​     abc cba  bac  a:97  b:98  c:99</p><p>​     abc 1<em>97+2</em>98+3*99   </p><p> cba 1<em>99+2</em>98+3*97</p><p>Student 先各个属性的哈希码，进行某些相加相乘的运算</p><p>​    int id    String name      int age      double score;</p><h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><ol><li><p>哈希表的长度和表中的记录数的比例–装填因子：</p><p>如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费， 如果选取小了的话，则容易造成冲突。 在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况时可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。</p></li></ol><p>​    <strong>装填因子&#x3D;表中的记录数&#x2F;哈希表的长度， 4&#x2F; 16  &#x3D;0.25  8&#x2F; 16&#x3D;0.5</strong></p><p>​    如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。 有相关文献证明当装填因子在0.5左右时候，Hash性能能够达到最优。 </p><p><strong>因此，一般情况下，装填因子取经验值0.5</strong>。</p><ol start="2"><li>哈希函数的选择</li></ol><p>​     直接定址法   平方取中法  折叠法  <strong>除留取余法（y &#x3D; x%11）</strong></p><ol start="3"><li>处理冲突的方法</li></ol><p>​      链地址法  开放地址法  再散列法  建立一个公共溢出区</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>Set：无序  唯一（不重复）</p><p>HashSet: 采用Hashtable哈希表存储结构（神奇的结构）</p><ul><li><p>优点：添加速度快  查询速度快 删除速度快</p></li><li><p>缺点：无序</p></li></ul><p>LinkedHashSet: 采用哈希表存储结构，同时使用链表维护次序</p><ul><li>有序（添加顺序）</li></ul><p> TreeSet: 采用二叉树（红黑树）的存储结构</p><ul><li><p>优点：有序  查询速度比List快（按照内容查询）</p></li><li><p>缺点：查询速度没有HashSet快</p></li></ul><h3 id="源码理解-2"><a href="#源码理解-2" class="headerlink" title="源码理解"></a>源码理解</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h4><p>HashSet的底层使用的是HashMap，所以底层结构也是哈希表</p><p>HashSet的元素到HashMap中做key，value统一是同一个Object()</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><strong>TreeSet</strong></h4><p>TreeSet的底层使用的是TreeMap，所以底层结构也是红黑树</p><p>TreeSet的元素e是作为TreeMap的key存在的，value统一为同一个 Object()</p><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>内部比较器只能定义一个，一般将使用频率最高的比较规则定义为内部比较器的规则；外部比较器可以定义多个； </p><p>注意1：对于外部比较器，如果使用次数较少，可以通过匿名内部类来实现。</p><p>注意2：需要比较的场合才需要实现内部比较器或者外部比较器，比如排序、比如TreeSet中数据的存储和查询，在HashSet、LinkedHashSet、ArrayList中存储元素，不需要实现内部比较器或者外部比较器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashSet  哈希表  唯一  无序</p><p>LinkedHashSet  哈希表+链表  唯一 有序（添加顺序）</p><p>TreeSet  红黑树 一种二叉平衡树 唯一  有序（自然顺序）</p><p>List针对Collection增加了一些关于索引位置操作的方法 get(i) add(i,elem),remove(i),set(i,elem)</p><p>Set是无序的，不可能提供关于索引位置操作的方法，set针对Collection没有增加任何方法</p><p>List的遍历方式：for循环、for-each循环、Iterator迭代器、流式编程forEach</p><p>Set的遍历方式： for-each循环、Iterator迭代器、流式编程forEach</p><h2 id="多线程下注意事项"><a href="#多线程下注意事项" class="headerlink" title="多线程下注意事项"></a>多线程下注意事项</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Vector 或者 CopyOnWriteArrayList 是两个线程安全的List实现。</p><p>ArrayList 不是线程安全的。若必须使用，则需要使用Collections.synchronizedList(List list)进行包装。</p><h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>        &#125;, String.valueOf(i)).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ArrayList线程不安全主要是由它的add()方法引起的.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Appends the specified element to the end of this list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param e element to be appended to this list</span><br><span class="hljs-comment">     * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-comment">//ArrayList的add()源码</span><br><span class="hljs-comment">//ArrayList的add()方法主要有两步，ensureCapacityInternal(size + 1);和elementData[size++] = e;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 确保容量足够，不够则进行扩容</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">// 将元素添加进列表的元素数组里面</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景一：数组越界异常 ArrayIndexOutOfBoundsException</span><br><span class="hljs-comment">单线程下是完全没有问题的，但在多线程中，有可能出现一种情况：假设当前ArrayList的长度是9（源码中ArrayList的初始容量是10），线程A、B同时执行add()方法。当线程A执行ensureCapacityInternal(size + 1);时，因为size等于9，容量为10，线程A判断不需要扩容，此时CPU调度线程B执行，同样执行ensureCapacityInternal(size + 1);，此时size还是等于9（线程A没有改变size的值），线程B也判断不需要扩容，然后线程B继续执行elementData[size++] = e;将元素e放到elementData[9]中，再执行size++并返回，此时size的值等于10。线程B执行完毕后，线程A继续往下执行elementData[size++] = e;，此时size的值是10，相当于线程A将元素e放到elementData[10]中，但ArrayList的容量也只是10（下标只有0-9）,这样就会抛出越界异常。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景二：元素值覆盖和为空问题</span><br><span class="hljs-comment">这个场景主要是与elementData[size++] = e;这句代码有关，因为它不是一个原子操作，有可能被其他线程中断，这句代码至少分为两步：</span><br><span class="hljs-comment">elementData[size] = e；</span><br><span class="hljs-comment">size = size + 1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">当多线程执行这段代码时，有可能出现这种场景：假设当前size=1，线程A、B执行这段代码，线程A执行elementData[size] = e；后，e被放在elementData[1]中，此时线程A中断，CPU调度线程B，线程B执行elementData[size] = e；，此时size的值还是1（线程A没来得及执行size+1操作就被中断），所以线程B还是把元素放在elementData[1]中，覆盖了线程A已经存放的值，然后对size进行+1操作并返回，此时size=2。线程B执行完后，CPU调度线程A继续执行，线程A对size+1，此时size就变成3。最终，两个线程执行完后，期待的结果是elementData[1]、elementData[2]各有一个元素，现在却是两个线程都把元素放在elementData[1]上，且线程B覆盖了线程A的元素，而elementData[2]为null。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h3><p>1.使用Vector（ArrayList所有方法加synchronized，太重）。</p><p>2.使用Collections.synchronizedList()转换成线程安全类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>    ...<br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// 必须在同步块中</span><br>    <span class="hljs-keyword">while</span> (i.hasNext())<br>        foo(i.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>3.使用java.concurrent.CopyOnWriteArrayList（推荐）。</p><p> <strong>CopyOnWriteArrayList</strong>：JUC的类，通过<strong>写时复制</strong>来实现<strong>读写分离</strong>。如add()方法，就是先<strong>复制</strong>一个新数组，长度为原数组长度+1，然后将新数组最后一个元素设为添加的元素。</p><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//得到旧数组</span><br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//复制新数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//设置新元素</span><br>        newElements[len] = e;<br>        <span class="hljs-comment">//设置新数组</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 优点：CopyOnWriteArrayList属于线程安全的，并发的读是没有异常的，读写操作被分离。缺点：在写入时不止加锁，使用了Arrays.copyOf()进行了数组复制，性能开销较大，遇到复杂对象也会导致内存占用较大。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>HashSet和TreeSet都不是线程安全的，对应的有线程安全类CopyOnWriteSet这个线程安全类，类底层维护了一个CopyOnWriteArrayList数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArraySet</span><span class="hljs-params">()</span> &#123;<br>    al = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;E&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p>HashMap不是线程安全的，Hashtable是线程安全的，但是跟Vector类似，太重量级。所以也有类似CopyOnWriteMap，叫ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContainerNotSafeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        listNotSafe();<br>        setNoSafe();<br>        mapNotSafe();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mapNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Map&lt;String,String&gt; map=new HashMap&lt;&gt;();</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + map);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNoSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//Set&lt;String&gt; set=new HashSet&lt;&gt;();</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + set);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listNotSafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>));<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t&quot;</span> + list);<br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_39240837/article/details/108006486">Java中的Set、Map、List等数据结构的存取以及基本使用</a></p><p><a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=49">黑马程序员Java数据结构与算法，全网资料最全，154张数据结构图</a></p><p><a href="https://github.com/CarpenterLee/JCFInternals">Java Collections Framework Internals</a></p><p><a href="https://blog.csdn.net/luweibin19/article/details/106215036/">JAVA list、set、map等集合类线程不安全的问题及解决方法</a></p><p><a href="https://blog.csdn.net/weixin_43932465/article/details/103006622">java多线程环境下数据结构的安全问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java踩坑小记</title>
    <link href="/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/10/24/Java%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>迭代器Iterator在遍历时能remove但是不能往集合里添加元素问题。我们都知道如果是像List集合这样的，如果用循环遍历，访问没问题，在这期间如果删除就会报错，这个问题是因为你改变了集合的长度，但是遍历用的原来的长度的原因，</p><p>所以Iterator优秀点就出现了，它的出现让你可以在遍历时删除你想删除的元素，它用while循环遍历，它往下循环也就是while里的判定条件是Iterator.hasNext() 返回的是boolean类型，看这个也明白，它是在你想继续往下遍历时先查询是否存在下一个元素。</p><p>而且集合转Iterator也不麻烦，集合本身就有这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Iterator&lt;泛型&gt; it = 集合.iterator();<br></code></pre></td></tr></table></figure><p>敲黑板 下面要讲两点重要的还容易忘的误区</p><p>如果在遍历时删除元素不要用集合的 remove() 方法，要用迭代器的 iterator.remove() 方法，虽然没有参数，但是它移除的是当前的。 在用迭代器迭代的时候千万不要修改集合和给集合添加元素，这样会报错，因为你迭代时添加元素会破坏迭代器的结构，所以会报错，因为拿ArrayList为例，在遍历到中间的时候，你往集合头部插入元素，集合的结构肯定变吧，那迭代器的数据结构也会跟着变，它就会主动报错，，但是删除就没问题了，因为你用的是迭代器的删除方法，而迭代器没有添加元素的方法</p><p>参考链接：<a href="https://blog.csdn.net/weixin_43113679/article/details/99775014">https://blog.csdn.net/weixin_43113679/article/details/99775014</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shuffle 算法</title>
    <link href="/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Shuffle-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>其中一种常见的洗牌算法是Fisher-Yates洗牌算法，我将用它来描述原理，并给出Java实现。</p><p><strong>Fisher-Yates洗牌算法原理：</strong></p><ol><li>从数组中最后一个元素开始，从后往前遍历每个元素。</li><li>对于当前遍历到的元素，随机生成一个不超过当前下标的随机数（假设为randIdx）。</li><li>将当前元素与数组中下标为randIdx的元素交换位置，将当前元素放到一个随机位置。</li><li>继续遍历上一个位置的元素，重复步骤2至步骤3，直到第一个元素被处理。</li></ol><p><strong>Fisher-Yates洗牌算法时间复杂度和空间复杂度：</strong></p><p>时间复杂度：洗牌算法的时间复杂度是O(n)，其中n为数组或集合中的元素数量。因为每个元素都需要进行随机交换，而总的交换次数是n次。</p><p>空间复杂度：洗牌算法的空间复杂度是O(1)，因为算法在原地对数组或集合进行交换，没有使用额外的数据结构。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShuffleAlgorithm</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shuffle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> array.length;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randIdx</span> <span class="hljs-operator">=</span> random.nextInt(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成[0, i]之间的随机数</span><br>            swap(array, i, randIdx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>        array[i] = array[j];<br>        array[j] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        shuffle(nums);<br>        System.out.println(<span class="hljs-string">&quot;Shuffled array: &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra 算法</title>
    <link href="/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/Dijkstra-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>贪心:找到该点到所有点的最短路径</strong></p><p>俩个集合, 一个(dis)是源点到当前该点的最短路径,一个(visited)是源点到该点是否已经找到最短路径; 初始时设定dis[] &#x3D; INT_MAX, dis[start] &#x3D; 0,后续需要比较是否可以找到比当前dis[i]小的值 每轮循环分别找到当前未被访问的点中到源点最短距离的点,加入visited集合中 每轮循环更新dis集合,根据确定的minpos,找到未被访问的点,且小于dis[minpos]+adj[minpos][i]时更新;</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 邻接矩阵-无向图</span><br><span class="hljs-comment">// adj[i][j] == 0 表示 i j 不相邻</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj = &#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>&#125;, <br>    &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 基于邻接矩阵dijkstra求解最短路</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj, <span class="hljs-type">int</span>&amp; start, <span class="hljs-type">int</span>&amp; end, vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = adj.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(start &gt;= n || start &lt; <span class="hljs-number">0</span> || end &gt;= n || end &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n, INT_MAX)</span></span>;    <span class="hljs-comment">// 当前点到源点的最短距离</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// 访问集合</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;       <span class="hljs-comment">// 当前点最短路径的前一节点</span><br><br>    dis[start] = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 保证初始查找点为源点start</span><br>    pre[start] = start;          <span class="hljs-comment">// 设置源点的prepos为start</span><br><br>    <span class="hljs-keyword">for</span>(;;)<br>    &#123;<br>        <span class="hljs-type">int</span> mindis = INT_MAX;<br>        <span class="hljs-type">int</span> minpos = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 找到本轮查找的初始点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i] &amp;&amp; dis[i] &lt; mindis)<br>            &#123;<br>                mindis = dis[i];<br>                minpos = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不存在邻接路径</span><br>        <span class="hljs-keyword">if</span>(minpos == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        visited[minpos] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果终点在确认集合中，则退出查找,保存路径</span><br>        <span class="hljs-keyword">if</span>(visited[end])<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = end;<br>            path.<span class="hljs-built_in">push_back</span>(end);<br>            <span class="hljs-keyword">while</span>(pre[tmp] != start &amp;&amp; pre[tmp] != <span class="hljs-number">-1</span>)<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(pre[tmp]);<br>                tmp = pre[tmp];<br>            &#125;<br>            path.<span class="hljs-built_in">push_back</span>(start);<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; adj[minpos][j] &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j] &gt; dis[minpos] + adj[minpos][j])<br>                &#123;<br>                    dis[j] = dis[minpos] + adj[minpos][j];<br>                    pre[j] = minpos;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dis[end];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printpath</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;path)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">// 打印路径</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i != path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span> &lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; path[i]+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;      <br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> start, end;<br>    cin &gt;&gt; start &gt;&gt; end;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-type">int</span> mindis = <span class="hljs-built_in">dijkstra</span>(adj, start, end, path);<br>    cout &lt;&lt; mindis &lt;&lt; endl;<br>    <span class="hljs-built_in">printpath</span>(path);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A* 算法</title>
    <link href="/2023/10/24/A-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/24/A-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>A*算法是一种常用于图形搜索和路径规划的启发式搜索算法。它通过综合考虑实际代价和估计代价，来寻找从起点到目标节点的最优路径。</p><p>算法步骤：</p><ol><li>创建两个空列表：Open列表和Closed列表。</li><li>将起点添加到Open列表。</li><li>重复以下步骤，直到找到目标节点或Open列表为空： a. 从Open列表中选择估计代价最小的节点，将其移动到Closed列表。 b. 遍历该节点的相邻节点：<ul><li>如果相邻节点已经在Closed列表中，跳过它。</li><li>如果相邻节点不在Open列表中，计算其实际代价（从起点到当前节点的代价）和估计代价（从当前节点到目标节点的估计代价），并将其添加到Open列表。</li><li>如果相邻节点已经在Open列表中，检查经过当前节点到达该相邻节点的路径是否更优，如果更优，则更新其实际代价和父节点。</li></ul></li><li>如果Open列表为空，表示没有找到目标节点，搜索失败；否则，从目标节点开始，沿着父节点指针一直回溯到起点，即可得到最优路径。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> g; <span class="hljs-comment">// Actual cost from start node to this node</span><br>    <span class="hljs-type">int</span> h; <span class="hljs-comment">// Heuristic cost from this node to the goal node</span><br>    <span class="hljs-type">int</span> f; <span class="hljs-comment">// f = g + h</span><br>    Node parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.g = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.h = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.f = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.parent = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AStarAlgorithm</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] grid; <span class="hljs-comment">// 2D array representing the map/grid</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cols;<br>    <span class="hljs-keyword">private</span> Node startNode;<br>    <span class="hljs-keyword">private</span> Node goalNode;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; openList;<br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; closedList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AStarAlgorithm</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> startX, <span class="hljs-type">int</span> startY, <span class="hljs-type">int</span> goalX, <span class="hljs-type">int</span> goalY)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.rows = grid.length;<br>        <span class="hljs-built_in">this</span>.cols = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.startNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(startX, startY);<br>        <span class="hljs-built_in">this</span>.goalNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(goalX, goalY);<br>        <span class="hljs-built_in">this</span>.openList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.closedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Node&gt; <span class="hljs-title function_">findPath</span><span class="hljs-params">()</span> &#123;<br>        openList.add(startNode);<br><br>        <span class="hljs-keyword">while</span> (!openList.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> findLowestFInOpenList();<br>            openList.remove(current);<br>            closedList.add(current);<br><br>            <span class="hljs-keyword">if</span> (current.x == goalNode.x &amp;&amp; current.y == goalNode.y) &#123;<br>                <span class="hljs-keyword">return</span> reconstructPath(current);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip current node</span><br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborX</span> <span class="hljs-operator">=</span> current.x + i;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">neighborY</span> <span class="hljs-operator">=</span> current.y + j;<br><br>                    <span class="hljs-keyword">if</span> (neighborX &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborX &lt; rows &amp;&amp; neighborY &gt;= <span class="hljs-number">0</span> &amp;&amp; neighborY &lt; cols) &#123;<br>                        <span class="hljs-keyword">if</span> (grid[neighborX][neighborY] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip obstacles</span><br><br>                        <span class="hljs-type">Node</span> <span class="hljs-variable">neighbor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(neighborX, neighborY);<br>                        <span class="hljs-keyword">if</span> (closedList.contains(neighbor)) <span class="hljs-keyword">continue</span>;<br><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">tentativeG</span> <span class="hljs-operator">=</span> current.g + <span class="hljs-number">1</span>; <span class="hljs-comment">// Assuming each move has a cost of 1 (can be modified for different costs)</span><br><br>                        <span class="hljs-keyword">if</span> (!openList.contains(neighbor) || tentativeG &lt; neighbor.g) &#123;<br>                            neighbor.parent = current;<br>                            neighbor.g = tentativeG;<br>                            neighbor.h = calculateHeuristic(neighbor);<br>                            neighbor.f = neighbor.g + neighbor.h;<br><br>                            <span class="hljs-keyword">if</span> (!openList.contains(neighbor)) &#123;<br>                                openList.add(neighbor);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// Path not found</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">findLowestFInOpenList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> openList.stream().min(Comparator.comparingInt(node -&gt; node.f)).orElse(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateHeuristic</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// Here, we can use any heuristic function (e.g., Manhattan distance, Euclidean distance, etc.)</span><br>        <span class="hljs-keyword">return</span> Math.abs(node.x - goalNode.x) + Math.abs(node.y - goalNode.y);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;Node&gt; <span class="hljs-title function_">reconstructPath</span><span class="hljs-params">(Node current)</span> &#123;<br>        List&lt;Node&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            path.add(<span class="hljs-number">0</span>, current);<br>            current = current.parent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] grid = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startX</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startY</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalX</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">goalY</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>        <span class="hljs-type">AStarAlgorithm</span> <span class="hljs-variable">aStar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AStarAlgorithm</span>(grid, startX, startY, goalX, goalY);<br>        List&lt;Node&gt; path = aStar.findPath();<br><br>        <span class="hljs-keyword">if</span> (path != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Node node : path) &#123;<br>                System.out.println(<span class="hljs-string">&quot;(&quot;</span> + node.x + <span class="hljs-string">&quot;, &quot;</span> + node.y + <span class="hljs-string">&quot;)&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Path not found!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/10/24/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>install node.js</p><p>install git</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h2 id="流程搭建"><a href="#流程搭建" class="headerlink" title="流程搭建"></a>流程搭建</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>新建一个文件夹，存放博客文件，如取名为&#x2F;blog</p><p>在&#x2F;blog文件夹下安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i hexo-cli -g<br></code></pre></td></tr></table></figure><p>验证hexo是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>初始化文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>安装必备组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm installs<br></code></pre></td></tr></table></figure><p>生成静态网页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br></code></pre></td></tr></table></figure><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s<br></code></pre></td></tr></table></figure><h3 id="github远程部署"><a href="#github远程部署" class="headerlink" title="github远程部署"></a>github远程部署</h3><p>新建一个远程仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/username/u</span>sername.github.io.git<br></code></pre></td></tr></table></figure><p>配置&#x2F;blog下的_config.yaml中</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/username/username.github.io.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p>远程部署</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。</p><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> your-hexo-site</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></code></pre></td></tr></table></figure><p>启用主题</p><p>与所有 Hexo 主题启用的模式一样。 当 克隆&#x2F;下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">theme:</span> <span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>验证主题</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><p>配置主题配置文件</p><h2 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h2><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><h3 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h3><p>新建一个branch并设置为默认分支,比如新分支叫hexo</p><p>克隆github仓库到本地，将原来的博客根目录下的文件拷贝过来（除.deploy_git, node_modules&#x2F;, public&#x2F;），</p><p>确认.gitignore内容</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></td></tr></table></figure><p>push源文件到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .<br>git commit -m &quot;add branch&quot;<br>git push<br></code></pre></td></tr></table></figure><p>在当前文件夹安装hexo，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br>hexo -v ## 验证下是否安装成功<br>npm install<br></code></pre></td></tr></table></figure><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li>npm install -g hexo-cli 异常</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ npm install -<span class="hljs-keyword">g</span> hexo-<span class="hljs-keyword">cli</span><br>npm <span class="hljs-keyword">ERR</span>! code EEXIST<br>npm <span class="hljs-keyword">ERR</span>! path C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! EEXIST: <span class="hljs-keyword">file</span> already exists<br>npm <span class="hljs-keyword">ERR</span>! <span class="hljs-keyword">File</span> exists: C:\Users\Administrator\AppData\Roaming\npm\hexo.ps1<br>npm <span class="hljs-keyword">ERR</span>! Remove the existing <span class="hljs-keyword">file</span> and try again, or <span class="hljs-keyword">run</span> npm<br>npm <span class="hljs-keyword">ERR</span>! with --force to overwrite files recklessly.<br><br>npm <span class="hljs-keyword">ERR</span>! A complete <span class="hljs-keyword">log</span> of this <span class="hljs-keyword">run</span> can be found <span class="hljs-keyword">in</span>:<br>npm <span class="hljs-keyword">ERR</span>!     C:\Users\Administrator\AppData\<span class="hljs-keyword">Local</span>\npm-cache\_logs\2023-10-24T05_13_02_159Z-debug-0.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p>这是由于之前可能装过hexo，需要在npm的appdata中删除原有的hexo modules</p><ul><li>hexo主题切换导致乱码</li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&#123;% extends <span class="hljs-string">&#x27;_layout.swig&#x27;</span> %&#125; &#123;% <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;_macro/post.swig&#x27;</span> as post_template %&#125;<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>..<br></code></pre></td></tr></table></figure><p>hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>重新生成</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean          <br>hexo <span class="hljs-keyword">generate</span>      <br>hexo server<br></code></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">github+hexo搭建个人博客</a></p><p><a href="https://www.cnblogs.com/lanhualan/p/14588669.html">hexo主题切换乱码问题解决</a></p><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E5%88%9B%E5%BB%BA%E3%80%8C%E5%85%B3%E4%BA%8E%E9%A1%B5%E3%80%8D">fluid主题配置</a></p><p><a href="https://dora-cmon.github.io/posts/454ba26/">hexo跨平台搭建</a></p>]]></content>
    
    
    <categories>
      
      <category>运维部署</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
